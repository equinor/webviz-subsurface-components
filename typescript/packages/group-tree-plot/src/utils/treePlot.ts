/**
 * Utilities for handling the tree nodes generated by d3
 */

import type { D3TreeEdge, D3TreeNode, RecursiveTreeNode } from "../types";
import type { HierarchyNode } from "d3";

/**
 * Computes a unique node identifier that should be unique across the entire tree
 * @param node A node in the tree
 * @returns A unique identifier
 */
export function computeNodeId(node: HierarchyNode<RecursiveTreeNode>): string {
    // It's technically possible for a group to have the same name as a well, so it should be enough to simply append the type in front of the label
    const type = node.data.node_type;
    const label = node.data.node_label;

    return `${type}__${label}`;
}

/**
 * Computes an identifier for a link that should be unique across the entire tree
 * @param link A link in the tree
 * @returns A unique path identifier
 */
export function computeLinkId(link: D3TreeEdge): string {
    return `path ${computeNodeId(link.target)}`;
}

/**
 * Formats a value from a node to either N/A, or to a number-string with decimals removed
 * @param value A number or null
 * @returns A formatted string
 */
export function printTreeValue(value: number | null): string {
    if (value === null) return "N/A";
    else return value.toFixed(0);
}

/**
 * Given a node in a tree, this method finds that node's closest visible ancestor in another tree-structure.
 * @param targetNode Some tree-node *from the initial tree*.
 * @param newTreeRoot  The root *of the new tree structure*
 * @returns A visible node in the new tree that's the closest to the target-node. Defaults to the tree root.
 */
export function findClosestVisibleInNewTree(
    targetNode: D3TreeNode,
    newTreeRoot: D3TreeNode
): D3TreeNode {
    // Traverse upwards to build the expected path to the original node
    let pathToNode = [targetNode];
    let traversingNode = targetNode;
    while (traversingNode.parent) {
        traversingNode = traversingNode.parent;
        pathToNode = [traversingNode, ...pathToNode];
    }

    // Assume that the tree root will always be an available visible parent
    let visibleParent = newTreeRoot;
    let childrenInTree = visibleParent.children ?? [];

    // Using the computed path, traverse downwards in the new tree structure as far as possible
    for (let i = 1; i < pathToNode.length; i++) {
        const pathNode = pathToNode[i];

        const nodeId = computeNodeId(pathNode);

        const foundChild = childrenInTree.find(
            (node) => computeNodeId(node) === nodeId
        );

        // Previous node was the last visible parent for the node
        if (!foundChild) {
            return visibleParent;
        } else {
            visibleParent = foundChild;
            childrenInTree = foundChild.children ?? [];
        }
    }

    return visibleParent;
}

/**
 * Computes the SVG drawing command for a link in the tree
 * @param link A link in the tree
 * @returns An SVG command string
 */
export function diagonalPath(link: D3TreeEdge): string {
    const { source, target } = link;

    const avgY = (target.y + source.y) / 2;
    // Svg path drawing commands. Note that x and y is swapped to show the tree sideways
    return `
        M ${source.y} ${source.x} \
        C \
            ${avgY} ${source.x}, \
            ${avgY} ${target.x}, \
            ${target.y} ${target.x}
        `;
}
