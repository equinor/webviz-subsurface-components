"use strict";(self.webpackChunk_webviz_subsurface_components=self.webpackChunk_webviz_subsurface_components||[]).push([[7246],{"./node_modules/@deck.gl/core/dist/controllers/controller.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return Controller}});var transition=__webpack_require__("./node_modules/@deck.gl/core/dist/transitions/transition.js");const noop=()=>{},TRANSITION_EVENTS_SNAP_TO_END=2,TRANSITION_EVENTS_IGNORE=3,DEFAULT_EASING=t=>t,DEFAULT_INTERRUPTION=1;class TransitionManager{constructor(opts){this._onTransitionUpdate=transition=>{const{time:time,settings:{interpolator:interpolator,startProps:startProps,endProps:endProps,duration:duration,easing:easing}}=transition,t=easing(time/duration),viewport=interpolator.interpolateProps(startProps,endProps,t);this.propsInTransition=this.getControllerState({...this.props,...viewport}).getViewportProps(),this.onViewStateChange({viewState:this.propsInTransition,oldViewState:this.props})},this.getControllerState=opts.getControllerState,this.propsInTransition=null,this.transition=new transition.A(opts.timeline),this.onViewStateChange=opts.onViewStateChange||noop,this.onStateChange=opts.onStateChange||noop}finalize(){this.transition.cancel()}getViewportInTransition(){return this.propsInTransition}processViewStateChange(nextProps){let transitionTriggered=!1;const currentProps=this.props;if(this.props=nextProps,!currentProps||this._shouldIgnoreViewportChange(currentProps,nextProps))return!1;if(this._isTransitionEnabled(nextProps)){let startProps=currentProps;if(this.transition.inProgress){const{interruption:interruption,endProps:endProps}=this.transition.settings;startProps={...currentProps,...interruption===TRANSITION_EVENTS_SNAP_TO_END?endProps:this.propsInTransition||currentProps}}this._triggerTransition(startProps,nextProps),transitionTriggered=!0}else this.transition.cancel();return transitionTriggered}updateTransition(){this.transition.update()}_isTransitionEnabled(props){const{transitionDuration:transitionDuration,transitionInterpolator:transitionInterpolator}=props;return(transitionDuration>0||"auto"===transitionDuration)&&Boolean(transitionInterpolator)}_isUpdateDueToCurrentTransition(props){return!(!this.transition.inProgress||!this.propsInTransition)&&this.transition.settings.interpolator.arePropsEqual(props,this.propsInTransition)}_shouldIgnoreViewportChange(currentProps,nextProps){if(this.transition.inProgress){return this.transition.settings.interruption===TRANSITION_EVENTS_IGNORE||this._isUpdateDueToCurrentTransition(nextProps)}return!this._isTransitionEnabled(nextProps)||nextProps.transitionInterpolator.arePropsEqual(currentProps,nextProps)}_triggerTransition(startProps,endProps){const startViewstate=this.getControllerState(startProps),endViewStateProps=this.getControllerState(endProps).shortestPathFrom(startViewstate),transitionInterpolator=endProps.transitionInterpolator,duration=transitionInterpolator.getDuration?transitionInterpolator.getDuration(startProps,endProps):endProps.transitionDuration;if(0===duration)return;const initialProps=transitionInterpolator.initializeProps(startProps,endViewStateProps);this.propsInTransition={};const transitionSettings={duration:duration,easing:endProps.transitionEasing||DEFAULT_EASING,interpolator:transitionInterpolator,interruption:endProps.transitionInterruption||DEFAULT_INTERRUPTION,startProps:initialProps.start,endProps:initialProps.end,onStart:endProps.onTransitionStart,onUpdate:this._onTransitionUpdate,onInterrupt:this._onTransitionEnd(endProps.onTransitionInterrupt),onEnd:this._onTransitionEnd(endProps.onTransitionEnd)};this.transition.start(transitionSettings),this.onStateChange({inTransition:!0}),this.updateTransition()}_onTransitionEnd(callback){return transition=>{this.propsInTransition=null,this.onStateChange({inTransition:!1,isZooming:!1,isPanning:!1,isRotating:!1}),callback?.(transition)}}}var linear_interpolator=__webpack_require__("./node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js");const NO_TRANSITION_PROPS={transitionDuration:0},INERTIA_EASING=t=>1-(1-t)*(1-t),EVENT_TYPES_WHEEL=["wheel"],EVENT_TYPES_PAN=["panstart","panmove","panend"],EVENT_TYPES_PINCH=["pinchstart","pinchmove","pinchend"],EVENT_TYPES_MULTI_PAN=["multipanstart","multipanmove","multipanend"],EVENT_TYPES_DOUBLE_CLICK=["dblclick"],EVENT_TYPES_KEYBOARD=["keydown"],pinchEventWorkaround={};class Controller{constructor(opts){this.state={},this._events={},this._interactionState={isDragging:!1},this._customEvents=[],this._eventStartBlocked=null,this._panMove=!1,this.invertPan=!1,this.dragMode="rotate",this.inertia=0,this.scrollZoom=!0,this.dragPan=!0,this.dragRotate=!0,this.doubleClickZoom=!0,this.touchZoom=!0,this.touchRotate=!1,this.keyboard=!0,this.transitionManager=new TransitionManager({...opts,getControllerState:props=>new this.ControllerState(props),onViewStateChange:this._onTransition.bind(this),onStateChange:this._setInteractionState.bind(this)}),this.handleEvent=this.handleEvent.bind(this),this.eventManager=opts.eventManager,this.onViewStateChange=opts.onViewStateChange||(()=>{}),this.onStateChange=opts.onStateChange||(()=>{}),this.makeViewport=opts.makeViewport}set events(customEvents){this.toggleEvents(this._customEvents,!1),this.toggleEvents(customEvents,!0),this._customEvents=customEvents,this.props&&this.setProps(this.props)}finalize(){for(const eventName in this._events)this._events[eventName]&&this.eventManager?.off(eventName,this.handleEvent);this.transitionManager.finalize()}handleEvent(event){this._controllerState=void 0;const eventStartBlocked=this._eventStartBlocked;switch(event.type){case"panstart":return!eventStartBlocked&&this._onPanStart(event);case"panmove":return this._onPan(event);case"panend":return this._onPanEnd(event);case"pinchstart":return!eventStartBlocked&&this._onPinchStart(event);case"pinchmove":return this._onPinch(event);case"pinchend":return this._onPinchEnd(event);case"multipanstart":return!eventStartBlocked&&this._onMultiPanStart(event);case"multipanmove":return this._onMultiPan(event);case"multipanend":return this._onMultiPanEnd(event);case"dblclick":return this._onDoubleClick(event);case"wheel":return this._onWheel(event);case"keydown":return this._onKeyDown(event);default:return!1}}get controllerState(){return this._controllerState=this._controllerState||new this.ControllerState({makeViewport:this.makeViewport,...this.props,...this.state}),this._controllerState}getCenter(event){const{x:x,y:y}=this.props,{offsetCenter:offsetCenter}=event;return[offsetCenter.x-x,offsetCenter.y-y]}isPointInBounds(pos,event){const{width:width,height:height}=this.props;if(event&&event.handled)return!1;const inside=pos[0]>=0&&pos[0]<=width&&pos[1]>=0&&pos[1]<=height;return inside&&event&&event.stopPropagation(),inside}isFunctionKeyPressed(event){const{srcEvent:srcEvent}=event;return Boolean(srcEvent.metaKey||srcEvent.altKey||srcEvent.ctrlKey||srcEvent.shiftKey)}isDragging(){return this._interactionState.isDragging||!1}blockEvents(timeout){const timer=setTimeout((()=>{this._eventStartBlocked===timer&&(this._eventStartBlocked=null)}),timeout);this._eventStartBlocked=timer}setProps(props){props.dragMode&&(this.dragMode=props.dragMode),this.props=props,"transitionInterpolator"in props||(props.transitionInterpolator=this._getTransitionProps().transitionInterpolator),this.transitionManager.processViewStateChange(props);const{inertia:inertia}=props;this.inertia=Number.isFinite(inertia)?inertia:!0===inertia?300:0;const{scrollZoom:scrollZoom=!0,dragPan:dragPan=!0,dragRotate:dragRotate=!0,doubleClickZoom:doubleClickZoom=!0,touchZoom:touchZoom=!0,touchRotate:touchRotate=!1,keyboard:keyboard=!0}=props,isInteractive=Boolean(this.onViewStateChange);this.toggleEvents(EVENT_TYPES_WHEEL,isInteractive&&scrollZoom),this.toggleEvents(EVENT_TYPES_PAN,isInteractive),this.toggleEvents(EVENT_TYPES_PINCH,isInteractive&&(touchZoom||touchRotate)),this.toggleEvents(EVENT_TYPES_MULTI_PAN,isInteractive&&touchRotate),this.toggleEvents(EVENT_TYPES_DOUBLE_CLICK,isInteractive&&doubleClickZoom),this.toggleEvents(EVENT_TYPES_KEYBOARD,isInteractive&&keyboard),this.scrollZoom=scrollZoom,this.dragPan=dragPan,this.dragRotate=dragRotate,this.doubleClickZoom=doubleClickZoom,this.touchZoom=touchZoom,this.touchRotate=touchRotate,this.keyboard=keyboard}updateTransition(){this.transitionManager.updateTransition()}toggleEvents(eventNames,enabled){this.eventManager&&eventNames.forEach((eventName=>{this._events[eventName]!==enabled&&(this._events[eventName]=enabled,enabled?this.eventManager.on(eventName,this.handleEvent):this.eventManager.off(eventName,this.handleEvent))}))}updateViewport(newControllerState,extraProps=null,interactionState={}){const viewState={...newControllerState.getViewportProps(),...extraProps},changed=this.controllerState!==newControllerState;if(this.state=newControllerState.getState(),this._setInteractionState(interactionState),changed){const oldViewState=this.controllerState&&this.controllerState.getViewportProps();this.onViewStateChange&&this.onViewStateChange({viewState:viewState,interactionState:this._interactionState,oldViewState:oldViewState,viewId:this.props.id})}}_onTransition(params){this.onViewStateChange({...params,interactionState:this._interactionState,viewId:this.props.id})}_setInteractionState(newStates){Object.assign(this._interactionState,newStates),this.onStateChange(this._interactionState)}_onPanStart(event){const pos=this.getCenter(event);if(!this.isPointInBounds(pos,event))return!1;let alternateMode=this.isFunctionKeyPressed(event)||event.rightButton||!1;(this.invertPan||"pan"===this.dragMode)&&(alternateMode=!alternateMode);const newControllerState=this.controllerState[alternateMode?"panStart":"rotateStart"]({pos:pos});return this._panMove=alternateMode,this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0}),!0}_onPan(event){return!!this.isDragging()&&(this._panMove?this._onPanMove(event):this._onPanRotate(event))}_onPanEnd(event){return!!this.isDragging()&&(this._panMove?this._onPanMoveEnd(event):this._onPanRotateEnd(event))}_onPanMove(event){if(!this.dragPan)return!1;const pos=this.getCenter(event),newControllerState=this.controllerState.pan({pos:pos});return this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0,isPanning:!0}),!0}_onPanMoveEnd(event){const{inertia:inertia}=this;if(this.dragPan&&inertia&&event.velocity){const pos=this.getCenter(event),endPos=[pos[0]+event.velocityX*inertia/2,pos[1]+event.velocityY*inertia/2],newControllerState=this.controllerState.pan({pos:endPos}).panEnd();this.updateViewport(newControllerState,{...this._getTransitionProps(),transitionDuration:inertia,transitionEasing:INERTIA_EASING},{isDragging:!1,isPanning:!0})}else{const newControllerState=this.controllerState.panEnd();this.updateViewport(newControllerState,null,{isDragging:!1,isPanning:!1})}return!0}_onPanRotate(event){if(!this.dragRotate)return!1;const pos=this.getCenter(event),newControllerState=this.controllerState.rotate({pos:pos});return this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0,isRotating:!0}),!0}_onPanRotateEnd(event){const{inertia:inertia}=this;if(this.dragRotate&&inertia&&event.velocity){const pos=this.getCenter(event),endPos=[pos[0]+event.velocityX*inertia/2,pos[1]+event.velocityY*inertia/2],newControllerState=this.controllerState.rotate({pos:endPos}).rotateEnd();this.updateViewport(newControllerState,{...this._getTransitionProps(),transitionDuration:inertia,transitionEasing:INERTIA_EASING},{isDragging:!1,isRotating:!0})}else{const newControllerState=this.controllerState.rotateEnd();this.updateViewport(newControllerState,null,{isDragging:!1,isRotating:!1})}return!0}_onWheel(event){if(!this.scrollZoom)return!1;const pos=this.getCenter(event);if(!this.isPointInBounds(pos,event))return!1;event.srcEvent.preventDefault();const{speed:speed=.01,smooth:smooth=!1}=!0===this.scrollZoom?{}:this.scrollZoom,{delta:delta}=event;let scale=2/(1+Math.exp(-Math.abs(delta*speed)));delta<0&&0!==scale&&(scale=1/scale);const newControllerState=this.controllerState.zoom({pos:pos,scale:scale});return this.updateViewport(newControllerState,{...this._getTransitionProps({around:pos}),transitionDuration:smooth?250:1},{isZooming:!0,isPanning:!0}),!0}_onMultiPanStart(event){const pos=this.getCenter(event);if(!this.isPointInBounds(pos,event))return!1;const newControllerState=this.controllerState.rotateStart({pos:pos});return this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0}),!0}_onMultiPan(event){if(!this.touchRotate)return!1;if(!this.isDragging())return!1;const pos=this.getCenter(event);pos[0]-=event.deltaX;const newControllerState=this.controllerState.rotate({pos:pos});return this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0,isRotating:!0}),!0}_onMultiPanEnd(event){if(!this.isDragging())return!1;const{inertia:inertia}=this;if(this.touchRotate&&inertia&&event.velocityY){const pos=this.getCenter(event),endPos=[pos[0],pos[1]+=event.velocityY*inertia/2],newControllerState=this.controllerState.rotate({pos:endPos});this.updateViewport(newControllerState,{...this._getTransitionProps(),transitionDuration:inertia,transitionEasing:INERTIA_EASING},{isDragging:!1,isRotating:!0}),this.blockEvents(inertia)}else{const newControllerState=this.controllerState.rotateEnd();this.updateViewport(newControllerState,null,{isDragging:!1,isRotating:!1})}return!0}_onPinchStart(event){const pos=this.getCenter(event);if(!this.isPointInBounds(pos,event))return!1;const newControllerState=this.controllerState.zoomStart({pos:pos}).rotateStart({pos:pos});return pinchEventWorkaround._startPinchRotation=event.rotation,pinchEventWorkaround._lastPinchEvent=event,this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0}),!0}_onPinch(event){if(!this.touchZoom&&!this.touchRotate)return!1;if(!this.isDragging())return!1;let newControllerState=this.controllerState;if(this.touchZoom){const{scale:scale}=event,pos=this.getCenter(event);newControllerState=newControllerState.zoom({pos:pos,scale:scale})}if(this.touchRotate){const{rotation:rotation}=event;newControllerState=newControllerState.rotate({deltaAngleX:pinchEventWorkaround._startPinchRotation-rotation})}return this.updateViewport(newControllerState,NO_TRANSITION_PROPS,{isDragging:!0,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:this.touchRotate}),pinchEventWorkaround._lastPinchEvent=event,!0}_onPinchEnd(event){if(!this.isDragging())return!1;const{inertia:inertia}=this,{_lastPinchEvent:_lastPinchEvent}=pinchEventWorkaround;if(this.touchZoom&&inertia&&_lastPinchEvent&&event.scale!==_lastPinchEvent.scale){const pos=this.getCenter(event);let newControllerState=this.controllerState.rotateEnd();const z=Math.log2(event.scale),velocityZ=(z-Math.log2(_lastPinchEvent.scale))/(event.deltaTime-_lastPinchEvent.deltaTime),endScale=Math.pow(2,z+velocityZ*inertia/2);newControllerState=newControllerState.zoom({pos:pos,scale:endScale}).zoomEnd(),this.updateViewport(newControllerState,{...this._getTransitionProps({around:pos}),transitionDuration:inertia,transitionEasing:INERTIA_EASING},{isDragging:!1,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:!1}),this.blockEvents(inertia)}else{const newControllerState=this.controllerState.zoomEnd().rotateEnd();this.updateViewport(newControllerState,null,{isDragging:!1,isPanning:!1,isZooming:!1,isRotating:!1})}return pinchEventWorkaround._startPinchRotation=null,pinchEventWorkaround._lastPinchEvent=null,!0}_onDoubleClick(event){if(!this.doubleClickZoom)return!1;const pos=this.getCenter(event);if(!this.isPointInBounds(pos,event))return!1;const isZoomOut=this.isFunctionKeyPressed(event),newControllerState=this.controllerState.zoom({pos:pos,scale:isZoomOut?.5:2});return this.updateViewport(newControllerState,this._getTransitionProps({around:pos}),{isZooming:!0,isPanning:!0}),this.blockEvents(100),!0}_onKeyDown(event){if(!this.keyboard)return!1;const funcKey=this.isFunctionKeyPressed(event),{zoomSpeed:zoomSpeed,moveSpeed:moveSpeed,rotateSpeedX:rotateSpeedX,rotateSpeedY:rotateSpeedY}=!0===this.keyboard?{}:this.keyboard,{controllerState:controllerState}=this;let newControllerState;const interactionState={};switch(event.srcEvent.code){case"Minus":newControllerState=funcKey?controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed):controllerState.zoomOut(zoomSpeed),interactionState.isZooming=!0;break;case"Equal":newControllerState=funcKey?controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed):controllerState.zoomIn(zoomSpeed),interactionState.isZooming=!0;break;case"ArrowLeft":funcKey?(newControllerState=controllerState.rotateLeft(rotateSpeedX),interactionState.isRotating=!0):(newControllerState=controllerState.moveLeft(moveSpeed),interactionState.isPanning=!0);break;case"ArrowRight":funcKey?(newControllerState=controllerState.rotateRight(rotateSpeedX),interactionState.isRotating=!0):(newControllerState=controllerState.moveRight(moveSpeed),interactionState.isPanning=!0);break;case"ArrowUp":funcKey?(newControllerState=controllerState.rotateUp(rotateSpeedY),interactionState.isRotating=!0):(newControllerState=controllerState.moveUp(moveSpeed),interactionState.isPanning=!0);break;case"ArrowDown":funcKey?(newControllerState=controllerState.rotateDown(rotateSpeedY),interactionState.isRotating=!0):(newControllerState=controllerState.moveDown(moveSpeed),interactionState.isPanning=!0);break;default:return!1}return this.updateViewport(newControllerState,this._getTransitionProps(),interactionState),!0}_getTransitionProps(opts){const{transition:transition}=this;return transition&&transition.transitionInterpolator?opts?{...transition,transitionInterpolator:new linear_interpolator.A({...opts,...transition.transitionInterpolator.opts,makeViewport:this.controllerState.makeViewport})}:transition:NO_TRANSITION_PROPS}}},"./node_modules/@deck.gl/core/dist/controllers/orbit-controller.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return OrbitController},c:function(){return OrbitState}});var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js"),_controller_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/controller.js"),_view_state_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/view-state.js"),_utils_math_utils_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/math-utils.js"),_transitions_linear_interpolator_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js");class OrbitState extends _view_state_js__WEBPACK_IMPORTED_MODULE_0__.A{constructor(options){const{width:width,height:height,rotationX:rotationX=0,rotationOrbit:rotationOrbit=0,target:target=[0,0,0],zoom:zoom=0,minRotationX:minRotationX=-90,maxRotationX:maxRotationX=90,minZoom:minZoom=-1/0,maxZoom:maxZoom=1/0,startPanPosition:startPanPosition,startRotatePos:startRotatePos,startRotationX:startRotationX,startRotationOrbit:startRotationOrbit,startZoomPosition:startZoomPosition,startZoom:startZoom}=options;super({width:width,height:height,rotationX:rotationX,rotationOrbit:rotationOrbit,target:target,zoom:zoom,minRotationX:minRotationX,maxRotationX:maxRotationX,minZoom:minZoom,maxZoom:maxZoom},{startPanPosition:startPanPosition,startRotatePos:startRotatePos,startRotationX:startRotationX,startRotationOrbit:startRotationOrbit,startZoomPosition:startZoomPosition,startZoom:startZoom}),this.makeViewport=options.makeViewport}panStart({pos:pos}){return this._getUpdatedState({startPanPosition:this._unproject(pos)})}pan({pos:pos,startPosition:startPosition}){const startPanPosition=this.getState().startPanPosition||startPosition;if(!startPanPosition)return this;const newProps=this.makeViewport(this.getViewportProps()).panByPosition(startPanPosition,pos);return this._getUpdatedState(newProps)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:pos}){return this._getUpdatedState({startRotatePos:pos,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:pos,deltaAngleX:deltaAngleX=0,deltaAngleY:deltaAngleY=0}){const{startRotatePos:startRotatePos,startRotationX:startRotationX,startRotationOrbit:startRotationOrbit}=this.getState(),{width:width,height:height}=this.getViewportProps();if(!startRotatePos||void 0===startRotationX||void 0===startRotationOrbit)return this;let newRotation;if(pos){let deltaScaleX=(pos[0]-startRotatePos[0])/width;(startRotationX<-90||startRotationX>90)&&(deltaScaleX*=-1),newRotation={rotationX:startRotationX+180*((pos[1]-startRotatePos[1])/height),rotationOrbit:startRotationOrbit+180*deltaScaleX}}else newRotation={rotationX:startRotationX+deltaAngleY,rotationOrbit:startRotationOrbit+deltaAngleX};return this._getUpdatedState(newRotation)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(viewState){const fromProps=viewState.getViewportProps(),props={...this.getViewportProps()},{rotationOrbit:rotationOrbit}=props;return Math.abs(rotationOrbit-fromProps.rotationOrbit)>180&&(props.rotationOrbit=rotationOrbit<0?rotationOrbit+360:rotationOrbit-360),props}zoomStart({pos:pos}){return this._getUpdatedState({startZoomPosition:this._unproject(pos),startZoom:this.getViewportProps().zoom})}zoom({pos:pos,startPos:startPos,scale:scale}){let{startZoom:startZoom,startZoomPosition:startZoomPosition}=this.getState();if(startZoomPosition||(startZoom=this.getViewportProps().zoom,startZoomPosition=this._unproject(startPos)||this._unproject(pos)),!startZoomPosition)return this;const newZoom=this._calculateNewZoom({scale:scale,startZoom:startZoom}),zoomedViewport=this.makeViewport({...this.getViewportProps(),zoom:newZoom});return this._getUpdatedState({zoom:newZoom,...zoomedViewport.panByPosition(startZoomPosition,pos)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(speed=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:speed})})}zoomOut(speed=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/speed})})}moveLeft(speed=50){return this._panFromCenter([-speed,0])}moveRight(speed=50){return this._panFromCenter([speed,0])}moveUp(speed=50){return this._panFromCenter([0,-speed])}moveDown(speed=50){return this._panFromCenter([0,speed])}rotateLeft(speed=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-speed})}rotateRight(speed=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+speed})}rotateUp(speed=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-speed})}rotateDown(speed=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+speed})}_unproject(pos){const viewport=this.makeViewport(this.getViewportProps());return pos&&viewport.unproject(pos)}_calculateNewZoom({scale:scale,startZoom:startZoom}){const{maxZoom:maxZoom,minZoom:minZoom}=this.getViewportProps();void 0===startZoom&&(startZoom=this.getViewportProps().zoom);const zoom=startZoom+Math.log2(scale);return(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(zoom,minZoom,maxZoom)}_panFromCenter(offset){const{width:width,height:height,target:target}=this.getViewportProps();return this.pan({startPosition:target,pos:[width/2+offset[0],height/2+offset[1]]})}_getUpdatedState(newProps){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...newProps})}applyConstraints(props){const{maxZoom:maxZoom,minZoom:minZoom,zoom:zoom,maxRotationX:maxRotationX,minRotationX:minRotationX,rotationOrbit:rotationOrbit}=props;return props.zoom=Array.isArray(zoom)?[(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(zoom[0],minZoom,maxZoom),(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(zoom[1],minZoom,maxZoom)]:(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(zoom,minZoom,maxZoom),props.rotationX=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(props.rotationX,minRotationX,maxRotationX),(rotationOrbit<-180||rotationOrbit>180)&&(props.rotationOrbit=(0,_utils_math_utils_js__WEBPACK_IMPORTED_MODULE_2__.zi)(rotationOrbit+180,360)-180),props}}class OrbitController extends _controller_js__WEBPACK_IMPORTED_MODULE_3__.A{constructor(){super(...arguments),this.ControllerState=OrbitState,this.transition={transitionDuration:300,transitionInterpolator:new _transitions_linear_interpolator_js__WEBPACK_IMPORTED_MODULE_4__.A({transitionProps:{compare:["target","zoom","rotationX","rotationOrbit"],required:["target","zoom"]}})}}}},"./node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return OrthographicController}});var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js"),_controller_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/controller.js"),_orbit_controller_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/orbit-controller.js"),_transitions_linear_interpolator_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js");class OrthographicState extends _orbit_controller_js__WEBPACK_IMPORTED_MODULE_0__.c{constructor(props){super(props),this.zoomAxis=props.zoomAxis||"all"}_calculateNewZoom({scale:scale,startZoom:startZoom}){const{maxZoom:maxZoom,minZoom:minZoom}=this.getViewportProps();void 0===startZoom&&(startZoom=this.getViewportProps().zoom);let deltaZoom=Math.log2(scale);if(Array.isArray(startZoom)){let[newZoomX,newZoomY]=startZoom;switch(this.zoomAxis){case"X":newZoomX=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(newZoomX+deltaZoom,minZoom,maxZoom);break;case"Y":newZoomY=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(newZoomY+deltaZoom,minZoom,maxZoom);break;default:let z=Math.min(newZoomX+deltaZoom,newZoomY+deltaZoom);z<minZoom&&(deltaZoom+=minZoom-z),z=Math.max(newZoomX+deltaZoom,newZoomY+deltaZoom),z>maxZoom&&(deltaZoom+=maxZoom-z),newZoomX+=deltaZoom,newZoomY+=deltaZoom}return[newZoomX,newZoomY]}return(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)(startZoom+deltaZoom,minZoom,maxZoom)}}class OrthographicController extends _controller_js__WEBPACK_IMPORTED_MODULE_2__.A{constructor(){super(...arguments),this.ControllerState=OrthographicState,this.transition={transitionDuration:300,transitionInterpolator:new _transitions_linear_interpolator_js__WEBPACK_IMPORTED_MODULE_3__.A(["target","zoom"])},this.dragMode="pan"}_onPanRotate(){return!1}}},"./node_modules/@deck.gl/core/dist/controllers/view-state.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return ViewState}});class ViewState{constructor(props,state){this._viewportProps=this.applyConstraints(props),this._state=state}getViewportProps(){return this._viewportProps}getState(){return this._state}}},"./node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{$:function(){return AmbientLight}});const DEFAULT_LIGHT_COLOR=[255,255,255],DEFAULT_LIGHT_INTENSITY=1;let idCount=0;class AmbientLight{constructor(props={}){this.type="ambient";const{color:color=DEFAULT_LIGHT_COLOR}=props,{intensity:intensity=DEFAULT_LIGHT_INTENSITY}=props;this.id=props.id||"ambient-"+idCount++,this.color=color,this.intensity=intensity}}},"./node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Z:function(){return DirectionalLight}});var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@math.gl/core/dist/classes/vector3.js");const DEFAULT_LIGHT_COLOR=[255,255,255],DEFAULT_LIGHT_INTENSITY=1,DEFAULT_LIGHT_DIRECTION=[0,0,-1];let idCount=0;class DirectionalLight{constructor(props={}){this.type="directional";const{color:color=DEFAULT_LIGHT_COLOR}=props,{intensity:intensity=DEFAULT_LIGHT_INTENSITY}=props,{direction:direction=DEFAULT_LIGHT_DIRECTION}=props,{_shadow:_shadow=!1}=props;this.id=props.id||"directional-"+idCount++,this.color=color,this.intensity=intensity,this.type="directional",this.direction=new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__.P(direction).normalize().toArray(),this.shadow=_shadow}getProjectedLight(opts){return this}}},"./node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return LightingEffect}});var ambient_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js"),directional_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js"),matrix4=__webpack_require__("./node_modules/@math.gl/core/dist/classes/matrix4.js"),vector3=__webpack_require__("./node_modules/@math.gl/core/dist/classes/vector3.js"),layers_pass=__webpack_require__("./node_modules/@deck.gl/core/dist/passes/layers-pass.js");class ShadowPass extends layers_pass.A{constructor(device,props){super(device,props);const shadowMap=device.createTexture({format:"rgba8unorm",width:1,height:1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},mipmaps:!0}),depthBuffer=device.createTexture({format:"depth16unorm",width:1,height:1,mipmaps:!1});this.fbo=device.createFramebuffer({id:"shadowmap",width:1,height:1,colorAttachments:[shadowMap],depthStencilAttachment:depthBuffer})}delete(){this.fbo&&(this.fbo.destroy(),this.fbo=null)}getShadowMap(){return this.fbo.colorAttachments[0].texture}render(params){const target=this.fbo,pixelRatio=this.device.canvasContext.cssToDeviceRatio(),viewport=params.viewports[0],width=viewport.width*pixelRatio,height=viewport.height*pixelRatio;width===target.width&&height===target.height||target.resize({width:width,height:height}),super.render({...params,clearColor:[1,1,1,1],target:target,pass:"shadow"})}getLayerParameters(layer,layerIndex,viewport){return{...layer.props.parameters,blend:!1,depthWriteEnabled:!0,depthCompare:"less-equal"}}shouldDrawLayer(layer){return!1!==layer.props.shadowEnabled}getShaderModuleProps(layer,effects,otherShaderModuleProps){return{shadow:{project:otherShaderModuleProps.project,drawToShadowMap:!0}}}}var constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project/project.js"),memoize=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/memoize.js"),dist=__webpack_require__("./node_modules/@math.gl/web-mercator/dist/index.js");const uniformBlock="\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n",vs=`\n${uniformBlock}\n\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n\n`,fs=`\n${uniformBlock}\n\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n\n`,getMemoizedViewportCenterPosition=(0,memoize.A)((function getViewportCenterPosition({viewport:viewport,center:center}){return new matrix4.k(viewport.viewProjectionMatrix).invert().transform(center)})),getMemoizedViewProjectionMatrices=(0,memoize.A)((function getViewProjectionMatrices({viewport:viewport,shadowMatrices:shadowMatrices}){const projectionMatrices=[],pixelUnprojectionMatrix=viewport.pixelUnprojectionMatrix,farZ=viewport.isGeospatial?void 0:1,corners=[[0,0,farZ],[viewport.width,0,farZ],[0,viewport.height,farZ],[viewport.width,viewport.height,farZ],[0,0,-1],[viewport.width,0,-1],[0,viewport.height,-1],[viewport.width,viewport.height,-1]].map((pixel=>function screenToCommonSpace(xyz,pixelUnprojectionMatrix){const[x,y,z]=xyz,coord=(0,dist.xJ)([x,y,z],pixelUnprojectionMatrix);if(Number.isFinite(z))return coord;return[coord[0],coord[1],0]}(pixel,pixelUnprojectionMatrix)));for(const shadowMatrix of shadowMatrices){const viewMatrix=shadowMatrix.clone().translate(new vector3.P(viewport.center).negate()),positions=corners.map((corner=>viewMatrix.transform(corner))),projectionMatrix=(new matrix4.k).ortho({left:Math.min(...positions.map((position=>position[0]))),right:Math.max(...positions.map((position=>position[0]))),bottom:Math.min(...positions.map((position=>position[1]))),top:Math.max(...positions.map((position=>position[1]))),near:Math.min(...positions.map((position=>-position[2]))),far:Math.max(...positions.map((position=>-position[2])))});projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix))}return projectionMatrices})),DEFAULT_SHADOW_COLOR=[0,0,0,1],VECTOR_TO_POINT_MATRIX=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0];var shadow={name:"shadow",dependencies:[project.A],vs:vs,fs:fs,inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    position = shadow_setVertexPosition(geometry.position);\n    ","fs:DECKGL_FILTER_COLOR":"\n    color = shadow_filterShadowColor(color);\n    "},getUniforms:function createShadowUniforms(opts){const{shadowEnabled:shadowEnabled=!0,project:projectProps}=opts;if(!(shadowEnabled&&projectProps&&opts.shadowMatrices&&opts.shadowMatrices.length))return{drawShadowMap:!1,useShadowMap:!1,shadow_uShadowMap0:opts.dummyShadowMap,shadow_uShadowMap1:opts.dummyShadowMap};const projectUniforms=project.A.getUniforms(projectProps),center=getMemoizedViewportCenterPosition({viewport:projectProps.viewport,center:projectUniforms.center}),projectCenters=[],viewProjectionMatrices=getMemoizedViewProjectionMatrices({shadowMatrices:opts.shadowMatrices,viewport:projectProps.viewport}).slice();for(let i=0;i<opts.shadowMatrices.length;i++){const viewProjectionMatrix=viewProjectionMatrices[i],viewProjectionMatrixCentered=viewProjectionMatrix.clone().translate(new vector3.P(projectProps.viewport.center).negate());projectUniforms.coordinateSystem===constants.rf.LNGLAT&&projectUniforms.projectionMode===constants.Kx.WEB_MERCATOR?(viewProjectionMatrices[i]=viewProjectionMatrixCentered,projectCenters[i]=center):(viewProjectionMatrices[i]=viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX),projectCenters[i]=viewProjectionMatrixCentered.transform(center))}const uniforms={drawShadowMap:Boolean(opts.drawToShadowMap),useShadowMap:!!opts.shadowMaps&&opts.shadowMaps.length>0,color:opts.shadowColor||DEFAULT_SHADOW_COLOR,lightId:opts.shadowLightId||0,lightCount:opts.shadowMatrices.length,shadow_uShadowMap0:opts.dummyShadowMap,shadow_uShadowMap1:opts.dummyShadowMap};for(let i=0;i<viewProjectionMatrices.length;i++)uniforms[`viewProjectionMatrix${i}`]=viewProjectionMatrices[i],uniforms[`projectCenter${i}`]=projectCenters[i];for(let i=0;i<2;i++)uniforms[`shadow_uShadowMap${i}`]=opts.shadowMaps&&opts.shadowMaps[i]||opts.dummyShadowMap;return uniforms},uniformTypes:{drawShadowMap:"f32",useShadowMap:"f32",color:"vec4<f32>",lightId:"i32",lightCount:"f32",viewProjectionMatrix0:"mat4x4<f32>",viewProjectionMatrix1:"mat4x4<f32>",projectCenter0:"vec4<f32>",projectCenter1:"vec4<f32>"}};const DEFAULT_AMBIENT_LIGHT_PROPS={color:[255,255,255],intensity:1},DEFAULT_DIRECTIONAL_LIGHT_PROPS=[{color:[255,255,255],intensity:1,direction:[-1,3,-1]},{color:[255,255,255],intensity:.9,direction:[1,-8,-2.5]}],lighting_effect_DEFAULT_SHADOW_COLOR=[0,0,0,200/255];class LightingEffect{constructor(props={}){this.id="lighting-effect",this.shadowColor=lighting_effect_DEFAULT_SHADOW_COLOR,this.shadow=!1,this.directionalLights=[],this.pointLights=[],this.shadowPasses=[],this.dummyShadowMap=null,this.setProps(props)}setup(context){this.context=context;const{device:device,deck:deck}=context;this.shadow&&!this.dummyShadowMap&&(this._createShadowPasses(device),deck._addDefaultShaderModule(shadow),this.dummyShadowMap=device.createTexture({width:1,height:1}))}setProps(props){this.ambientLight=void 0,this.directionalLights=[],this.pointLights=[];for(const key in props){const lightSource=props[key];switch(lightSource.type){case"ambient":this.ambientLight=lightSource;break;case"directional":this.directionalLights.push(lightSource);break;case"point":this.pointLights.push(lightSource)}}this._applyDefaultLights(),this.shadow=this.directionalLights.some((light=>light.shadow)),this.context&&this.setup(this.context),this.props=props}preRender({layers:layers,layerFilter:layerFilter,viewports:viewports,onViewportActive:onViewportActive,views:views}){if(this.shadow){this.shadowMatrices=this._calculateMatrices();for(let i=0;i<this.shadowPasses.length;i++){this.shadowPasses[i].render({layers:layers,layerFilter:layerFilter,viewports:viewports,onViewportActive:onViewportActive,views:views,shaderModuleProps:{shadow:{shadowLightId:i,dummyShadowMap:this.dummyShadowMap,shadowMatrices:this.shadowMatrices}}})}}}getShaderModuleProps(layer,otherShaderModuleProps){const shadowProps=this.shadow?{project:otherShaderModuleProps.project,shadowMaps:this.shadowPasses.map((shadowPass=>shadowPass.getShadowMap())),dummyShadowMap:this.dummyShadowMap,shadowColor:this.shadowColor,shadowMatrices:this.shadowMatrices}:{},lightingProps={enabled:!0,ambientLight:this.ambientLight,directionalLights:this.directionalLights.map((directionalLight=>directionalLight.getProjectedLight({layer:layer}))),pointLights:this.pointLights.map((pointLight=>pointLight.getProjectedLight({layer:layer})))},materialProps=layer.props.material;return{shadow:shadowProps,lighting:lightingProps,phongMaterial:materialProps,gouraudMaterial:materialProps}}cleanup(context){for(const shadowPass of this.shadowPasses)shadowPass.delete();this.shadowPasses.length=0,this.dummyShadowMap&&(this.dummyShadowMap.destroy(),this.dummyShadowMap=null,context.deck._removeDefaultShaderModule(shadow))}_calculateMatrices(){const lightMatrices=[];for(const light of this.directionalLights){const viewMatrix=(new matrix4.k).lookAt({eye:new vector3.P(light.direction).negate()});lightMatrices.push(viewMatrix)}return lightMatrices}_createShadowPasses(device){for(let i=0;i<this.directionalLights.length;i++){const shadowPass=new ShadowPass(device);this.shadowPasses[i]=shadowPass}}_applyDefaultLights(){const{ambientLight:ambientLight,pointLights:pointLights,directionalLights:directionalLights}=this;ambientLight||0!==pointLights.length||0!==directionalLights.length||(this.ambientLight=new ambient_light.$(DEFAULT_AMBIENT_LIGHT_PROPS),this.directionalLights.push(new directional_light.Z(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),new directional_light.Z(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])))}}},"./node_modules/@deck.gl/core/dist/passes/layers-pass.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return LayersPass}});class Pass{constructor(device,props={id:"pass"}){const{id:id}=props;this.id=id,this.device=device,this.props={...props}}setProps(props){Object.assign(this.props,props)}render(params){}cleanup(){}}class LayersPass extends Pass{constructor(){super(...arguments),this._lastRenderIndex=-1}render(options){const[width,height]=this.device.canvasContext.getDrawingBufferSize(),clearCanvas=options.clearCanvas??!0,clearColor=options.clearColor??(!!clearCanvas&&[0,0,0,0]),clearDepth=!!clearCanvas&&1,clearStencil=!!clearCanvas&&0,colorMask=options.colorMask??15,parameters={viewport:[0,0,width,height]};options.colorMask&&(parameters.colorMask=colorMask),options.scissorRect&&(parameters.scissorRect=options.scissorRect);const renderPass=this.device.beginRenderPass({framebuffer:options.target,parameters:parameters,clearColor:clearColor,clearDepth:clearDepth,clearStencil:clearStencil});try{return this._drawLayers(renderPass,options)}finally{renderPass.end(),this.device.submit()}}_drawLayers(renderPass,options){const{target:target,shaderModuleProps:shaderModuleProps,viewports:viewports,views:views,onViewportActive:onViewportActive,clearStack:clearStack=!0}=options;options.pass=options.pass||"unknown",clearStack&&(this._lastRenderIndex=-1);const renderStats=[];for(const viewport of viewports){const view=views&&views[viewport.id];onViewportActive?.(viewport);const drawLayerParams=this._getDrawLayerParams(viewport,options),subViewports=viewport.subViewports||[viewport];for(const subViewport of subViewports){const stats=this._drawLayersInViewport(renderPass,{target:target,shaderModuleProps:shaderModuleProps,viewport:subViewport,view:view,pass:options.pass,layers:options.layers},drawLayerParams);renderStats.push(stats)}}return renderStats}_getDrawLayerParams(viewport,{layers:layers,pass:pass,isPicking:isPicking=!1,layerFilter:layerFilter,cullRect:cullRect,effects:effects,shaderModuleProps:shaderModuleProps},evaluateShouldDrawOnly=!1){const drawLayerParams=[],indexResolver=layerIndexResolver(this._lastRenderIndex+1),drawContext={layer:layers[0],viewport:viewport,isPicking:isPicking,renderPass:pass,cullRect:cullRect},layerFilterCache={};for(let layerIndex=0;layerIndex<layers.length;layerIndex++){const layer=layers[layerIndex],shouldDrawLayer=this._shouldDrawLayer(layer,drawContext,layerFilter,layerFilterCache),layerParam={shouldDrawLayer:shouldDrawLayer};shouldDrawLayer&&!evaluateShouldDrawOnly&&(layerParam.shouldDrawLayer=!0,layerParam.layerRenderIndex=indexResolver(layer,shouldDrawLayer),layerParam.shaderModuleProps=this._getShaderModuleProps(layer,effects,pass,shaderModuleProps),layerParam.layerParameters={...layer.context.deck?.props.parameters,...this.getLayerParameters(layer,layerIndex,viewport)}),drawLayerParams[layerIndex]=layerParam}return drawLayerParams}_drawLayersInViewport(renderPass,{layers:layers,shaderModuleProps:globalModuleParameters,pass:pass,target:target,viewport:viewport,view:view},drawLayerParams){const glViewport=function getGLViewport(device,{shaderModuleProps:shaderModuleProps,target:target,viewport:viewport}){const pixelRatio=shaderModuleProps?.project?.devicePixelRatio??device.canvasContext.cssToDeviceRatio(),[,drawingBufferHeight]=device.canvasContext.getDrawingBufferSize(),height=target?target.height:drawingBufferHeight,dimensions=viewport;return[dimensions.x*pixelRatio,height-(dimensions.y+dimensions.height)*pixelRatio,dimensions.width*pixelRatio,dimensions.height*pixelRatio]}(this.device,{shaderModuleProps:globalModuleParameters,target:target,viewport:viewport});if(view&&view.props.clear){const clearOpts=!0===view.props.clear?{color:!0,depth:!0}:view.props.clear;this.device.beginRenderPass({framebuffer:target,parameters:{viewport:glViewport,scissorRect:glViewport},clearColor:!!clearOpts.color&&[0,0,0,0],clearDepth:!!clearOpts.depth&&1}).end()}const renderStatus={totalCount:layers.length,visibleCount:0,compositeCount:0,pickableCount:0};renderPass.setParameters({viewport:glViewport});for(let layerIndex=0;layerIndex<layers.length;layerIndex++){const layer=layers[layerIndex],drawLayerParameters=drawLayerParams[layerIndex],{shouldDrawLayer:shouldDrawLayer}=drawLayerParameters;if(shouldDrawLayer&&layer.props.pickable&&renderStatus.pickableCount++,layer.isComposite&&renderStatus.compositeCount++,layer.isDrawable&&drawLayerParameters.shouldDrawLayer){const{layerRenderIndex:layerRenderIndex,shaderModuleProps:shaderModuleProps,layerParameters:layerParameters}=drawLayerParameters;renderStatus.visibleCount++,this._lastRenderIndex=Math.max(this._lastRenderIndex,layerRenderIndex),shaderModuleProps.project&&(shaderModuleProps.project.viewport=viewport),layer.context.renderPass=renderPass;try{layer._drawLayer({renderPass:renderPass,shaderModuleProps:shaderModuleProps,uniforms:{layerIndex:layerRenderIndex},parameters:layerParameters})}catch(err){layer.raiseError(err,`drawing ${layer} to ${pass}`)}}}return renderStatus}shouldDrawLayer(layer){return!0}getShaderModuleProps(layer,effects,otherShaderModuleProps){return null}getLayerParameters(layer,layerIndex,viewport){return layer.props.parameters}_shouldDrawLayer(layer,drawContext,layerFilter,layerFilterCache){if(!(layer.props.visible&&this.shouldDrawLayer(layer)))return!1;drawContext.layer=layer;let parent=layer.parent;for(;parent;){if(!parent.props.visible||!parent.filterSubLayer(drawContext))return!1;drawContext.layer=parent,parent=parent.parent}if(layerFilter){const rootLayerId=drawContext.layer.id;if(rootLayerId in layerFilterCache||(layerFilterCache[rootLayerId]=layerFilter(drawContext)),!layerFilterCache[rootLayerId])return!1}return layer.activateViewport(drawContext.viewport),!0}_getShaderModuleProps(layer,effects,pass,overrides){const devicePixelRatio=this.device.canvasContext.cssToDeviceRatio(),layerProps=layer.internalState?.propsInTransition||layer.props,shaderModuleProps={layer:layerProps,picking:{isActive:!1},project:{viewport:layer.context.viewport,devicePixelRatio:devicePixelRatio,modelMatrix:layerProps.modelMatrix,coordinateSystem:layerProps.coordinateSystem,coordinateOrigin:layerProps.coordinateOrigin,autoWrapLongitude:layer.wrapLongitude}};if(effects)for(const effect of effects)mergeModuleParameters(shaderModuleProps,effect.getShaderModuleProps?.(layer,shaderModuleProps));return mergeModuleParameters(shaderModuleProps,this.getShaderModuleProps(layer,effects,shaderModuleProps),overrides)}}function layerIndexResolver(startIndex=0,layerIndices={}){const resolvers={},resolveLayerIndex=(layer,isDrawn)=>{const indexOverride=layer.props._offset,layerId=layer.id,parentId=layer.parent&&layer.parent.id;let index;if(parentId&&!(parentId in layerIndices)&&resolveLayerIndex(layer.parent,!1),parentId in resolvers){const resolver=resolvers[parentId]=resolvers[parentId]||layerIndexResolver(layerIndices[parentId],layerIndices);index=resolver(layer,isDrawn),resolvers[layerId]=resolver}else Number.isFinite(indexOverride)?(index=indexOverride+(layerIndices[parentId]||0),resolvers[layerId]=null):index=startIndex;return isDrawn&&index>=startIndex&&(startIndex=index+1),layerIndices[layerId]=index,index};return resolveLayerIndex}function mergeModuleParameters(target,...sources){for(const source of sources)if(source)for(const key in source)target[key]?Object.assign(target[key],source[key]):target[key]=source[key];return target}},"./node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return LinearInterpolator}});var common=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js"),assert=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/assert.js");class TransitionInterpolator{constructor(opts){const{compare:compare,extract:extract,required:required}=opts;this._propsToCompare=compare,this._propsToExtract=extract||compare,this._requiredProps=required}arePropsEqual(currentProps,nextProps){for(const key of this._propsToCompare)if(!(key in currentProps)||!(key in nextProps)||!(0,common.aI)(currentProps[key],nextProps[key]))return!1;return!0}initializeProps(startProps,endProps){const startViewStateProps={},endViewStateProps={};for(const key of this._propsToExtract)(key in startProps||key in endProps)&&(startViewStateProps[key]=startProps[key],endViewStateProps[key]=endProps[key]);return this._checkRequiredProps(startViewStateProps),this._checkRequiredProps(endViewStateProps),{start:startViewStateProps,end:endViewStateProps}}getDuration(startProps,endProps){return endProps.transitionDuration}_checkRequiredProps(props){this._requiredProps&&this._requiredProps.forEach((propName=>{const value=props[propName];(0,assert.A)(Number.isFinite(value)||Array.isArray(value),`${propName} is required for transition`)}))}}const DEFAULT_PROPS=["longitude","latitude","zoom","bearing","pitch"],DEFAULT_REQUIRED_PROPS=["longitude","latitude","zoom"];class LinearInterpolator extends TransitionInterpolator{constructor(opts={}){const transitionProps=Array.isArray(opts)?opts:opts.transitionProps,normalizedOpts=Array.isArray(opts)?{}:opts;normalizedOpts.transitionProps=Array.isArray(transitionProps)?{compare:transitionProps,required:transitionProps}:transitionProps||{compare:DEFAULT_PROPS,required:DEFAULT_REQUIRED_PROPS},super(normalizedOpts.transitionProps),this.opts=normalizedOpts}initializeProps(startProps,endProps){const result=super.initializeProps(startProps,endProps),{makeViewport:makeViewport,around:around}=this.opts;if(makeViewport&&around){const startViewport=makeViewport(startProps),endViewport=makeViewport(endProps),aroundPosition=startViewport.unproject(around);result.start.around=around,Object.assign(result.end,{around:endViewport.project(aroundPosition),aroundPosition:aroundPosition,width:endProps.width,height:endProps.height})}return result}interpolateProps(startProps,endProps,t){const propsInTransition={};for(const key of this._propsToExtract)propsInTransition[key]=(0,common.Cc)(startProps[key]||0,endProps[key]||0,t);if(endProps.aroundPosition&&this.opts.makeViewport){const viewport=this.opts.makeViewport({...endProps,...propsInTransition});Object.assign(propsInTransition,viewport.panByPosition(endProps.aroundPosition,(0,common.Cc)(startProps.around,endProps.around,t)))}return propsInTransition}}},"./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return OrthographicViewport}});var _viewports_viewport_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/viewport.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@math.gl/core/dist/classes/matrix4.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@math.gl/core/dist/gl-matrix/vec2.js"),_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@math.gl/web-mercator/dist/index.js");const viewMatrix=(new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__.k).lookAt({eye:[0,0,1]});function getProjectionMatrix({width:width,height:height,near:near,far:far,padding:padding}){let left=-width/2,right=width/2,bottom=-height/2,top=height/2;if(padding){const{left:l=0,right:r=0,top:t=0,bottom:b=0}=padding,offsetX=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.qE)((l+width-r)/2,0,width)-width/2,offsetY=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.qE)((t+height-b)/2,0,height)-height/2;left-=offsetX,right-=offsetX,bottom+=offsetY,top+=offsetY}return(new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__.k).ortho({left:left,right:right,bottom:bottom,top:top,near:near,far:far})}class OrthographicViewport extends _viewports_viewport_js__WEBPACK_IMPORTED_MODULE_3__.A{constructor(props){const{width:width,height:height,near:near=.1,far:far=1e3,zoom:zoom=0,target:target=[0,0,0],padding:padding=null,flipY:flipY=!0}=props,zoomX=Array.isArray(zoom)?zoom[0]:zoom,zoomY=Array.isArray(zoom)?zoom[1]:zoom,zoom_=Math.min(zoomX,zoomY),scale=Math.pow(2,zoom_);let distanceScales;if(zoomX!==zoomY){const scaleX=Math.pow(2,zoomX),scaleY=Math.pow(2,zoomY);distanceScales={unitsPerMeter:[scaleX/scale,scaleY/scale,1],metersPerUnit:[scale/scaleX,scale/scaleY,1]}}super({...props,longitude:void 0,position:target,viewMatrix:viewMatrix.clone().scale([scale,scale*(flipY?-1:1),scale]),projectionMatrix:getProjectionMatrix({width:width||1,height:height||1,padding:padding,near:near,far:far}),zoom:zoom_,distanceScales:distanceScales})}projectFlat([X,Y]){const{unitsPerMeter:unitsPerMeter}=this.distanceScales;return[X*unitsPerMeter[0],Y*unitsPerMeter[1]]}unprojectFlat([x,y]){const{metersPerUnit:metersPerUnit}=this.distanceScales;return[x*metersPerUnit[0],y*metersPerUnit[1]]}panByPosition(coords,pixel){const fromLocation=(0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__.xJ)(pixel,this.pixelUnprojectionMatrix),toLocation=this.projectFlat(coords),translate=_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.WQ([],toLocation,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.ze([],fromLocation)),newCenter=_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.WQ([],this.center,translate);return{target:this.unprojectFlat(newCenter)}}}},"./node_modules/@deck.gl/core/dist/views/map-view.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return map_view}});var view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/view.js"),web_mercator_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/web-mercator-viewport.js"),common=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js"),controller=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/controller.js"),view_state=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/view-state.js"),dist=__webpack_require__("./node_modules/@math.gl/web-mercator/dist/index.js"),assert=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/assert.js"),linear_interpolator=__webpack_require__("./node_modules/@deck.gl/core/dist/transitions/linear-interpolator.js");class MapState extends view_state.A{constructor(options){const{width:width,height:height,latitude:latitude,longitude:longitude,zoom:zoom,bearing:bearing=0,pitch:pitch=0,altitude:altitude=1.5,position:position=[0,0,0],maxZoom:maxZoom=20,minZoom:minZoom=0,maxPitch:maxPitch=60,minPitch:minPitch=0,startPanLngLat:startPanLngLat,startZoomLngLat:startZoomLngLat,startRotatePos:startRotatePos,startBearing:startBearing,startPitch:startPitch,startZoom:startZoom,normalize:normalize=!0}=options;(0,assert.A)(Number.isFinite(longitude)),(0,assert.A)(Number.isFinite(latitude)),(0,assert.A)(Number.isFinite(zoom)),super({width:width,height:height,latitude:latitude,longitude:longitude,zoom:zoom,bearing:bearing,pitch:pitch,altitude:altitude,maxZoom:maxZoom,minZoom:minZoom,maxPitch:maxPitch,minPitch:minPitch,normalize:normalize,position:position},{startPanLngLat:startPanLngLat,startZoomLngLat:startZoomLngLat,startRotatePos:startRotatePos,startBearing:startBearing,startPitch:startPitch,startZoom:startZoom}),this.makeViewport=options.makeViewport}panStart({pos:pos}){return this._getUpdatedState({startPanLngLat:this._unproject(pos)})}pan({pos:pos,startPos:startPos}){const startPanLngLat=this.getState().startPanLngLat||this._unproject(startPos);if(!startPanLngLat)return this;const newProps=this.makeViewport(this.getViewportProps()).panByPosition(startPanLngLat,pos);return this._getUpdatedState(newProps)}panEnd(){return this._getUpdatedState({startPanLngLat:null})}rotateStart({pos:pos}){return this._getUpdatedState({startRotatePos:pos,startBearing:this.getViewportProps().bearing,startPitch:this.getViewportProps().pitch})}rotate({pos:pos,deltaAngleX:deltaAngleX=0,deltaAngleY:deltaAngleY=0}){const{startRotatePos:startRotatePos,startBearing:startBearing,startPitch:startPitch}=this.getState();if(!startRotatePos||void 0===startBearing||void 0===startPitch)return this;let newRotation;return newRotation=pos?this._getNewRotation(pos,startRotatePos,startPitch,startBearing):{bearing:startBearing+deltaAngleX,pitch:startPitch+deltaAngleY},this._getUpdatedState(newRotation)}rotateEnd(){return this._getUpdatedState({startBearing:null,startPitch:null})}zoomStart({pos:pos}){return this._getUpdatedState({startZoomLngLat:this._unproject(pos),startZoom:this.getViewportProps().zoom})}zoom({pos:pos,startPos:startPos,scale:scale}){let{startZoom:startZoom,startZoomLngLat:startZoomLngLat}=this.getState();if(startZoomLngLat||(startZoom=this.getViewportProps().zoom,startZoomLngLat=this._unproject(startPos)||this._unproject(pos)),!startZoomLngLat)return this;const{maxZoom:maxZoom,minZoom:minZoom}=this.getViewportProps();let zoom=startZoom+Math.log2(scale);zoom=(0,common.qE)(zoom,minZoom,maxZoom);const zoomedViewport=this.makeViewport({...this.getViewportProps(),zoom:zoom});return this._getUpdatedState({zoom:zoom,...zoomedViewport.panByPosition(startZoomLngLat,pos)})}zoomEnd(){return this._getUpdatedState({startZoomLngLat:null,startZoom:null})}zoomIn(speed=2){return this._zoomFromCenter(speed)}zoomOut(speed=2){return this._zoomFromCenter(1/speed)}moveLeft(speed=100){return this._panFromCenter([speed,0])}moveRight(speed=100){return this._panFromCenter([-speed,0])}moveUp(speed=100){return this._panFromCenter([0,speed])}moveDown(speed=100){return this._panFromCenter([0,-speed])}rotateLeft(speed=15){return this._getUpdatedState({bearing:this.getViewportProps().bearing-speed})}rotateRight(speed=15){return this._getUpdatedState({bearing:this.getViewportProps().bearing+speed})}rotateUp(speed=10){return this._getUpdatedState({pitch:this.getViewportProps().pitch+speed})}rotateDown(speed=10){return this._getUpdatedState({pitch:this.getViewportProps().pitch-speed})}shortestPathFrom(viewState){const fromProps=viewState.getViewportProps(),props={...this.getViewportProps()},{bearing:bearing,longitude:longitude}=props;return Math.abs(bearing-fromProps.bearing)>180&&(props.bearing=bearing<0?bearing+360:bearing-360),Math.abs(longitude-fromProps.longitude)>180&&(props.longitude=longitude<0?longitude+360:longitude-360),props}applyConstraints(props){const{maxZoom:maxZoom,minZoom:minZoom,zoom:zoom}=props;props.zoom=(0,common.qE)(zoom,minZoom,maxZoom);const{maxPitch:maxPitch,minPitch:minPitch,pitch:pitch}=props;props.pitch=(0,common.qE)(pitch,minPitch,maxPitch);const{normalize:normalize=!0}=props;return normalize&&Object.assign(props,(0,dist.CK)(props)),props}_zoomFromCenter(scale){const{width:width,height:height}=this.getViewportProps();return this.zoom({pos:[width/2,height/2],scale:scale})}_panFromCenter(offset){const{width:width,height:height}=this.getViewportProps();return this.pan({startPos:[width/2,height/2],pos:[width/2+offset[0],height/2+offset[1]]})}_getUpdatedState(newProps){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...newProps})}_unproject(pos){const viewport=this.makeViewport(this.getViewportProps());return pos&&viewport.unproject(pos)}_getNewRotation(pos,startPos,startPitch,startBearing){const deltaX=pos[0]-startPos[0],deltaY=pos[1]-startPos[1],centerY=pos[1],startY=startPos[1],{width:width,height:height}=this.getViewportProps(),deltaScaleX=deltaX/width;let deltaScaleY=0;deltaY>0?Math.abs(height-startY)>5&&(deltaScaleY=deltaY/(startY-height)*1.2):deltaY<0&&startY>5&&(deltaScaleY=1-centerY/startY),deltaScaleY=(0,common.qE)(deltaScaleY,-1,1);const{minPitch:minPitch,maxPitch:maxPitch}=this.getViewportProps();let pitch=startPitch;return deltaScaleY>0?pitch=startPitch+deltaScaleY*(maxPitch-startPitch):deltaScaleY<0&&(pitch=startPitch-deltaScaleY*(minPitch-startPitch)),{pitch:pitch,bearing:startBearing+180*deltaScaleX}}}class MapController extends controller.A{constructor(){super(...arguments),this.ControllerState=MapState,this.transition={transitionDuration:300,transitionInterpolator:new linear_interpolator.A({transitionProps:{compare:["longitude","latitude","zoom","bearing","pitch","position"],required:["longitude","latitude","zoom"]}})},this.dragMode="pan"}setProps(props){props.position=props.position||[0,0,0];const oldProps=this.props;super.setProps(props);(!oldProps||oldProps.height!==props.height)&&this.updateViewport(new this.ControllerState({makeViewport:this.makeViewport,...props,...this.state}))}}class MapView extends view.A{constructor(props={}){super(props)}getViewportType(){return web_mercator_viewport.A}get ControllerType(){return MapController}}MapView.displayName="MapView";var map_view=MapView},"./node_modules/@deck.gl/core/dist/views/orthographic-view.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){var _view_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@deck.gl/core/dist/views/view.js"),_viewports_orthographic_viewport_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js"),_controllers_orthographic_controller_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js");class OrthographicView extends _view_js__WEBPACK_IMPORTED_MODULE_0__.A{constructor(props={}){super(props)}getViewportType(){return _viewports_orthographic_viewport_js__WEBPACK_IMPORTED_MODULE_1__.A}get ControllerType(){return _controllers_orthographic_controller_js__WEBPACK_IMPORTED_MODULE_2__.A}}OrthographicView.displayName="OrthographicView",__webpack_exports__.A=OrthographicView},"./node_modules/@deck.gl/core/dist/views/view.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return View}});const PERCENT_OR_PIXELS_REGEX=/([0-9]+\.?[0-9]*)(%|px)/;function parsePosition(value){switch(typeof value){case"number":return{position:value,relative:!1};case"string":const match=PERCENT_OR_PIXELS_REGEX.exec(value);if(match&&match.length>=3){const relative="%"===match[2],position=parseFloat(match[1]);return{position:relative?position/100:position,relative:relative}}default:throw new Error(`Could not parse position string ${value}`)}}function getPosition(position,extent){return position.relative?Math.round(position.position*extent):position.position}var deep_equal=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/deep-equal.js");class View{constructor(props){const{id:id,x:x=0,y:y=0,width:width="100%",height:height="100%",padding:padding=null}=props;this.id=id||this.constructor.displayName||"view",this.props={...props,id:this.id},this._x=parsePosition(x),this._y=parsePosition(y),this._width=parsePosition(width),this._height=parsePosition(height),this._padding=padding&&{left:parsePosition(padding.left||0),right:parsePosition(padding.right||0),top:parsePosition(padding.top||0),bottom:parsePosition(padding.bottom||0)},this.equals=this.equals.bind(this),Object.seal(this)}equals(view){return this===view||this.constructor===view.constructor&&(0,deep_equal.b)(this.props,view.props,2)}makeViewport({width:width,height:height,viewState:viewState}){viewState=this.filterViewState(viewState);const viewportDimensions=this.getDimensions({width:width,height:height});if(!viewportDimensions.height||!viewportDimensions.width)return null;return new(this.getViewportType(viewState))({...viewState,...this.props,...viewportDimensions})}getViewStateId(){const{viewState:viewState}=this.props;return"string"==typeof viewState?viewState:viewState?.id||this.id}filterViewState(viewState){if(this.props.viewState&&"object"==typeof this.props.viewState){if(!this.props.viewState.id)return this.props.viewState;const newViewState={...viewState};for(const key in this.props.viewState)"id"!==key&&(newViewState[key]=this.props.viewState[key]);return newViewState}return viewState}getDimensions({width:width,height:height}){const dimensions={x:getPosition(this._x,width),y:getPosition(this._y,height),width:getPosition(this._width,width),height:getPosition(this._height,height)};return this._padding&&(dimensions.padding={left:getPosition(this._padding.left,width),top:getPosition(this._padding.top,height),right:getPosition(this._padding.right,width),bottom:getPosition(this._padding.bottom,height)}),dimensions}get controller(){const opts=this.props.controller;return opts?!0===opts?{type:this.ControllerType}:"function"==typeof opts?{type:opts}:{type:this.ControllerType,...opts}:null}}},"./node_modules/@deck.gl/react/dist/deckgl.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return deckgl}});var react=__webpack_require__("./node_modules/react/index.js");let channelHandles=1,animationHandles=1;class Timeline{time=0;channels=new Map;animations=new Map;playing=!1;lastEngineTime=-1;constructor(){}addChannel(props){const{delay:delay=0,duration:duration=Number.POSITIVE_INFINITY,rate:rate=1,repeat:repeat=1}=props,channelId=channelHandles++,channel={time:0,delay:delay,duration:duration,rate:rate,repeat:repeat};return this._setChannelTime(channel,this.time),this.channels.set(channelId,channel),channelId}removeChannel(channelId){this.channels.delete(channelId);for(const[animationHandle,animation]of this.animations)animation.channel===channelId&&this.detachAnimation(animationHandle)}isFinished(channelId){const channel=this.channels.get(channelId);return void 0!==channel&&this.time>=channel.delay+channel.duration*channel.repeat}getTime(channelId){if(void 0===channelId)return this.time;const channel=this.channels.get(channelId);return void 0===channel?-1:channel.time}setTime(time){this.time=Math.max(0,time);const channels=this.channels.values();for(const channel of channels)this._setChannelTime(channel,this.time);const animations=this.animations.values();for(const animationData of animations){const{animation:animation,channel:channel}=animationData;animation.setTime(this.getTime(channel))}}play(){this.playing=!0}pause(){this.playing=!1,this.lastEngineTime=-1}reset(){this.setTime(0)}attachAnimation(animation,channelHandle){const animationHandle=animationHandles++;return this.animations.set(animationHandle,{animation:animation,channel:channelHandle}),animation.setTime(this.getTime(channelHandle)),animationHandle}detachAnimation(channelId){this.animations.delete(channelId)}update(engineTime){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=engineTime),this.setTime(this.time+(engineTime-this.lastEngineTime)),this.lastEngineTime=engineTime)}_setChannelTime(channel,time){const offsetTime=time-channel.delay;offsetTime>=channel.duration*channel.repeat?channel.time=channel.duration*channel.rate:(channel.time=Math.max(0,offsetTime)%channel.duration,channel.time*=channel.rate)}}var shader_assembler=__webpack_require__("./node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js");const DEFAULT_MODULES=[__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js").A],SHADER_HOOKS_GLSL=["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)","vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)","vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)","fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"],SHADER_HOOKS_WGSL=[];function getShaderAssembler(language){const shaderAssembler=shader_assembler._.getDefaultShaderAssembler();for(const shaderModule of DEFAULT_MODULES)shaderAssembler.addDefaultModule(shaderModule);const shaderHooks="glsl"===language?SHADER_HOOKS_GLSL:SHADER_HOOKS_WGSL;for(const shaderHook of shaderHooks)shaderAssembler.addShaderHook(shaderHook);return shaderAssembler}const uniformBlock="uniform layerUniforms {\n  uniform float opacity;\n} layer;\n",layerUniforms={name:"layer",vs:uniformBlock,fs:uniformBlock,getUniforms:props=>({opacity:Math.pow(props.opacity,1/2.2)}),uniformTypes:{opacity:"f32"}};var constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lifecycle/constants.js"),log=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/log.js"),debug=__webpack_require__("./node_modules/@deck.gl/core/dist/debug/index.js"),flatten=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/flatten.js"),dist=__webpack_require__("./node_modules/@probe.gl/stats/dist/index.js"),load=__webpack_require__("./node_modules/@loaders.gl/core/dist/lib/api/load.js");class Resource{constructor(id,data,context){this._loadCount=0,this._subscribers=new Set,this.id=id,this.context=context,this.setData(data)}subscribe(consumer){this._subscribers.add(consumer)}unsubscribe(consumer){this._subscribers.delete(consumer)}inUse(){return this._subscribers.size>0}delete(){}getData(){return this.isLoaded?this._error?Promise.reject(this._error):this._content:this._loader.then((()=>this.getData()))}setData(data,forceUpdate){if(data===this._data&&!forceUpdate)return;this._data=data;const loadCount=++this._loadCount;let loader=data;"string"==typeof data&&(loader=(0,load.H)(data)),loader instanceof Promise?(this.isLoaded=!1,this._loader=loader.then((result=>{this._loadCount===loadCount&&(this.isLoaded=!0,this._error=void 0,this._content=result)})).catch((error=>{this._loadCount===loadCount&&(this.isLoaded=!0,this._error=error||!0)}))):(this.isLoaded=!0,this._error=void 0,this._content=data);for(const subscriber of this._subscribers)subscriber.onChange(this.getData())}}class ResourceManager{constructor(props){this.protocol=props.protocol||"resource://",this._context={device:props.device,gl:props.device?.gl,resourceManager:this},this._resources={},this._consumers={},this._pruneRequest=null}contains(resourceId){return!!resourceId.startsWith(this.protocol)||resourceId in this._resources}add({resourceId:resourceId,data:data,forceUpdate:forceUpdate=!1,persistent:persistent=!0}){let res=this._resources[resourceId];res?res.setData(data,forceUpdate):(res=new Resource(resourceId,data,this._context),this._resources[resourceId]=res),res.persistent=persistent}remove(resourceId){const res=this._resources[resourceId];res&&(res.delete(),delete this._resources[resourceId])}unsubscribe({consumerId:consumerId}){const consumer=this._consumers[consumerId];if(consumer){for(const requestId in consumer){const request=consumer[requestId],resource=this._resources[request.resourceId];resource&&resource.unsubscribe(request)}delete this._consumers[consumerId],this.prune()}}subscribe({resourceId:resourceId,onChange:onChange,consumerId:consumerId,requestId:requestId="default"}){const{_resources:resources,protocol:protocol}=this;resourceId.startsWith(protocol)&&(resources[resourceId=resourceId.replace(protocol,"")]||this.add({resourceId:resourceId,data:null,persistent:!1}));const res=resources[resourceId];if(this._track(consumerId,requestId,res,onChange),res)return res.getData()}prune(){this._pruneRequest||(this._pruneRequest=setTimeout((()=>this._prune()),0))}finalize(){for(const key in this._resources)this._resources[key].delete()}_track(consumerId,requestId,resource,onChange){const consumers=this._consumers,consumer=consumers[consumerId]=consumers[consumerId]||{};let request=consumer[requestId];const oldResource=request&&request.resourceId&&this._resources[request.resourceId];oldResource&&(oldResource.unsubscribe(request),this.prune()),resource&&(request?(request.onChange=onChange,request.resourceId=resource.id):request={onChange:onChange,resourceId:resource.id},consumer[requestId]=request,resource.subscribe(request))}_prune(){this._pruneRequest=null;for(const key of Object.keys(this._resources)){const res=this._resources[key];res.persistent||res.inUse()||(res.delete(),delete this._resources[key])}}}var viewports_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/viewport.js");class LayerManager{constructor(device,props){this._lastRenderedLayers=[],this._needsRedraw=!1,this._needsUpdate=!1,this._nextLayers=null,this._debug=!1,this._defaultShaderModulesChanged=!1,this.activateViewport=viewport=>{(0,debug.A)("layerManager.activateViewport",this,viewport),viewport&&(this.context.viewport=viewport)};const{deck:deck,stats:stats,viewport:viewport,timeline:timeline}=props||{};this.layers=[],this.resourceManager=new ResourceManager({device:device,protocol:"deck://"}),this.context={mousePosition:null,userData:{},layerManager:this,device:device,gl:device?.gl,deck:deck,shaderAssembler:getShaderAssembler(device?.info?.shadingLanguage||"glsl"),defaultShaderModules:[layerUniforms],renderPass:void 0,stats:stats||new dist.Uz({id:"deck.gl"}),viewport:viewport||new viewports_viewport.A({id:"DEFAULT-INITIAL-VIEWPORT"}),timeline:timeline||new Timeline,resourceManager:this.resourceManager,onError:void 0},Object.seal(this)}finalize(){this.resourceManager.finalize();for(const layer of this.layers)this._finalizeLayer(layer)}needsRedraw(opts={clearRedrawFlags:!1}){let redraw=this._needsRedraw;opts.clearRedrawFlags&&(this._needsRedraw=!1);for(const layer of this.layers){const layerNeedsRedraw=layer.getNeedsRedraw(opts);redraw=redraw||layerNeedsRedraw}return redraw}needsUpdate(){return this._nextLayers&&this._nextLayers!==this._lastRenderedLayers?"layers changed":this._defaultShaderModulesChanged?"shader modules changed":this._needsUpdate}setNeedsRedraw(reason){this._needsRedraw=this._needsRedraw||reason}setNeedsUpdate(reason){this._needsUpdate=this._needsUpdate||reason}getLayers({layerIds:layerIds}={}){return layerIds?this.layers.filter((layer=>layerIds.find((layerId=>0===layer.id.indexOf(layerId))))):this.layers}setProps(props){"debug"in props&&(this._debug=props.debug),"userData"in props&&(this.context.userData=props.userData),"layers"in props&&(this._nextLayers=props.layers),"onError"in props&&(this.context.onError=props.onError)}setLayers(newLayers,reason){(0,debug.A)("layerManager.setLayers",this,reason,newLayers),this._lastRenderedLayers=newLayers;const flatLayers=(0,flatten.B)(newLayers,Boolean);for(const layer of flatLayers)layer.context=this.context;this._updateLayers(this.layers,flatLayers)}updateLayers(){const reason=this.needsUpdate();reason&&(this.setNeedsRedraw(`updating layers: ${reason}`),this.setLayers(this._nextLayers||this._lastRenderedLayers,reason)),this._nextLayers=null}addDefaultShaderModule(module){const{defaultShaderModules:defaultShaderModules}=this.context;defaultShaderModules.find((m=>m.name===module.name))||(defaultShaderModules.push(module),this._defaultShaderModulesChanged=!0)}removeDefaultShaderModule(module){const{defaultShaderModules:defaultShaderModules}=this.context,i=defaultShaderModules.findIndex((m=>m.name===module.name));i>=0&&(defaultShaderModules.splice(i,1),this._defaultShaderModulesChanged=!0)}_handleError(stage,error,layer){layer.raiseError(error,`${stage} of ${layer}`)}_updateLayers(oldLayers,newLayers){const oldLayerMap={};for(const oldLayer of oldLayers)oldLayerMap[oldLayer.id]?log.A.warn(`Multiple old layers with same id ${oldLayer.id}`)():oldLayerMap[oldLayer.id]=oldLayer;if(this._defaultShaderModulesChanged){for(const layer of oldLayers)layer.setNeedsUpdate(),layer.setChangeFlags({extensionsChanged:!0});this._defaultShaderModulesChanged=!1}const generatedLayers=[];this._updateSublayersRecursively(newLayers,oldLayerMap,generatedLayers),this._finalizeOldLayers(oldLayerMap);let needsUpdate=!1;for(const layer of generatedLayers)if(layer.hasUniformTransition()){needsUpdate=`Uniform transition in ${layer}`;break}this._needsUpdate=needsUpdate,this.layers=generatedLayers}_updateSublayersRecursively(newLayers,oldLayerMap,generatedLayers){for(const newLayer of newLayers){newLayer.context=this.context;const oldLayer=oldLayerMap[newLayer.id];null===oldLayer&&log.A.warn(`Multiple new layers with same id ${newLayer.id}`)(),oldLayerMap[newLayer.id]=null;let sublayers=null;try{this._debug&&oldLayer!==newLayer&&newLayer.validateProps(),oldLayer?(this._transferLayerState(oldLayer,newLayer),this._updateLayer(newLayer)):this._initializeLayer(newLayer),generatedLayers.push(newLayer),sublayers=newLayer.isComposite?newLayer.getSubLayers():null}catch(err){this._handleError("matching",err,newLayer)}sublayers&&this._updateSublayersRecursively(sublayers,oldLayerMap,generatedLayers)}}_finalizeOldLayers(oldLayerMap){for(const layerId in oldLayerMap){const layer=oldLayerMap[layerId];layer&&this._finalizeLayer(layer)}}_initializeLayer(layer){try{layer._initialize(),layer.lifecycle=constants.VD.INITIALIZED}catch(err){this._handleError("initialization",err,layer)}}_transferLayerState(oldLayer,newLayer){newLayer._transferState(oldLayer),newLayer.lifecycle=constants.VD.MATCHED,newLayer!==oldLayer&&(oldLayer.lifecycle=constants.VD.AWAITING_GC)}_updateLayer(layer){try{layer._update()}catch(err){this._handleError("update",err,layer)}}_finalizeLayer(layer){this._needsRedraw=this._needsRedraw||`finalized ${layer}`,layer.lifecycle=constants.VD.AWAITING_FINALIZATION;try{layer._finalize(),layer.lifecycle=constants.VD.FINALIZED}catch(err){this._handleError("finalization",err,layer)}}}var deep_equal=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/deep-equal.js");class ViewManager{constructor(props){this.views=[],this.width=100,this.height=100,this.viewState={},this.controllers={},this.timeline=props.timeline,this._viewports=[],this._viewportMap={},this._isUpdating=!1,this._needsRedraw="First render",this._needsUpdate="Initialize",this._eventManager=props.eventManager,this._eventCallbacks={onViewStateChange:props.onViewStateChange,onInteractionStateChange:props.onInteractionStateChange},Object.seal(this),this.setProps(props)}finalize(){for(const key in this.controllers){const controller=this.controllers[key];controller&&controller.finalize()}this.controllers={}}needsRedraw(opts={clearRedrawFlags:!1}){const redraw=this._needsRedraw;return opts.clearRedrawFlags&&(this._needsRedraw=!1),redraw}setNeedsUpdate(reason){this._needsUpdate=this._needsUpdate||reason,this._needsRedraw=this._needsRedraw||reason}updateViewStates(){for(const viewId in this.controllers){const controller=this.controllers[viewId];controller&&controller.updateTransition()}}getViewports(rect){return rect?this._viewports.filter((viewport=>viewport.containsPixel(rect))):this._viewports}getViews(){const viewMap={};return this.views.forEach((view=>{viewMap[view.id]=view})),viewMap}getView(viewId){return this.views.find((view=>view.id===viewId))}getViewState(viewOrViewId){const view="string"==typeof viewOrViewId?this.getView(viewOrViewId):viewOrViewId,viewState=view&&this.viewState[view.getViewStateId()]||this.viewState;return view?view.filterViewState(viewState):viewState}getViewport(viewId){return this._viewportMap[viewId]}unproject(xyz,opts){const viewports=this.getViewports(),pixel={x:xyz[0],y:xyz[1]};for(let i=viewports.length-1;i>=0;--i){const viewport=viewports[i];if(viewport.containsPixel(pixel)){const p=xyz.slice();return p[0]-=viewport.x,p[1]-=viewport.y,viewport.unproject(p,opts)}}return null}setProps(props){props.views&&this._setViews(props.views),props.viewState&&this._setViewState(props.viewState),("width"in props||"height"in props)&&this._setSize(props.width,props.height),this._isUpdating||this._update()}_update(){this._isUpdating=!0,this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._isUpdating=!1}_setSize(width,height){width===this.width&&height===this.height||(this.width=width,this.height=height,this.setNeedsUpdate("Size changed"))}_setViews(views){views=(0,flatten.B)(views,Boolean);this._diffViews(views,this.views)&&this.setNeedsUpdate("views changed"),this.views=views}_setViewState(viewState){if(viewState){!(0,deep_equal.b)(viewState,this.viewState,3)&&this.setNeedsUpdate("viewState changed"),this.viewState=viewState}else log.A.warn("missing `viewState` or `initialViewState`")()}_createController(view,props){return new(0,props.type)({timeline:this.timeline,eventManager:this._eventManager,onViewStateChange:this._eventCallbacks.onViewStateChange,onStateChange:this._eventCallbacks.onInteractionStateChange,makeViewport:viewState=>this.getView(view.id)?.makeViewport({viewState:viewState,width:this.width,height:this.height})})}_updateController(view,viewState,viewport,controller){const controllerProps=view.controller;if(controllerProps&&viewport){const resolvedProps={...viewState,...controllerProps,id:view.id,x:viewport.x,y:viewport.y,width:viewport.width,height:viewport.height};return controller&&controller.constructor===controllerProps.type||(controller=this._createController(view,resolvedProps)),controller&&controller.setProps(resolvedProps),controller}return null}_rebuildViewports(){const{views:views}=this,oldControllers=this.controllers;this._viewports=[],this.controllers={};let invalidateControllers=!1;for(let i=views.length;i--;){const view=views[i],viewState=this.getViewState(view),viewport=view.makeViewport({viewState:viewState,width:this.width,height:this.height});let oldController=oldControllers[view.id];const hasController=Boolean(view.controller);hasController&&!oldController&&(invalidateControllers=!0),!invalidateControllers&&hasController||!oldController||(oldController.finalize(),oldController=null),this.controllers[view.id]=this._updateController(view,viewState,viewport,oldController),viewport&&this._viewports.unshift(viewport)}for(const id in oldControllers){const oldController=oldControllers[id];oldController&&!this.controllers[id]&&oldController.finalize()}this._buildViewportMap()}_buildViewportMap(){this._viewportMap={},this._viewports.forEach((viewport=>{viewport.id&&(this._viewportMap[viewport.id]=this._viewportMap[viewport.id]||viewport)}))}_diffViews(newViews,oldViews){return newViews.length!==oldViews.length||newViews.some(((_,i)=>!newViews[i].equals(oldViews[i])))}}var map_view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/map-view.js"),lighting_effect=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js");const DEFAULT_LIGHTING_EFFECT=new lighting_effect.A;class EffectManager{constructor(context){this._resolvedEffects=[],this._defaultEffects=[],this.effects=[],this._context=context,this._needsRedraw="Initial render",this._setEffects([])}addDefaultEffect(effect){const defaultEffects=this._defaultEffects;if(!defaultEffects.find((e=>e.id===effect.id))){const index=defaultEffects.findIndex((e=>function compareEffects(e1,e2){return(e1.order??1/0)-(e2.order??1/0)}(e,effect)>0));index<0?defaultEffects.push(effect):defaultEffects.splice(index,0,effect),effect.setup(this._context),this._setEffects(this.effects)}}setProps(props){"effects"in props&&((0,deep_equal.b)(props.effects,this.effects,1)||this._setEffects(props.effects))}needsRedraw(opts={clearRedrawFlags:!1}){const redraw=this._needsRedraw;return opts.clearRedrawFlags&&(this._needsRedraw=!1),redraw}getEffects(){return this._resolvedEffects}_setEffects(effects){const oldEffectsMap={};for(const effect of this.effects)oldEffectsMap[effect.id]=effect;const nextEffects=[];for(const effect of effects){const oldEffect=oldEffectsMap[effect.id];let effectToAdd=effect;oldEffect&&oldEffect!==effect?oldEffect.setProps?(oldEffect.setProps(effect.props),effectToAdd=oldEffect):oldEffect.cleanup(this._context):oldEffect||effect.setup(this._context),nextEffects.push(effectToAdd),delete oldEffectsMap[effect.id]}for(const removedEffectId in oldEffectsMap)oldEffectsMap[removedEffectId].cleanup(this._context);this.effects=nextEffects,this._resolvedEffects=nextEffects.concat(this._defaultEffects),effects.some((effect=>effect instanceof lighting_effect.A))||this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT),this._needsRedraw="effects changed"}finalize(){for(const effect of this._resolvedEffects)effect.cleanup(this._context);this.effects.length=0,this._resolvedEffects.length=0,this._defaultEffects.length=0}}var layers_pass=__webpack_require__("./node_modules/@deck.gl/core/dist/passes/layers-pass.js");class DrawLayersPass extends layers_pass.A{shouldDrawLayer(layer){const{operation:operation}=layer.props;return operation.includes("draw")||operation.includes("terrain")}}const PICKING_BLENDING={blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"zero",blendAlphaOperation:"add",blendAlphaSrcFactor:"constant-alpha",blendAlphaDstFactor:"zero"};class PickLayersPass extends layers_pass.A{constructor(){super(...arguments),this._colorEncoderState=null}render(props){return"pickingFBO"in props?this._drawPickingBuffer(props):super.render(props)}_drawPickingBuffer({layers:layers,layerFilter:layerFilter,views:views,viewports:viewports,onViewportActive:onViewportActive,pickingFBO:pickingFBO,deviceRect:{x:x,y:y,width:width,height:height},cullRect:cullRect,effects:effects,pass:pass="picking",pickZ:pickZ,shaderModuleProps:shaderModuleProps}){this.pickZ=pickZ;const colorEncoderState=this._resetColorEncoder(pickZ),scissorRect=[x,y,width,height],renderStatus=super.render({target:pickingFBO,layers:layers,layerFilter:layerFilter,views:views,viewports:viewports,onViewportActive:onViewportActive,cullRect:cullRect,effects:effects?.filter((e=>e.useInPicking)),pass:pass,isPicking:!0,shaderModuleProps:shaderModuleProps,clearColor:[0,0,0,0],colorMask:15,scissorRect:scissorRect});this._colorEncoderState=null;return{decodePickingColor:colorEncoderState&&decodeColor.bind(null,colorEncoderState),stats:renderStatus}}shouldDrawLayer(layer){const{pickable:pickable,operation:operation}=layer.props;return pickable&&operation.includes("draw")||operation.includes("terrain")||operation.includes("mask")}getShaderModuleProps(layer,effects,otherShaderModuleProps){return{picking:{isActive:1,isAttribute:this.pickZ},lighting:{enabled:!1}}}getLayerParameters(layer,layerIndex,viewport){const pickParameters={...layer.props.parameters},{pickable:pickable,operation:operation}=layer.props;return!this._colorEncoderState||operation.includes("terrain")?pickParameters.blend=!1:pickable&&operation.includes("draw")&&(Object.assign(pickParameters,PICKING_BLENDING),pickParameters.blend=!0,pickParameters.blendColor=function encodeColor(encoded,layer,viewport){const{byLayer:byLayer,byAlpha:byAlpha}=encoded;let a,entry=byLayer.get(layer);entry?(entry.viewports.push(viewport),a=entry.a):(a=byLayer.size+1,a<=255?(entry={a:a,layer:layer,viewports:[viewport]},byLayer.set(layer,entry),byAlpha[a]=entry):(log.A.warn("Too many pickable layers, only picking the first 255")(),a=0));return[0,0,0,a/255]}(this._colorEncoderState,layer,viewport)),pickParameters}_resetColorEncoder(pickZ){return this._colorEncoderState=pickZ?null:{byLayer:new Map,byAlpha:[]},this._colorEncoderState}}function decodeColor(encoded,pickedColor){const entry=encoded.byAlpha[pickedColor[3]];return entry&&{pickedLayer:entry.layer,pickedViewports:entry.viewports,pickedObjectIndex:entry.layer.decodePickingColor(pickedColor)}}class DeckRenderer{constructor(device){this.device=device,this.layerFilter=null,this.drawPickingColors=!1,this.drawLayersPass=new DrawLayersPass(device),this.pickLayersPass=new PickLayersPass(device),this.renderCount=0,this._needsRedraw="Initial render",this.renderBuffers=[],this.lastPostProcessEffect=null}setProps(props){this.layerFilter!==props.layerFilter&&(this.layerFilter=props.layerFilter,this._needsRedraw="layerFilter changed"),this.drawPickingColors!==props.drawPickingColors&&(this.drawPickingColors=props.drawPickingColors,this._needsRedraw="drawPickingColors changed")}renderLayers(opts){if(!opts.viewports.length)return;const layerPass=this.drawPickingColors?this.pickLayersPass:this.drawLayersPass,renderOpts={layerFilter:this.layerFilter,isPicking:this.drawPickingColors,...opts};renderOpts.effects&&this._preRender(renderOpts.effects,renderOpts);const outputBuffer=this.lastPostProcessEffect?this.renderBuffers[0]:renderOpts.target;this.lastPostProcessEffect&&(renderOpts.clearColor=[0,0,0,0],renderOpts.clearCanvas=!0);const renderStats=layerPass.render({...renderOpts,target:outputBuffer});renderOpts.effects&&this._postRender(renderOpts.effects,renderOpts),this.renderCount++,(0,debug.A)("deckRenderer.renderLayers",this,renderStats,opts)}needsRedraw(opts={clearRedrawFlags:!1}){const redraw=this._needsRedraw;return opts.clearRedrawFlags&&(this._needsRedraw=!1),redraw}finalize(){const{renderBuffers:renderBuffers}=this;for(const buffer of renderBuffers)buffer.delete();renderBuffers.length=0}_preRender(effects,opts){this.lastPostProcessEffect=null,opts.preRenderStats=opts.preRenderStats||{};for(const effect of effects)opts.preRenderStats[effect.id]=effect.preRender(opts),effect.postRender&&(this.lastPostProcessEffect=effect.id);this.lastPostProcessEffect&&this._resizeRenderBuffers()}_resizeRenderBuffers(){const{renderBuffers:renderBuffers}=this,size=this.device.canvasContext.getDrawingBufferSize();0===renderBuffers.length&&[0,1].map((i=>{const texture=this.device.createTexture({sampler:{minFilter:"linear",magFilter:"linear"}});renderBuffers.push(this.device.createFramebuffer({id:`deck-renderbuffer-${i}`,colorAttachments:[texture]}))}));for(const buffer of renderBuffers)buffer.resize(size)}_postRender(effects,opts){const{renderBuffers:renderBuffers}=this,params={...opts,inputBuffer:renderBuffers[0],swapBuffer:renderBuffers[1]};for(const effect of effects)if(effect.postRender){params.target=effect.id===this.lastPostProcessEffect?opts.target:void 0;const buffer=effect.postRender(params);params.inputBuffer=buffer,params.swapBuffer=buffer===renderBuffers[0]?renderBuffers[1]:renderBuffers[0]}}}const NO_PICKED_OBJECT={pickedColor:null,pickedObjectIndex:-1};function getClosestObject({pickedColors:pickedColors,decodePickingColor:decodePickingColor,deviceX:deviceX,deviceY:deviceY,deviceRadius:deviceRadius,deviceRect:deviceRect}){const{x:x,y:y,width:width,height:height}=deviceRect;let minSquareDistanceToCenter=deviceRadius*deviceRadius,closestPixelIndex=-1,i=0;for(let row=0;row<height;row++){const dy=row+y-deviceY,dy2=dy*dy;if(dy2>minSquareDistanceToCenter)i+=4*width;else for(let col=0;col<width;col++){if(pickedColors[i+3]-1>=0){const dx=col+x-deviceX,d2=dx*dx+dy2;d2<=minSquareDistanceToCenter&&(minSquareDistanceToCenter=d2,closestPixelIndex=i)}i+=4}}if(closestPixelIndex>=0){const pickedColor=pickedColors.slice(closestPixelIndex,closestPixelIndex+4),pickedObject=decodePickingColor(pickedColor);if(pickedObject){const dy=Math.floor(closestPixelIndex/4/width),dx=closestPixelIndex/4-dy*width;return{...pickedObject,pickedColor:pickedColor,pickedX:x+dx,pickedY:y+dy}}log.A.error("Picked non-existent layer. Is picking buffer corrupt?")()}return NO_PICKED_OBJECT}function getEmptyPickingInfo({pickInfo:pickInfo,viewports:viewports,pixelRatio:pixelRatio,x:x,y:y,z:z}){let coordinate,pickedViewport=viewports[0];if(viewports.length>1&&(pickedViewport=function getViewportFromCoordinates(viewports,pixel){for(let i=viewports.length-1;i>=0;i--){const viewport=viewports[i];if(viewport.containsPixel(pixel))return viewport}return viewports[0]}(pickInfo?.pickedViewports||viewports,{x:x,y:y})),pickedViewport){const point=[x-pickedViewport.x,y-pickedViewport.y];void 0!==z&&(point[2]=z),coordinate=pickedViewport.unproject(point)}return{color:null,layer:null,viewport:pickedViewport,index:-1,picked:!1,x:x,y:y,pixel:[x,y],coordinate:coordinate,devicePixel:pickInfo&&"pickedX"in pickInfo?[pickInfo.pickedX,pickInfo.pickedY]:void 0,pixelRatio:pixelRatio}}function processPickInfo(opts){const{pickInfo:pickInfo,lastPickedInfo:lastPickedInfo,mode:mode,layers:layers}=opts,{pickedColor:pickedColor,pickedLayer:pickedLayer,pickedObjectIndex:pickedObjectIndex}=pickInfo,affectedLayers=pickedLayer?[pickedLayer]:[];if("hover"===mode){const lastPickedPixelIndex=lastPickedInfo.index,lastPickedLayerId=lastPickedInfo.layerId,pickedLayerId=pickedLayer?pickedLayer.props.id:null;if(pickedLayerId!==lastPickedLayerId||pickedObjectIndex!==lastPickedPixelIndex){if(pickedLayerId!==lastPickedLayerId){const lastPickedLayer=layers.find((layer=>layer.props.id===lastPickedLayerId));lastPickedLayer&&affectedLayers.unshift(lastPickedLayer)}lastPickedInfo.layerId=pickedLayerId,lastPickedInfo.index=pickedObjectIndex,lastPickedInfo.info=null}}const baseInfo=getEmptyPickingInfo(opts),infos=new Map;return infos.set(null,baseInfo),affectedLayers.forEach((layer=>{let info={...baseInfo};layer===pickedLayer&&(info.color=pickedColor,info.index=pickedObjectIndex,info.picked=!0),info=getLayerPickingInfo({layer:layer,info:info,mode:mode});const rootLayer=info.layer;layer===pickedLayer&&"hover"===mode&&(lastPickedInfo.info=info),infos.set(rootLayer.id,info),"hover"===mode&&rootLayer.updateAutoHighlight(info)})),infos}function getLayerPickingInfo({layer:layer,info:info,mode:mode}){for(;layer&&info;){const sourceLayer=info.layer||null;info.sourceLayer=sourceLayer,info.layer=layer,info=layer.getPickingInfo({info:info,mode:mode,sourceLayer:sourceLayer}),layer=layer.parent}return info}class DeckPicker{constructor(device){this._pickable=!0,this.device=device,this.pickLayersPass=new PickLayersPass(device),this.lastPickedInfo={index:-1,layerId:null,info:null}}setProps(props){"layerFilter"in props&&(this.layerFilter=props.layerFilter),"_pickable"in props&&(this._pickable=props._pickable)}finalize(){this.pickingFBO&&this.pickingFBO.destroy(),this.depthFBO&&this.depthFBO.destroy()}pickObject(opts){return this._pickClosestObject(opts)}pickObjects(opts){return this._pickVisibleObjects(opts)}getLastPickedObject({x:x,y:y,layers:layers,viewports:viewports},lastPickedInfo=this.lastPickedInfo.info){const lastPickedLayerId=lastPickedInfo&&lastPickedInfo.layer&&lastPickedInfo.layer.id,lastPickedViewportId=lastPickedInfo&&lastPickedInfo.viewport&&lastPickedInfo.viewport.id,layer=lastPickedLayerId?layers.find((l=>l.id===lastPickedLayerId)):null,viewport=lastPickedViewportId&&viewports.find((v=>v.id===lastPickedViewportId))||viewports[0],coordinate=viewport&&viewport.unproject([x-viewport.x,y-viewport.y]),info={x:x,y:y,viewport:viewport,coordinate:coordinate,layer:layer};return{...lastPickedInfo,...info}}_resizeBuffer(){if(!this.pickingFBO&&(this.pickingFBO=this.device.createFramebuffer({colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth16unorm"}),this.device.isTextureFormatRenderable("rgba32float"))){const depthFBO=this.device.createFramebuffer({colorAttachments:["rgba32float"],depthStencilAttachment:"depth16unorm"});this.depthFBO=depthFBO}const{canvas:canvas}=this.device.getDefaultCanvasContext();this.pickingFBO?.resize({width:canvas.width,height:canvas.height}),this.depthFBO?.resize({width:canvas.width,height:canvas.height})}_getPickable(layers){if(!1===this._pickable)return null;const pickableLayers=layers.filter((layer=>this.pickLayersPass.shouldDrawLayer(layer)&&!layer.isComposite));return pickableLayers.length?pickableLayers:null}_pickClosestObject({layers:layers,views:views,viewports:viewports,x:x,y:y,radius:radius=0,depth:depth=1,mode:mode="query",unproject3D:unproject3D,onViewportActive:onViewportActive,effects:effects}){const pixelRatio=this.device.canvasContext.cssToDeviceRatio(),pickableLayers=this._getPickable(layers);if(!pickableLayers||0===viewports.length)return{result:[],emptyInfo:getEmptyPickingInfo({viewports:viewports,x:x,y:y,pixelRatio:pixelRatio})};this._resizeBuffer();const devicePixelRange=this.device.canvasContext.cssToDevicePixels([x,y],!0),devicePixel=[devicePixelRange.x+Math.floor(devicePixelRange.width/2),devicePixelRange.y+Math.floor(devicePixelRange.height/2)],deviceRadius=Math.round(radius*pixelRatio),{width:width,height:height}=this.pickingFBO,deviceRect=this._getPickingRect({deviceX:devicePixel[0],deviceY:devicePixel[1],deviceRadius:deviceRadius,deviceWidth:width,deviceHeight:height}),cullRect={x:x-radius,y:y-radius,width:2*radius+1,height:2*radius+1};let infos;const result=[],affectedLayers=new Set;for(let i=0;i<depth;i++){let pickInfo,z;if(deviceRect){pickInfo=getClosestObject({...this._drawAndSample({layers:pickableLayers,views:views,viewports:viewports,onViewportActive:onViewportActive,deviceRect:deviceRect,cullRect:cullRect,effects:effects,pass:`picking:${mode}`}),deviceX:devicePixel[0],deviceY:devicePixel[1],deviceRadius:deviceRadius,deviceRect:deviceRect})}else pickInfo={pickedColor:null,pickedObjectIndex:-1};if(pickInfo.pickedLayer&&unproject3D&&this.depthFBO){const{pickedColors:pickedColors2}=this._drawAndSample({layers:[pickInfo.pickedLayer],views:views,viewports:viewports,onViewportActive:onViewportActive,deviceRect:{x:pickInfo.pickedX,y:pickInfo.pickedY,width:1,height:1},cullRect:cullRect,effects:effects,pass:`picking:${mode}:z`},!0);pickedColors2[3]&&(z=pickedColors2[0])}pickInfo.pickedLayer&&i+1<depth&&(affectedLayers.add(pickInfo.pickedLayer),pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex)),infos=processPickInfo({pickInfo:pickInfo,lastPickedInfo:this.lastPickedInfo,mode:mode,layers:pickableLayers,viewports:viewports,x:x,y:y,z:z,pixelRatio:pixelRatio});for(const info of infos.values())info.layer&&result.push(info);if(!pickInfo.pickedColor)break}for(const layer of affectedLayers)layer.restorePickingColors();return{result:result,emptyInfo:infos.get(null)}}_pickVisibleObjects({layers:layers,views:views,viewports:viewports,x:x,y:y,width:width=1,height:height=1,mode:mode="query",maxObjects:maxObjects=null,onViewportActive:onViewportActive,effects:effects}){const pickableLayers=this._getPickable(layers);if(!pickableLayers||0===viewports.length)return[];this._resizeBuffer();const pixelRatio=this.device.canvasContext.cssToDeviceRatio(),leftTop=this.device.canvasContext.cssToDevicePixels([x,y],!0),deviceLeft=leftTop.x,deviceTop=leftTop.y+leftTop.height,rightBottom=this.device.canvasContext.cssToDevicePixels([x+width,y+height],!0),deviceRight=rightBottom.x+rightBottom.width,deviceBottom=rightBottom.y,deviceRect={x:deviceLeft,y:deviceBottom,width:deviceRight-deviceLeft,height:deviceTop-deviceBottom},pickInfos=function getUniqueObjects({pickedColors:pickedColors,decodePickingColor:decodePickingColor}){const uniqueColors=new Map;if(pickedColors)for(let i=0;i<pickedColors.length;i+=4)if(pickedColors[i+3]-1>=0){const pickedColor=pickedColors.slice(i,i+4),colorKey=pickedColor.join(",");if(!uniqueColors.has(colorKey)){const pickedObject=decodePickingColor(pickedColor);pickedObject?uniqueColors.set(colorKey,{...pickedObject,color:pickedColor}):log.A.error("Picked non-existent layer. Is picking buffer corrupt?")()}}return Array.from(uniqueColors.values())}(this._drawAndSample({layers:pickableLayers,views:views,viewports:viewports,onViewportActive:onViewportActive,deviceRect:deviceRect,cullRect:{x:x,y:y,width:width,height:height},effects:effects,pass:`picking:${mode}`})),uniquePickedObjects=new Map,uniqueInfos=[],limitMaxObjects=Number.isFinite(maxObjects);for(let i=0;i<pickInfos.length&&!(limitMaxObjects&&uniqueInfos.length>=maxObjects);i++){const pickInfo=pickInfos[i];let info={color:pickInfo.pickedColor,layer:null,index:pickInfo.pickedObjectIndex,picked:!0,x:x,y:y,pixelRatio:pixelRatio};info=getLayerPickingInfo({layer:pickInfo.pickedLayer,info:info,mode:mode});const pickedLayerId=info.layer.id;uniquePickedObjects.has(pickedLayerId)||uniquePickedObjects.set(pickedLayerId,new Set);const uniqueObjectsInLayer=uniquePickedObjects.get(pickedLayerId),pickedObjectKey=info.object??info.index;uniqueObjectsInLayer.has(pickedObjectKey)||(uniqueObjectsInLayer.add(pickedObjectKey),uniqueInfos.push(info))}return uniqueInfos}_drawAndSample({layers:layers,views:views,viewports:viewports,onViewportActive:onViewportActive,deviceRect:deviceRect,cullRect:cullRect,effects:effects,pass:pass},pickZ=!1){const pickingFBO=pickZ?this.depthFBO:this.pickingFBO,opts={layers:layers,layerFilter:this.layerFilter,views:views,viewports:viewports,onViewportActive:onViewportActive,pickingFBO:pickingFBO,deviceRect:deviceRect,cullRect:cullRect,effects:effects,pass:pass,pickZ:pickZ,preRenderStats:{},isPicking:!0};for(const effect of effects)effect.useInPicking&&(opts.preRenderStats[effect.id]=effect.preRender(opts));const{decodePickingColor:decodePickingColor}=this.pickLayersPass.render(opts),{x:x,y:y,width:width,height:height}=deviceRect,pickedColors=new(pickZ?Float32Array:Uint8Array)(width*height*4);return this.device.readPixelsToArrayWebGL(pickingFBO,{sourceX:x,sourceY:y,sourceWidth:width,sourceHeight:height,target:pickedColors}),{pickedColors:pickedColors,decodePickingColor:decodePickingColor}}_getPickingRect({deviceX:deviceX,deviceY:deviceY,deviceRadius:deviceRadius,deviceWidth:deviceWidth,deviceHeight:deviceHeight}){const x=Math.max(0,deviceX-deviceRadius),y=Math.max(0,deviceY-deviceRadius),width=Math.min(deviceWidth,deviceX+deviceRadius+1)-x,height=Math.min(deviceHeight,deviceY+deviceRadius+1)-y;return width<=0||height<=0?null:{x:x,y:y,width:width,height:height}}}var lib_constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js");const PLACEMENTS={"top-left":{top:0,left:0},"top-right":{top:0,right:0},"bottom-left":{bottom:0,left:0},"bottom-right":{bottom:0,right:0},fill:{top:0,left:0,bottom:0,right:0}},DEFAULT_PLACEMENT="top-left";class WidgetManager{constructor({deck:deck,parentElement:parentElement}){this.defaultWidgets=[],this.widgets=[],this.resolvedWidgets=[],this.containers={},this.lastViewports={},this.deck=deck,this.parentElement=parentElement}getWidgets(){return this.resolvedWidgets}setProps(props){props.widgets&&!(0,deep_equal.b)(props.widgets,this.widgets,1)&&this._setWidgets(props.widgets)}finalize(){for(const widget of this.getWidgets())this._remove(widget);this.defaultWidgets.length=0,this.resolvedWidgets.length=0;for(const id in this.containers)this.containers[id].remove()}addDefault(widget){this.defaultWidgets.find((w=>w.id===widget.id))||(this._add(widget),this.defaultWidgets.push(widget),this._setWidgets(this.widgets))}_setWidgets(nextWidgets){const oldWidgetMap={};for(const widget of this.resolvedWidgets)oldWidgetMap[widget.id]=widget;this.resolvedWidgets.length=0;for(const widget of this.defaultWidgets)oldWidgetMap[widget.id]=null,this.resolvedWidgets.push(widget);for(let widget of nextWidgets){const oldWidget=oldWidgetMap[widget.id];oldWidget?oldWidget.viewId!==widget.viewId||oldWidget.placement!==widget.placement?(this._remove(oldWidget),this._add(widget)):widget!==oldWidget&&(oldWidget.setProps(widget.props),widget=oldWidget):this._add(widget),oldWidgetMap[widget.id]=null,this.resolvedWidgets.push(widget)}for(const id in oldWidgetMap){const oldWidget=oldWidgetMap[id];oldWidget&&this._remove(oldWidget)}this.widgets=nextWidgets}_add(widget){const{viewId:viewId=null,placement:placement=DEFAULT_PLACEMENT}=widget,element=widget.onAdd({deck:this.deck,viewId:viewId});element&&this._getContainer(viewId,placement).append(element),widget._element=element}_remove(widget){widget.onRemove?.(),widget._element&&widget._element.remove(),widget._element=void 0}_getContainer(viewId,placement){const containerId=viewId||"__root";let viewContainer=this.containers[containerId];viewContainer||(viewContainer=document.createElement("div"),viewContainer.style.pointerEvents="none",viewContainer.style.position="absolute",viewContainer.style.overflow="hidden",this.parentElement?.append(viewContainer),this.containers[containerId]=viewContainer);let container=viewContainer.querySelector(`.${placement}`);return container||(container=document.createElement("div"),container.className=placement,container.style.position="absolute",container.style.zIndex="2",Object.assign(container.style,PLACEMENTS[placement]),viewContainer.append(container)),container}_updateContainers(){const canvasWidth=this.deck.width,canvasHeight=this.deck.height;for(const id in this.containers){const viewport=this.lastViewports[id]||null,visible="__root"===id||viewport,container=this.containers[id];visible?(container.style.display="block",container.style.left=`${viewport?viewport.x:0}px`,container.style.top=`${viewport?viewport.y:0}px`,container.style.width=`${viewport?viewport.width:canvasWidth}px`,container.style.height=`${viewport?viewport.height:canvasHeight}px`):container.style.display="none"}}onRedraw({viewports:viewports,layers:layers}){const viewportsById=viewports.reduce(((acc,v)=>(acc[v.id]=v,acc)),{});for(const widget of this.getWidgets()){const{viewId:viewId}=widget;if(viewId){const viewport=viewportsById[viewId];viewport&&(widget.onViewportChange&&widget.onViewportChange(viewport),widget.onRedraw?.({viewports:[viewport],layers:layers}))}else{if(widget.onViewportChange)for(const viewport of viewports)widget.onViewportChange(viewport);widget.onRedraw?.({viewports:viewports,layers:layers})}}this.lastViewports=viewportsById,this._updateContainers()}onHover(info,event){for(const widget of this.getWidgets()){const{viewId:viewId}=widget;viewId&&viewId!==info.viewport?.id||widget.onHover?.(info,event)}}onEvent(info,event){const eventHandlerProp=lib_constants.tg[event.type];if(eventHandlerProp)for(const widget of this.getWidgets()){const{viewId:viewId}=widget;viewId&&viewId!==info.viewport?.id||widget[eventHandlerProp]?.(info,event)}}}const defaultStyle={zIndex:"1",position:"absolute",pointerEvents:"none",color:"#a0a7b4",backgroundColor:"#29323c",padding:"10px",top:"0",left:"0",display:"none"};class Tooltip{constructor(){this.id="default-tooltip",this.placement="fill",this.props={},this.isVisible=!1}onAdd({deck:deck}){const el=document.createElement("div");return el.className="deck-tooltip",Object.assign(el.style,defaultStyle),this.deck=deck,this.element=el,el}onRemove(){this.deck=void 0,this.element=void 0}setProps(){}onViewportChange(viewport){this.isVisible&&viewport.id===this.lastViewport?.id&&viewport!==this.lastViewport&&this.setTooltip(null)}onHover(info){const{deck:deck}=this,getTooltip=deck&&deck.props.getTooltip;if(!getTooltip)return;const displayInfo=getTooltip(info);this.lastViewport=info.viewport,this.setTooltip(displayInfo,info.x,info.y)}setTooltip(displayInfo,x,y){const el=this.element;if(el){if("string"==typeof displayInfo)el.innerText=displayInfo;else{if(!displayInfo)return this.isVisible=!1,void(el.style.display="none");displayInfo.text&&(el.innerText=displayInfo.text),displayInfo.html&&(el.innerHTML=displayInfo.html),displayInfo.className&&(el.className=displayInfo.className)}this.isVisible=!0,el.style.display="block",el.style.transform=`translate(${x}px, ${y}px)`,displayInfo&&"object"==typeof displayInfo&&"style"in displayInfo&&Object.assign(el.style,displayInfo.style)}}}var typed_array_manager=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/typed-array-manager.js"),register_loaders=__webpack_require__("./node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js"),image_loader=__webpack_require__("./node_modules/@loaders.gl/images/dist/image-loader.js");var json_loader={dataType:null,batchType:null,id:"JSON",name:"JSON",module:"",version:"",options:{},extensions:["json","geojson"],mimeTypes:["application/json","application/geo+json"],testText:function isJSON(text){const firstChar=text[0],lastChar=text[text.length-1];return"{"===firstChar&&"}"===lastChar||"["===firstChar&&"]"===lastChar},parseTextSync:JSON.parse};const VERSION=function checkVersion(){const existingVersion=globalThis.deck&&globalThis.deck.VERSION;if(existingVersion&&"9.1.14"!==existingVersion)throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs 9.1.14`);return existingVersion||(log.A.log(1,"deck.gl 9.1.14")(),globalThis.deck={...globalThis.deck,VERSION:"9.1.14",version:"9.1.14",log:log.A,_registerLoggers:debug.k},(0,register_loaders.mk)([json_loader,[image_loader.$,{imagebitmap:{premultiplyAlpha:"none"}}]])),"9.1.14"}();var is_browser=__webpack_require__("./node_modules/@probe.gl/env/dist/lib/is-browser.js"),device=__webpack_require__("./node_modules/@luma.gl/core/dist/adapter/device.js"),stats_manager=__webpack_require__("./node_modules/@luma.gl/core/dist/utils/stats-manager.js"),utils_log=__webpack_require__("./node_modules/@luma.gl/core/dist/utils/log.js");const isPage=(0,is_browser.B)()&&"undefined"!=typeof document,ERROR_MESSAGE="No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";class Luma{static defaultProps={...device.pF.defaultProps,type:"best-available",adapters:void 0,waitForPageLoad:!0};static pageLoaded=function getPageLoadPromise(){if(isPage&&"complete"===document.readyState||"undefined"==typeof window)return Promise.resolve();return new Promise((resolve=>{window.addEventListener("load",(()=>resolve()))}))}().then((()=>{utils_log.R.probe(2,"DOM is loaded")()}));stats=stats_manager.d;log=utils_log.R;VERSION="9.1.9";spector;preregisteredAdapters=new Map;constructor(){if(globalThis.luma){if(globalThis.luma.VERSION!==this.VERSION)throw utils_log.R.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(),utils_log.R.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(),new Error("luma.gl - multiple versions detected: see console log");utils_log.R.error("This version of luma.gl has already been initialized")()}utils_log.R.log(1,`${this.VERSION} - set luma.log.level=1 (or higher) to trace rendering`)(),globalThis.luma=this}registerAdapters(adapters){for(const deviceClass of adapters)this.preregisteredAdapters.set(deviceClass.type,deviceClass)}getSupportedAdapters(adapters=[]){const adapterMap=this.getAdapterMap(adapters);return Array.from(adapterMap).map((([,adapter])=>adapter)).filter((adapter=>adapter.isSupported?.())).map((adapter=>adapter.type))}getBestAvailableAdapter(adapters=[]){const adapterMap=this.getAdapterMap(adapters);return adapterMap.get("webgpu")?.isSupported?.()?"webgpu":adapterMap.get("webgl")?.isSupported?.()?"webgl":null}setDefaultDeviceProps(props){Object.assign(Luma.defaultProps,props)}async createDevice(props={}){(props={...Luma.defaultProps,...props}).waitForPageLoad&&await Luma.pageLoaded;const adapterMap=this.getAdapterMap(props.adapters);let type=props.type||"";"best-available"===type&&(type=this.getBestAvailableAdapter(props.adapters)||type);const adapter=(this.getAdapterMap(props.adapters)||adapterMap).get(type),device=await(adapter?.create?.(props));if(device)return device;throw new Error(ERROR_MESSAGE)}async attachDevice(props){const adapters=this.getAdapterMap(props.adapters);let type="";props.handle instanceof WebGL2RenderingContext&&(type="webgl"),props.createCanvasContext&&await Luma.pageLoaded,null===props.handle&&(type="unknown");const adapter=adapters.get(type),device=await(adapter?.attach?.(null));if(device)return device;throw new Error(ERROR_MESSAGE)}enforceWebGL2(enforce=!0,adapters=[]){const webgl2Adapter=this.getAdapterMap(adapters).get("webgl");webgl2Adapter||utils_log.R.warn("enforceWebGL2: webgl adapter not found")(),webgl2Adapter?.enforceWebGL2?.(enforce)}getAdapterMap(adapters=[]){const map=new Map(this.preregisteredAdapters);for(const adapter of adapters)map.set(adapter.type,adapter);return map}registerDevices(deviceClasses){utils_log.R.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");for(const deviceClass of deviceClasses){const adapter=deviceClass.adapter;adapter&&this.preregisteredAdapters.set(adapter.type,adapter)}}}const luma=new Luma;class Adapter{}var webgl_device=__webpack_require__("./node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js");const WEBGL1_STATIC_EXTENSIONS={WEBGL_depth_texture:{UNSIGNED_INT_24_8_WEBGL:34042},OES_element_index_uint:{},OES_texture_float:{},OES_texture_half_float:{HALF_FLOAT_OES:5131},EXT_color_buffer_float:{},OES_standard_derivatives:{FRAGMENT_SHADER_DERIVATIVE_HINT_OES:35723},EXT_frag_depth:{},EXT_blend_minmax:{MIN_EXT:32775,MAX_EXT:32776},EXT_shader_texture_lod:{}},getWEBGL_draw_buffers=gl=>({drawBuffersWEBGL(buffers){return gl.drawBuffers(buffers)},COLOR_ATTACHMENT0_WEBGL:36064,COLOR_ATTACHMENT1_WEBGL:36065,COLOR_ATTACHMENT2_WEBGL:36066,COLOR_ATTACHMENT3_WEBGL:36067}),getOES_vertex_array_object=gl=>({VERTEX_ARRAY_BINDING_OES:34229,createVertexArrayOES(){return gl.createVertexArray()},deleteVertexArrayOES(vertexArray){return gl.deleteVertexArray(vertexArray)},isVertexArrayOES(vertexArray){return gl.isVertexArray(vertexArray)},bindVertexArrayOES(vertexArray){return gl.bindVertexArray(vertexArray)}}),getANGLE_instanced_arrays=gl=>({VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:35070,drawArraysInstancedANGLE(...args){return gl.drawArraysInstanced(...args)},drawElementsInstancedANGLE(...args){return gl.drawElementsInstanced(...args)},vertexAttribDivisorANGLE(...args){return gl.vertexAttribDivisor(...args)}});function enforceWebGL2(enforce=!0){const prototype=HTMLCanvasElement.prototype;if(!enforce&&prototype.originalGetContext)return prototype.getContext=prototype.originalGetContext,void(prototype.originalGetContext=void 0);prototype.originalGetContext=prototype.getContext,prototype.getContext=function(contextId,options){if("webgl"===contextId||"experimental-webgl"===contextId){const context=this.originalGetContext("webgl2",options);return context instanceof HTMLElement&&function polyfillWebGL1Extensions(gl){gl.getExtension("EXT_color_buffer_float");const boundExtensions={...WEBGL1_STATIC_EXTENSIONS,WEBGL_disjoint_timer_query:gl.getExtension("EXT_disjoint_timer_query_webgl2"),WEBGL_draw_buffers:getWEBGL_draw_buffers(gl),OES_vertex_array_object:getOES_vertex_array_object(gl),ANGLE_instanced_arrays:getANGLE_instanced_arrays(gl)},originalGetExtension=gl.getExtension;gl.getExtension=function(extensionName){const ext=originalGetExtension.call(gl,extensionName);return ext||(extensionName in boundExtensions?boundExtensions[extensionName]:null)};const originalGetSupportedExtensions=gl.getSupportedExtensions;gl.getSupportedExtensions=function(){const extensions=originalGetSupportedExtensions.apply(gl)||[];return extensions?.concat(Object.keys(boundExtensions))}}(context),context}return this.originalGetContext(contextId,options)}}var spector=__webpack_require__("./node_modules/@luma.gl/webgl/dist/context/debug/spector.js"),webgl_developer_tools=__webpack_require__("./node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js");const webgl2Adapter=new class WebGLAdapter extends Adapter{type="webgl";constructor(){super(),device.pF.defaultProps={...device.pF.defaultProps,...spector.ic},webgl_device.e.adapter=this}isSupported(){return"undefined"!=typeof WebGL2RenderingContext}enforceWebGL2(enable){enforceWebGL2(enable)}async attach(gl){if(gl instanceof webgl_device.e)return gl;if(gl?.device instanceof device.pF)return gl.device;if(!function isWebGL(gl){if("undefined"!=typeof WebGL2RenderingContext&&gl instanceof WebGL2RenderingContext)return!0;return Boolean(gl&&Number.isFinite(gl._version))}(gl))throw new Error("Invalid WebGL2RenderingContext");return new webgl_device.e({_handle:gl,createCanvasContext:{canvas:gl.canvas,autoResize:!1}})}async create(props={}){utils_log.R.groupCollapsed(1,"WebGLDevice created")();const promises=[];(props.debugWebGL||props.debug)&&promises.push((0,webgl_developer_tools.$)()),props.debugSpectorJS&&promises.push((0,spector._G)(props));const results=await Promise.allSettled(promises);for(const result of results)"rejected"===result.status&&utils_log.R.error(`Failed to initialize debug libraries ${result.reason}`)();const device=new webgl_device.e(props),message=`${device._reused?"Reusing":"Created"} device with WebGL2 ${device.debug?"debug ":""}context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;return utils_log.R.probe(1,message)(),utils_log.R.table(1,device.info)(),utils_log.R.groupEnd(1)(),device}};let statIdCounter=0;const DEFAULT_ANIMATION_LOOP_PROPS={device:null,onAddHTML:()=>"",onInitialize:async()=>null,onRender:()=>{},onFinalize:()=>{},onError:error=>console.error(error),stats:luma.stats.get("animation-loop-"+statIdCounter++),useDevicePixels:!0,autoResizeViewport:!1,autoResizeDrawingBuffer:!1};class AnimationLoop{device=null;canvas=null;props;animationProps=null;timeline=null;stats;cpuTime;gpuTime;frameRate;display;needsRedraw="initialized";_initialized=!1;_running=!1;_animationFrameId=null;_nextFramePromise=null;_resolveNextFrame=null;_cpuStartTime=0;_error=null;constructor(props){if(this.props={...DEFAULT_ANIMATION_LOOP_PROPS,...props},!(props=this.props).device)throw new Error("No device provided");const{useDevicePixels:useDevicePixels=!0}=this.props;this.stats=props.stats||new dist.Uz({id:"animation-loop-stats"}),this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this.setProps({autoResizeViewport:props.autoResizeViewport,autoResizeDrawingBuffer:props.autoResizeDrawingBuffer,useDevicePixels:useDevicePixels}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}destroy(){this.stop(),this._setDisplay(null)}delete(){this.destroy()}setError(error){this.props.onError(error),this._error=Error();const canvas=this.device?.canvasContext?.canvas;if(canvas instanceof HTMLCanvasElement){const errorDiv=document.createElement("h1");errorDiv.innerHTML=error.message,errorDiv.style.position="absolute",errorDiv.style.top="20%",errorDiv.style.left="10px",errorDiv.style.color="black",errorDiv.style.backgroundColor="red",document.body.appendChild(errorDiv)}}setNeedsRedraw(reason){return this.needsRedraw=this.needsRedraw||reason,this}setProps(props){return"autoResizeViewport"in props&&(this.props.autoResizeViewport=props.autoResizeViewport||!1),"autoResizeDrawingBuffer"in props&&(this.props.autoResizeDrawingBuffer=props.autoResizeDrawingBuffer||!1),"useDevicePixels"in props&&(this.props.useDevicePixels=props.useDevicePixels||!1),this}async start(){if(this._running)return this;this._running=!0;try{let appContext;return this._initialized||(this._initialized=!0,await this._initDevice(),this._initialize(),await this.props.onInitialize(this._getAnimationProps())),this._running?(!1!==appContext&&(this._cancelAnimationFrame(),this._requestAnimationFrame()),this):null}catch(err){const error=err instanceof Error?err:new Error("Unknown error");throw this.props.onError(error),error}}stop(){return this._running&&(this.animationProps&&!this._error&&this.props.onFinalize(this.animationProps),this._cancelAnimationFrame(),this._nextFramePromise=null,this._resolveNextFrame=null,this._running=!1),this}redraw(){return this.device?.isLost||this._error||(this._beginFrameTimers(),this._setupFrame(),this._updateAnimationProps(),this._renderFrame(this._getAnimationProps()),this._clearNeedsRedraw(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endFrameTimers()),this}attachTimeline(timeline){return this.timeline=timeline,this.timeline}detachTimeline(){this.timeline=null}waitForRender(){return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise((resolve=>{this._resolveNextFrame=resolve}))),this._nextFramePromise}async toDataURL(){if(this.setNeedsRedraw("toDataURL"),await this.waitForRender(),this.canvas instanceof HTMLCanvasElement)return this.canvas.toDataURL();throw new Error("OffscreenCanvas")}_initialize(){this._startEventHandling(),this._initializeAnimationProps(),this._updateAnimationProps(),this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_setDisplay(display){this.display&&(this.display.destroy(),this.display.animationLoop=null),display&&(display.animationLoop=this),this.display=display}_requestAnimationFrame(){this._running&&(this._animationFrameId=function requestAnimationFramePolyfill(callback){return"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(callback):setTimeout(callback,1e3/60)}(this._animationFrame.bind(this)))}_cancelAnimationFrame(){null!==this._animationFrameId&&(!function cancelAnimationFramePolyfill(timerId){return"undefined"!=typeof window&&window.cancelAnimationFrame?window.cancelAnimationFrame(timerId):clearTimeout(timerId)}(this._animationFrameId),this._animationFrameId=null)}_animationFrame(){this._running&&(this.redraw(),this._requestAnimationFrame())}_renderFrame(animationProps){this.display?this.display._renderFrame(animationProps):(this.props.onRender(this._getAnimationProps()),this.device?.submit())}_clearNeedsRedraw(){this.needsRedraw=!1}_setupFrame(){this._resizeCanvasDrawingBuffer(),this._resizeViewport()}_initializeAnimationProps(){const canvas=this.device?.canvasContext?.canvas;if(!this.device||!canvas)throw new Error("loop");this.animationProps={animationLoop:this,device:this.device,canvas:canvas,timeline:this.timeline,useDevicePixels:this.props.useDevicePixels,needsRedraw:!1,width:1,height:1,aspect:1,time:0,startTime:Date.now(),engineTime:0,tick:0,tock:0,_mousePosition:null}}_getAnimationProps(){if(!this.animationProps)throw new Error("animationProps");return this.animationProps}_updateAnimationProps(){if(!this.animationProps)return;const{width:width,height:height,aspect:aspect}=this._getSizeAndAspect();width===this.animationProps.width&&height===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),aspect!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=width,this.animationProps.height=height,this.animationProps.aspect=aspect,this.animationProps.needsRedraw=this.needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime}async _initDevice(){if(this.device=await this.props.device,!this.device)throw new Error("No device provided");this.canvas=this.device.canvasContext?.canvas||null}_createInfoDiv(){if(this.canvas&&this.props.onAddHTML){const wrapperDiv=document.createElement("div");document.body.appendChild(wrapperDiv),wrapperDiv.style.position="relative";const div=document.createElement("div");div.style.position="absolute",div.style.left="10px",div.style.bottom="10px",div.style.width="300px",div.style.background="white",this.canvas instanceof HTMLCanvasElement&&wrapperDiv.appendChild(this.canvas),wrapperDiv.appendChild(div);const html=this.props.onAddHTML(div);html&&(div.innerHTML=html)}}_getSizeAndAspect(){if(!this.device)return{width:1,height:1,aspect:1};const[width,height]=this.device?.canvasContext?.getPixelSize()||[1,1];let aspect=1;const canvas=this.device?.canvasContext?.canvas;return canvas&&canvas.clientHeight?aspect=canvas.clientWidth/canvas.clientHeight:width>0&&height>0&&(aspect=width/height),{width:width,height:height,aspect:aspect}}_resizeViewport(){this.props.autoResizeViewport&&this.device.gl&&this.device.gl.viewport(0,0,this.device.gl.drawingBufferWidth,this.device.gl.drawingBufferHeight)}_resizeCanvasDrawingBuffer(){this.props.autoResizeDrawingBuffer&&this.device?.canvasContext?.resize({useDevicePixels:this.props.useDevicePixels})}_beginFrameTimers(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this.cpuTime.timeStart()}_endFrameTimers(){this.cpuTime.timeEnd()}_startEventHandling(){this.canvas&&(this.canvas.addEventListener("mousemove",this._onMousemove.bind(this)),this.canvas.addEventListener("mouseleave",this._onMouseleave.bind(this)))}_onMousemove(event){event instanceof MouseEvent&&(this._getAnimationProps()._mousePosition=[event.offsetX,event.offsetY])}_onMouseleave(event){this._getAnimationProps()._mousePosition=null}}var mjolnir_js_dist=__webpack_require__("./node_modules/mjolnir.js/dist/index.js"),assert=__webpack_require__("./node_modules/@deck.gl/core/dist/utils/assert.js");function noop(){}const defaultProps={id:"",width:"100%",height:"100%",style:null,viewState:null,initialViewState:null,pickingRadius:0,layerFilter:null,parameters:{},parent:null,device:null,deviceProps:{},gl:null,canvas:null,layers:[],effects:[],views:null,controller:null,useDevicePixels:!0,touchAction:"none",eventRecognizerOptions:{},_framebuffer:null,_animate:!1,_pickable:!0,_typedArrayManagerProps:{},_customRender:null,widgets:[],onDeviceInitialized:noop,onWebGLInitialized:noop,onResize:noop,onViewStateChange:noop,onInteractionStateChange:noop,onBeforeRender:noop,onAfterRender:noop,onLoad:noop,onError:error=>log.A.error(error.message,error.cause)(),onHover:null,onClick:null,onDragStart:null,onDrag:null,onDragEnd:null,_onMetrics:null,getCursor:({isDragging:isDragging})=>isDragging?"grabbing":"grab",getTooltip:null,debug:!1,drawPickingColors:!1};class Deck{constructor(props){this.width=0,this.height=0,this.userData={},this.device=null,this.canvas=null,this.viewManager=null,this.layerManager=null,this.effectManager=null,this.deckRenderer=null,this.deckPicker=null,this.eventManager=null,this.widgetManager=null,this.tooltip=null,this.animationLoop=null,this.cursorState={isHovering:!1,isDragging:!1},this.stats=new dist.Uz({id:"deck.gl"}),this.metrics={fps:0,setPropsTime:0,updateAttributesTime:0,framesRedrawn:0,pickTime:0,pickCount:0,gpuTime:0,gpuTimePerFrame:0,cpuTime:0,cpuTimePerFrame:0,bufferMemory:0,textureMemory:0,renderbufferMemory:0,gpuMemory:0},this._metricsCounter=0,this._needsRedraw="Initial render",this._pickRequest={mode:"hover",x:-1,y:-1,radius:0,event:null},this._lastPointerDownInfo=null,this._onPointerMove=event=>{const{_pickRequest:_pickRequest}=this;if("pointerleave"===event.type)_pickRequest.x=-1,_pickRequest.y=-1,_pickRequest.radius=0;else{if(event.leftButton||event.rightButton)return;{const pos=event.offsetCenter;if(!pos)return;_pickRequest.x=pos.x,_pickRequest.y=pos.y,_pickRequest.radius=this.props.pickingRadius}}this.layerManager&&(this.layerManager.context.mousePosition={x:_pickRequest.x,y:_pickRequest.y}),_pickRequest.event=event},this._onEvent=event=>{const eventHandlerProp=lib_constants.tg[event.type],pos=event.offsetCenter;if(!eventHandlerProp||!pos||!this.layerManager)return;const layers=this.layerManager.getLayers(),info=this.deckPicker.getLastPickedObject({x:pos.x,y:pos.y,layers:layers,viewports:this.getViewports(pos)},this._lastPointerDownInfo),{layer:layer}=info,layerHandler=layer&&(layer[eventHandlerProp]||layer.props[eventHandlerProp]),rootHandler=this.props[eventHandlerProp];let handled=!1;layerHandler&&(handled=layerHandler.call(layer,info,event)),handled||(rootHandler?.(info,event),this.widgetManager.onEvent(info,event))},this._onPointerDown=event=>{if("webgpu"===this.device?.type)return;const pos=event.offsetCenter,pickedInfo=this._pick("pickObject","pickObject Time",{x:pos.x,y:pos.y,radius:this.props.pickingRadius});this._lastPointerDownInfo=pickedInfo.result[0]||pickedInfo.emptyInfo},this.props={...defaultProps,...props},(props=this.props).viewState&&props.initialViewState&&log.A.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(),this.viewState=this.props.initialViewState,props.device&&(this.device=props.device);let deviceOrPromise=this.device;!deviceOrPromise&&props.gl&&(props.gl instanceof WebGLRenderingContext&&log.A.error("WebGL1 context not supported.")(),deviceOrPromise=webgl2Adapter.attach(props.gl)),deviceOrPromise||(deviceOrPromise=luma.createDevice({type:"best-available",_reuseDevices:!0,adapters:[webgl2Adapter],...props.deviceProps,createCanvasContext:{canvas:this._createCanvas(props),useDevicePixels:this.props.useDevicePixels,autoResize:!1}})),this.animationLoop=this._createAnimationLoop(deviceOrPromise,props),this.setProps(props),props._typedArrayManagerProps&&typed_array_manager.A.setOptions(props._typedArrayManagerProps),this.animationLoop.start()}finalize(){this.animationLoop?.stop(),this.animationLoop?.destroy(),this.animationLoop=null,this._lastPointerDownInfo=null,this.layerManager?.finalize(),this.layerManager=null,this.viewManager?.finalize(),this.viewManager=null,this.effectManager?.finalize(),this.effectManager=null,this.deckRenderer?.finalize(),this.deckRenderer=null,this.deckPicker?.finalize(),this.deckPicker=null,this.eventManager?.destroy(),this.eventManager=null,this.widgetManager?.finalize(),this.widgetManager=null,this.props.canvas||this.props.device||this.props.gl||!this.canvas||(this.canvas.parentElement?.removeChild(this.canvas),this.canvas=null)}setProps(props){this.stats.get("setProps Time").timeStart(),"onLayerHover"in props&&log.A.removed("onLayerHover","onHover")(),"onLayerClick"in props&&log.A.removed("onLayerClick","onClick")(),props.initialViewState&&!(0,deep_equal.b)(this.props.initialViewState,props.initialViewState,3)&&(this.viewState=props.initialViewState),Object.assign(this.props,props),this._setCanvasSize(this.props);const resolvedProps=Object.create(this.props);Object.assign(resolvedProps,{views:this._getViews(),width:this.width,height:this.height,viewState:this._getViewState()}),this.animationLoop?.setProps(resolvedProps),this.layerManager&&(this.viewManager.setProps(resolvedProps),this.layerManager.activateViewport(this.getViewports()[0]),this.layerManager.setProps(resolvedProps),this.effectManager.setProps(resolvedProps),this.deckRenderer.setProps(resolvedProps),this.deckPicker.setProps(resolvedProps),this.widgetManager.setProps(resolvedProps)),this.stats.get("setProps Time").timeEnd()}needsRedraw(opts={clearRedrawFlags:!1}){if(!this.layerManager)return!1;if(this.props._animate)return"Deck._animate";let redraw=this._needsRedraw;opts.clearRedrawFlags&&(this._needsRedraw=!1);const viewManagerNeedsRedraw=this.viewManager.needsRedraw(opts),layerManagerNeedsRedraw=this.layerManager.needsRedraw(opts),effectManagerNeedsRedraw=this.effectManager.needsRedraw(opts),deckRendererNeedsRedraw=this.deckRenderer.needsRedraw(opts);return redraw=redraw||viewManagerNeedsRedraw||layerManagerNeedsRedraw||effectManagerNeedsRedraw||deckRendererNeedsRedraw,redraw}redraw(reason){if(!this.layerManager)return;let redrawReason=this.needsRedraw({clearRedrawFlags:!0});redrawReason=reason||redrawReason,redrawReason&&(this.stats.get("Redraw Count").incrementCount(),this.props._customRender?this.props._customRender(redrawReason):this._drawLayers(redrawReason))}get isInitialized(){return null!==this.viewManager}getViews(){return(0,assert.A)(this.viewManager),this.viewManager.views}getViewports(rect){return(0,assert.A)(this.viewManager),this.viewManager.getViewports(rect)}getCanvas(){return this.canvas}pickObject(opts){const infos=this._pick("pickObject","pickObject Time",opts).result;return infos.length?infos[0]:null}pickMultipleObjects(opts){return opts.depth=opts.depth||10,this._pick("pickObject","pickMultipleObjects Time",opts).result}pickObjects(opts){return this._pick("pickObjects","pickObjects Time",opts)}_addResources(resources,forceUpdate=!1){for(const id in resources)this.layerManager.resourceManager.add({resourceId:id,data:resources[id],forceUpdate:forceUpdate})}_removeResources(resourceIds){for(const id of resourceIds)this.layerManager.resourceManager.remove(id)}_addDefaultEffect(effect){this.effectManager.addDefaultEffect(effect)}_addDefaultShaderModule(module){this.layerManager.addDefaultShaderModule(module)}_removeDefaultShaderModule(module){this.layerManager?.removeDefaultShaderModule(module)}_pick(method,statKey,opts){(0,assert.A)(this.deckPicker);const{stats:stats}=this;stats.get("Pick Count").incrementCount(),stats.get(statKey).timeStart();const infos=this.deckPicker[method]({layers:this.layerManager.getLayers(opts),views:this.viewManager.getViews(),viewports:this.getViewports(opts),onViewportActive:this.layerManager.activateViewport,effects:this.effectManager.getEffects(),...opts});return stats.get(statKey).timeEnd(),infos}_createCanvas(props){let canvas=props.canvas;if("string"==typeof canvas&&(canvas=document.getElementById(canvas),(0,assert.A)(canvas)),!canvas){canvas=document.createElement("canvas"),canvas.id=props.id||"deckgl-overlay";(props.parent||document.body).appendChild(canvas)}return Object.assign(canvas.style,props.style),canvas}_setCanvasSize(props){if(!this.canvas)return;const{width:width,height:height}=props;if(width||0===width){const cssWidth=Number.isFinite(width)?`${width}px`:width;this.canvas.style.width=cssWidth}if(height||0===height){const cssHeight=Number.isFinite(height)?`${height}px`:height;this.canvas.style.position=props.style?.position||"absolute",this.canvas.style.height=cssHeight}}_updateCanvasSize(){const{canvas:canvas}=this;if(!canvas)return;const newWidth=canvas.clientWidth??canvas.width,newHeight=canvas.clientHeight??canvas.height;newWidth===this.width&&newHeight===this.height||(this.width=newWidth,this.height=newHeight,this.viewManager?.setProps({width:newWidth,height:newHeight}),this.layerManager?.activateViewport(this.getViewports()[0]),this.props.onResize({width:newWidth,height:newHeight}))}_createAnimationLoop(deviceOrPromise,props){const{gl:gl,onError:onError,useDevicePixels:useDevicePixels}=props;return new AnimationLoop({device:deviceOrPromise,useDevicePixels:useDevicePixels,autoResizeDrawingBuffer:!gl,autoResizeViewport:!1,onInitialize:context=>this._setDevice(context.device),onRender:this._onRenderFrame.bind(this),onError:onError})}_getViewState(){return this.props.viewState||this.viewState}_getViews(){const{views:views}=this.props,normalizedViews=Array.isArray(views)?views:views?[views]:[new map_view.A({id:"default-view"})];return normalizedViews.length&&this.props.controller&&(normalizedViews[0].props.controller=this.props.controller),normalizedViews}_onContextLost(){const{onError:onError}=this.props;this.animationLoop&&onError&&onError(new Error("WebGL context is lost"))}_pickAndCallback(){if("webgpu"===this.device?.type)return;const{_pickRequest:_pickRequest}=this;if(_pickRequest.event){const{result:result,emptyInfo:emptyInfo}=this._pick("pickObject","pickObject Time",_pickRequest);this.cursorState.isHovering=result.length>0;let pickedInfo=emptyInfo,handled=!1;for(const info of result)pickedInfo=info,handled=info.layer?.onHover(info,_pickRequest.event)||handled;handled||(this.props.onHover?.(pickedInfo,_pickRequest.event),this.widgetManager.onHover(pickedInfo,_pickRequest.event)),_pickRequest.event=null}}_updateCursor(){const container=this.props.parent||this.canvas;container&&(container.style.cursor=this.props.getCursor(this.cursorState))}_setDevice(device){if(this.device=device,!this.animationLoop)return;this.canvas||(this.canvas=this.device.canvasContext?.canvas),"webgl"===this.device.type&&this.device.setParametersWebGL({blend:!0,blendFunc:[770,771,1,771],polygonOffsetFill:!0,depthTest:!0,depthFunc:515}),this.props.onDeviceInitialized(this.device),"webgl"===this.device.type&&this.props.onWebGLInitialized(this.device.gl);const timeline=new Timeline;timeline.play(),this.animationLoop.attachTimeline(timeline),this.eventManager=new mjolnir_js_dist.EU(this.props.parent||this.canvas,{touchAction:this.props.touchAction,recognizers:Object.keys(lib_constants.We).map((eventName=>{const[RecognizerConstructor,defaultOptions,recognizeWith,requestFailure]=lib_constants.We[eventName],optionsOverride=this.props.eventRecognizerOptions?.[eventName];return{recognizer:new RecognizerConstructor({...defaultOptions,...optionsOverride,event:eventName}),recognizeWith:recognizeWith,requestFailure:requestFailure}})),events:{pointerdown:this._onPointerDown,pointermove:this._onPointerMove,pointerleave:this._onPointerMove}});for(const eventType in lib_constants.tg)this.eventManager.on(eventType,this._onEvent);this.viewManager=new ViewManager({timeline:timeline,eventManager:this.eventManager,onViewStateChange:this._onViewStateChange.bind(this),onInteractionStateChange:this._onInteractionStateChange.bind(this),views:this._getViews(),viewState:this._getViewState(),width:this.width,height:this.height});const viewport=this.viewManager.getViewports()[0];this.layerManager=new LayerManager(this.device,{deck:this,stats:this.stats,viewport:viewport,timeline:timeline}),this.effectManager=new EffectManager({deck:this,device:this.device}),this.deckRenderer=new DeckRenderer(this.device),this.deckPicker=new DeckPicker(this.device),this.widgetManager=new WidgetManager({deck:this,parentElement:this.canvas?.parentElement}),this.widgetManager.addDefault(new Tooltip),this.setProps(this.props),this._updateCanvasSize(),this.props.onLoad()}_drawLayers(redrawReason,renderOptions){const{device:device,gl:gl}=this.layerManager.context;this.props.onBeforeRender({device:device,gl:gl});const opts={target:this.props._framebuffer,layers:this.layerManager.getLayers(),viewports:this.viewManager.getViewports(),onViewportActive:this.layerManager.activateViewport,views:this.viewManager.getViews(),pass:"screen",effects:this.effectManager.getEffects(),...renderOptions};this.deckRenderer?.renderLayers(opts),"screen"===opts.pass&&this.widgetManager.onRedraw({viewports:opts.viewports,layers:opts.layers}),this.props.onAfterRender({device:device,gl:gl})}_onRenderFrame(){this._getFrameStats(),this._metricsCounter++%60==0&&(this._getMetrics(),this.stats.reset(),log.A.table(4,this.metrics)(),this.props._onMetrics&&this.props._onMetrics(this.metrics)),this._updateCanvasSize(),this._updateCursor(),this.layerManager.updateLayers(),"webgpu"!==this.device?.type&&this._pickAndCallback(),this.redraw(),this.viewManager&&this.viewManager.updateViewStates()}_onViewStateChange(params){const viewState=this.props.onViewStateChange(params)||params.viewState;this.viewState&&(this.viewState={...this.viewState,[params.viewId]:viewState},this.props.viewState||this.viewManager&&this.viewManager.setProps({viewState:this.viewState}))}_onInteractionStateChange(interactionState){this.cursorState.isDragging=interactionState.isDragging||!1,this.props.onInteractionStateChange(interactionState)}_getFrameStats(){const{stats:stats}=this;stats.get("frameRate").timeEnd(),stats.get("frameRate").timeStart();const animationLoopStats=this.animationLoop.stats;stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming),stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming)}_getMetrics(){const{metrics:metrics,stats:stats}=this;metrics.fps=stats.get("frameRate").getHz(),metrics.setPropsTime=stats.get("setProps Time").time,metrics.updateAttributesTime=stats.get("Update Attributes").time,metrics.framesRedrawn=stats.get("Redraw Count").count,metrics.pickTime=stats.get("pickObject Time").time+stats.get("pickMultipleObjects Time").time+stats.get("pickObjects Time").time,metrics.pickCount=stats.get("Pick Count").count,metrics.gpuTime=stats.get("GPU Time").time,metrics.cpuTime=stats.get("CPU Time").time,metrics.gpuTimePerFrame=stats.get("GPU Time").getAverageTime(),metrics.cpuTimePerFrame=stats.get("CPU Time").getAverageTime();const memoryStats=luma.stats.get("Memory Usage");metrics.bufferMemory=memoryStats.get("Buffer Memory").count,metrics.textureMemory=memoryStats.get("Texture Memory").count,metrics.renderbufferMemory=memoryStats.get("Renderbuffer Memory").count,metrics.gpuMemory=memoryStats.get("GPU Memory").count}}Deck.defaultProps=defaultProps,Deck.VERSION=VERSION;var deck=Deck;var use_isomorphic_layout_effect="undefined"!=typeof window?react.useLayoutEffect:react.useEffect;function inheritsFrom(Type,ParentType){for(;Type;){if(Type===ParentType)return!0;Type=Object.getPrototypeOf(Type)}return!1}var view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/view.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js");const MAP_STYLE={position:"absolute",zIndex:-1};function evaluateChildren(children,childProps){if("function"==typeof children)return children(childProps);if(Array.isArray(children))return children.map((child=>evaluateChildren(child,childProps)));if(isComponent(children)){if(function isReactMap(child){return child.props?.mapStyle}(children))return childProps.style=MAP_STYLE,(0,react.cloneElement)(children,childProps);if(function needsDeckGLViewProps(child){const componentClass=child.type;return componentClass&&componentClass.deckGLViewProps}(children))return(0,react.cloneElement)(children,childProps)}return children}function isComponent(child){return child&&"object"==typeof child&&"type"in child||!1}function wrapInView(node){if("function"==typeof node)return(0,react.createElement)(view.A,{},node);if(Array.isArray(node))return node.map(wrapInView);if(isComponent(node)){if(node.type===react.Fragment)return wrapInView(node.props.children);if(inheritsFrom(node.type,view.A))return node}return node}const DeckGlContext=(0,react.createContext)();const CANVAS_ONLY_STYLES={mixBlendMode:null};function redrawDeck(thisRef){thisRef.redrawReason&&(thisRef.deck._drawLayers(thisRef.redrawReason),thisRef.redrawReason=null)}const DeckGL=react.forwardRef((function DeckGLWithRef(props,ref){const[version,setVersion]=(0,react.useState)(0),thisRef=(0,react.useRef)({control:null,version:version,forceUpdate:()=>setVersion((v=>v+1))}).current,containerRef=(0,react.useRef)(null),canvasRef=(0,react.useRef)(null),jsxProps=(0,react.useMemo)((()=>function extractJSXLayers({children:children,layers:layers=[],views:views=null}){const reactChildren=[],jsxLayers=[],jsxViews={};return react.Children.forEach(wrapInView(children),(reactElement=>{if(isComponent(reactElement)){const ElementType=reactElement.type;if(inheritsFrom(ElementType,lib_layer.A)){const layer=function createLayer(LayerType,reactProps){const props={},defaultProps=LayerType.defaultProps||{};for(const key in reactProps)defaultProps[key]!==reactProps[key]&&(props[key]=reactProps[key]);return new LayerType(props)}(ElementType,reactElement.props);jsxLayers.push(layer)}else reactChildren.push(reactElement);if(inheritsFrom(ElementType,view.A)&&ElementType!==view.A&&reactElement.props.id){const view=new ElementType(reactElement.props);jsxViews[view.id]=view}}else reactElement&&reactChildren.push(reactElement)})),Object.keys(jsxViews).length>0&&(Array.isArray(views)?views.forEach((view=>{jsxViews[view.id]=view})):views&&(jsxViews[views.id]=views),views=Object.values(jsxViews)),{layers:layers=jsxLayers.length>0?[...jsxLayers,...layers]:layers,children:reactChildren,views:views}}(props)),[props.layers,props.views,props.children]);let inRender=!0;const handleViewStateChange=params=>inRender&&props.viewState?(thisRef.viewStateUpdateRequested=params,null):(thisRef.viewStateUpdateRequested=null,props.onViewStateChange?.(params)),handleInteractionStateChange=params=>{inRender?thisRef.interactionStateUpdateRequested=params:(thisRef.interactionStateUpdateRequested=null,props.onInteractionStateChange?.(params))},deckProps=(0,react.useMemo)((()=>{const forwardProps={widgets:[],...props,style:null,width:"100%",height:"100%",parent:containerRef.current,canvas:canvasRef.current,layers:jsxProps.layers,views:jsxProps.views,onViewStateChange:handleViewStateChange,onInteractionStateChange:handleInteractionStateChange};return delete forwardProps._customRender,thisRef.deck&&thisRef.deck.setProps(forwardProps),forwardProps}),[props]);(0,react.useEffect)((()=>{const DeckClass=props.Deck||deck;return thisRef.deck=function createDeckInstance(thisRef,DeckClass,props){const deck=new DeckClass({...props,_customRender:"webgpu"===props.deviceProps?.adapters?.[0]?.type?void 0:redrawReason=>{thisRef.redrawReason=redrawReason;const viewports=deck.getViewports();thisRef.lastRenderedViewports!==viewports?thisRef.forceUpdate():redrawDeck(thisRef)}});return deck}(thisRef,DeckClass,{...deckProps,parent:containerRef.current,canvas:canvasRef.current}),()=>thisRef.deck?.finalize()}),[]),use_isomorphic_layout_effect((()=>{redrawDeck(thisRef);const{viewStateUpdateRequested:viewStateUpdateRequested,interactionStateUpdateRequested:interactionStateUpdateRequested}=thisRef;viewStateUpdateRequested&&handleViewStateChange(viewStateUpdateRequested),interactionStateUpdateRequested&&handleInteractionStateChange(interactionStateUpdateRequested)})),(0,react.useImperativeHandle)(ref,(()=>function getRefHandles(thisRef){return{get deck(){return thisRef.deck},pickObject:opts=>thisRef.deck.pickObject(opts),pickMultipleObjects:opts=>thisRef.deck.pickMultipleObjects(opts),pickObjects:opts=>thisRef.deck.pickObjects(opts)}}(thisRef)),[]);const currentViewports=thisRef.deck&&thisRef.deck.isInitialized?thisRef.deck.getViewports():void 0,{ContextProvider:ContextProvider,width:width="100%",height:height="100%",id:id,style:style}=props,{containerStyle:containerStyle,canvasStyle:canvasStyle}=(0,react.useMemo)((()=>function extractStyles({width:width,height:height,style:style}){const containerStyle={position:"absolute",zIndex:0,left:0,top:0,width:width,height:height},canvasStyle={left:0,top:0};if(style)for(const key in style)key in CANVAS_ONLY_STYLES?canvasStyle[key]=style[key]:containerStyle[key]=style[key];return{containerStyle:containerStyle,canvasStyle:canvasStyle}}({width:width,height:height,style:style})),[width,height,style]);if(!thisRef.viewStateUpdateRequested&&thisRef.lastRenderedViewports===currentViewports||thisRef.version!==version){thisRef.lastRenderedViewports=currentViewports,thisRef.version=version;const childrenUnderViews=function positionChildrenUnderViews({children:children,deck:deck,ContextProvider:ContextProvider=DeckGlContext.Provider}){const{viewManager:viewManager}=deck||{};if(!viewManager||!viewManager.views.length)return[];const views={},defaultViewId=viewManager.views[0].id;for(const child of children){let viewId=defaultViewId,viewChildren=child;isComponent(child)&&inheritsFrom(child.type,view.A)&&(viewId=child.props.id||defaultViewId,viewChildren=child.props.children);const viewport=viewManager.getViewport(viewId),viewState=viewManager.getViewState(viewId);if(viewport){viewState.padding=viewport.padding;const{x:x,y:y,width:width,height:height}=viewport;viewChildren=evaluateChildren(viewChildren,{x:x,y:y,width:width,height:height,viewport:viewport,viewState:viewState}),views[viewId]||(views[viewId]={viewport:viewport,children:[]}),views[viewId].children.push(viewChildren)}}return Object.keys(views).map((viewId=>{const{viewport:viewport,children:viewChildren}=views[viewId],{x:x,y:y,width:width,height:height}=viewport,style={position:"absolute",left:x,top:y,width:width,height:height},key=`view-${viewId}`,viewElement=(0,react.createElement)("div",{key:key,id:key,style:style},...viewChildren),contextValue={deck:deck,viewport:viewport,container:deck.canvas.offsetParent,eventManager:deck.eventManager,onViewStateChange:params=>{params.viewId=viewId,deck._onViewStateChange(params)},widgets:[]},providerKey=`view-${viewId}-context`;return(0,react.createElement)(ContextProvider,{key:providerKey,value:contextValue},viewElement)}))}({children:jsxProps.children,deck:thisRef.deck,ContextProvider:ContextProvider}),canvas=(0,react.createElement)("canvas",{key:"canvas",id:id||"deckgl-overlay",ref:canvasRef,style:canvasStyle});thisRef.control=(0,react.createElement)("div",{id:`${id||"deckgl"}-wrapper`,ref:containerRef,style:containerStyle},[canvas,childrenUnderViews])}return inRender=!1,thisRef.control}));var deckgl=DeckGL},"./node_modules/@loaders.gl/images/dist/image-loader.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{$:function(){return ImageLoader}});var assert=__webpack_require__("./node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js"),globals=__webpack_require__("./node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js");const parseImageNode=globalThis.loaders?.parseImageNode,IMAGE_SUPPORTED="undefined"!=typeof Image,IMAGE_BITMAP_SUPPORTED="undefined"!=typeof ImageBitmap,NODE_IMAGE_SUPPORTED=Boolean(parseImageNode),DATA_SUPPORTED=!!globals.Bd||NODE_IMAGE_SUPPORTED;var parsed_image_api=__webpack_require__("./node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js");const SVG_DATA_URL_PATTERN=/^data:image\/svg\+xml/,SVG_URL_PATTERN=/\.svg((\?|#).*)?$/;function isSVG(url){return url&&(SVG_DATA_URL_PATTERN.test(url)||SVG_URL_PATTERN.test(url))}function getBlob(arrayBuffer,url){if(isSVG(url))throw new Error("SVG cannot be parsed directly to imagebitmap");return new Blob([new Uint8Array(arrayBuffer)])}async function parseToImage(arrayBuffer,options,url){const blobOrDataUrl=function getBlobOrSVGDataUrl(arrayBuffer,url){if(isSVG(url)){let xmlText=(new TextDecoder).decode(arrayBuffer);try{"function"==typeof unescape&&"function"==typeof encodeURIComponent&&(xmlText=unescape(encodeURIComponent(xmlText)))}catch(error){throw new Error(error.message)}return`data:image/svg+xml;base64,${btoa(xmlText)}`}return getBlob(arrayBuffer,url)}(arrayBuffer,url),URL=self.URL||self.webkitURL,objectUrl="string"!=typeof blobOrDataUrl&&URL.createObjectURL(blobOrDataUrl);try{return await async function loadToImage(url,options){const image=new Image;if(image.src=url,options.image&&options.image.decode&&image.decode)return await image.decode(),image;return await new Promise(((resolve,reject)=>{try{image.onload=()=>resolve(image),image.onerror=error=>{const message=error instanceof Error?error.message:"error";reject(new Error(message))}}catch(error){reject(error)}}))}(objectUrl||blobOrDataUrl,options)}finally{objectUrl&&URL.revokeObjectURL(objectUrl)}}const EMPTY_OBJECT={};let imagebitmapOptionsSupported=!0;async function parseToImageBitmap(arrayBuffer,options,url){let blob;if(isSVG(url)){blob=await parseToImage(arrayBuffer,options,url)}else blob=getBlob(arrayBuffer,url);const imagebitmapOptions=options&&options.imagebitmap;return await async function safeCreateImageBitmap(blob,imagebitmapOptions=null){!function isEmptyObject(object){for(const key in object||EMPTY_OBJECT)return!1;return!0}(imagebitmapOptions)&&imagebitmapOptionsSupported||(imagebitmapOptions=null);if(imagebitmapOptions)try{return await createImageBitmap(blob,imagebitmapOptions)}catch(error){console.warn(error),imagebitmapOptionsSupported=!1}return await createImageBitmap(blob)}(blob,imagebitmapOptions)}var binary_image_api=__webpack_require__("./node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js");const ImageLoader={dataType:null,batchType:null,id:"image",module:"images",name:"Images",version:"4.2.2",mimeTypes:["image/png","image/jpeg","image/gif","image/webp","image/avif","image/bmp","image/vnd.microsoft.icon","image/svg+xml"],extensions:["png","jpg","jpeg","gif","webp","bmp","ico","svg","avif"],parse:async function parseImage(arrayBuffer,options,context){const imageType=((options=options||{}).image||{}).type||"auto",{url:url}=context||{};let image;switch(function getLoadableImageType(type){switch(type){case"auto":case"data":return function getDefaultImageType(){if(IMAGE_BITMAP_SUPPORTED)return"imagebitmap";if(IMAGE_SUPPORTED)return"image";if(DATA_SUPPORTED)return"data";throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")}();default:return function isImageTypeSupported(type){switch(type){case"auto":return IMAGE_BITMAP_SUPPORTED||IMAGE_SUPPORTED||DATA_SUPPORTED;case"imagebitmap":return IMAGE_BITMAP_SUPPORTED;case"image":return IMAGE_SUPPORTED;case"data":return DATA_SUPPORTED;default:throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`)}}(type),type}}(imageType)){case"imagebitmap":image=await parseToImageBitmap(arrayBuffer,options,url);break;case"image":image=await parseToImage(arrayBuffer,options,url);break;case"data":image=await async function parseToNodeImage(arrayBuffer,options){const{mimeType:mimeType}=(0,binary_image_api.m)(arrayBuffer)||{},parseImageNode=globalThis.loaders?.parseImageNode;return(0,assert.v)(parseImageNode),await parseImageNode(arrayBuffer,mimeType)}(arrayBuffer);break;default:(0,assert.v)(!1)}return"data"===imageType&&(image=(0,parsed_image_api.M5)(image)),image},tests:[arrayBuffer=>Boolean((0,binary_image_api.m)(new DataView(arrayBuffer)))],options:{image:{type:"auto",decode:!0}}}},"./node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function getISOBMFFMediaType(buffer){return function checkString(buffer,header,offset=0){const headerBytes=function stringToBytes(string){return[...string].map((character=>character.charCodeAt(0)))}(header);for(let i=0;i<headerBytes.length;++i)if(headerBytes[i]!==buffer[i+offset])return!1;return!0}(buffer,"ftyp",4)&&96&buffer[8]?function decodeMajorBrand(buffer){switch(function getUTF8String(array,start,end){return String.fromCharCode(...array.slice(start,end))}(buffer,8,12).replace("\0"," ").trim()){case"avif":case"avis":return{extension:"avif",mimeType:"image/avif"};default:return null}}(buffer):null}__webpack_require__.d(__webpack_exports__,{m:function(){return getBinaryImageMetadata}});const BIG_ENDIAN=!1,LITTLE_ENDIAN=!0;function getBinaryImageMetadata(binaryData){const dataView=toDataView(binaryData);return function getPngMetadata(binaryData){const dataView=toDataView(binaryData),isPng=dataView.byteLength>=24&&2303741511===dataView.getUint32(0,BIG_ENDIAN);if(!isPng)return null;return{mimeType:"image/png",width:dataView.getUint32(16,BIG_ENDIAN),height:dataView.getUint32(20,BIG_ENDIAN)}}(dataView)||function getJpegMetadata(binaryData){const dataView=toDataView(binaryData),isJpeg=dataView.byteLength>=3&&65496===dataView.getUint16(0,BIG_ENDIAN)&&255===dataView.getUint8(2);if(!isJpeg)return null;const{tableMarkers:tableMarkers,sofMarkers:sofMarkers}=function getJpegMarkers(){const tableMarkers=new Set([65499,65476,65484,65501,65534]);for(let i=65504;i<65520;++i)tableMarkers.add(i);const sofMarkers=new Set([65472,65473,65474,65475,65477,65478,65479,65481,65482,65483,65485,65486,65487,65502]);return{tableMarkers:tableMarkers,sofMarkers:sofMarkers}}();let i=2;for(;i+9<dataView.byteLength;){const marker=dataView.getUint16(i,BIG_ENDIAN);if(sofMarkers.has(marker))return{mimeType:"image/jpeg",height:dataView.getUint16(i+5,BIG_ENDIAN),width:dataView.getUint16(i+7,BIG_ENDIAN)};if(!tableMarkers.has(marker))return null;i+=2,i+=dataView.getUint16(i,BIG_ENDIAN)}return null}(dataView)||function getGifMetadata(binaryData){const dataView=toDataView(binaryData),isGif=dataView.byteLength>=10&&1195984440===dataView.getUint32(0,BIG_ENDIAN);if(!isGif)return null;return{mimeType:"image/gif",width:dataView.getUint16(6,LITTLE_ENDIAN),height:dataView.getUint16(8,LITTLE_ENDIAN)}}(dataView)||function getBmpMetadata(binaryData){const dataView=toDataView(binaryData),isBmp=dataView.byteLength>=14&&16973===dataView.getUint16(0,BIG_ENDIAN)&&dataView.getUint32(2,LITTLE_ENDIAN)===dataView.byteLength;if(!isBmp)return null;return{mimeType:"image/bmp",width:dataView.getUint32(18,LITTLE_ENDIAN),height:dataView.getUint32(22,LITTLE_ENDIAN)}}(dataView)||function getISOBMFFMetadata(binaryData){const buffer=new Uint8Array(binaryData instanceof DataView?binaryData.buffer:binaryData),mediaType=getISOBMFFMediaType(buffer);if(!mediaType)return null;return{mimeType:mediaType.mimeType,width:0,height:0}}(dataView)}function toDataView(data){if(data instanceof DataView)return data;if(ArrayBuffer.isView(data))return new DataView(data.buffer);if(data instanceof ArrayBuffer)return new DataView(data);throw new Error("toDataView")}},"./node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function getImageType(image){const format=getImageTypeOrNull(image);if(!format)throw new Error("Not an image");return format}function getImageData(image){switch(getImageType(image)){case"data":return image;case"image":case"imagebitmap":const canvas=document.createElement("canvas"),context=canvas.getContext("2d");if(!context)throw new Error("getImageData");return canvas.width=image.width,canvas.height=image.height,context.drawImage(image,0,0),context.getImageData(0,0,image.width,image.height);default:throw new Error("getImageData")}}function getImageTypeOrNull(image){return"undefined"!=typeof ImageBitmap&&image instanceof ImageBitmap?"imagebitmap":"undefined"!=typeof Image&&image instanceof Image?"image":image&&"object"==typeof image&&image.data&&image.width&&image.height?"data":null}__webpack_require__.d(__webpack_exports__,{M5:function(){return getImageData}})},"./node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function assert(condition,message){if(!condition)throw new Error(message||"loader assertion failed.")}__webpack_require__.d(__webpack_exports__,{v:function(){return assert}})},"./node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Bd:function(){return isBrowser}});var process=__webpack_require__("./node_modules/process/browser.js");"undefined"!=typeof self&&self,"undefined"!=typeof window&&window,void 0!==__webpack_require__.g&&__webpack_require__.g,"undefined"!=typeof document&&document;const isBrowser=Boolean("object"!=typeof process||"[object process]"!==String(process)||process.browser),matches=void 0!==process&&process.version&&/v([0-9]*)/.exec(process.version);matches&&parseFloat(matches[1])}}]);