(self.webpackChunk_webviz_subsurface_components=self.webpackChunk_webviz_subsurface_components||[]).push([[510],{"./packages/subsurface-viewer/src/SubsurfaceViewer.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{e:function(){return _layers_grid3d_grid3dLayer__WEBPACK_IMPORTED_MODULE_2__.e}});var convert_units__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/convert-units/lib/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(convert_units__WEBPACK_IMPORTED_MODULE_0__),prop_types__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/prop-types/index.js"),prop_types__WEBPACK_IMPORTED_MODULE_4___default=__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/index.js"),_layers_grid3d_grid3dLayer__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./packages/subsurface-viewer/src/layers/grid3d/grid3dLayer.ts"),_components_Map__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./packages/subsurface-viewer/src/components/Map.tsx");function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}const SubsurfaceViewer=({id:id,resources:resources,layers:layers,bounds:bounds,cameraPosition:cameraPosition,triggerHome:triggerHome,views:views,coords:coords,scale:scale,coordinateUnit:coordinateUnit,colorTables:colorTables,editedData:editedData,setProps:setProps,checkDatafileSchema:checkDatafileSchema,onMouseEvent:onMouseEvent,selection:selection,getTooltip:getTooltip,getCameraPosition:getCameraPosition,onRenderingProgress:onRenderingProgress,onDragStart:onDragStart,onDragEnd:onDragEnd,triggerResetMultipleWells:triggerResetMultipleWells,lights:lights,children:children,verticalScale:verticalScale,...args})=>{const[layerEditedData,setLayerEditedData]=react__WEBPACK_IMPORTED_MODULE_1__.useState(editedData),[layerInstances,setLayerInstances]=react__WEBPACK_IMPORTED_MODULE_1__.useState([]);react__WEBPACK_IMPORTED_MODULE_1__.useEffect((()=>{const enumerations=[];if(resources&&enumerations.push({resources:resources}),editedData?enumerations.push({editedData:editedData}):enumerations.push({editedData:{}}),!layers)return void setLayerInstances([]);const layersList=(0,_components_Map__WEBPACK_IMPORTED_MODULE_3__.fW)(layers,enumerations);setLayerInstances(layersList)}),[layers]),react__WEBPACK_IMPORTED_MODULE_1__.useEffect((()=>{editedData&&setLayerEditedData({...layerEditedData,...editedData})}),[editedData]);const setEditedData=react__WEBPACK_IMPORTED_MODULE_1__.useCallback((data=>{null!=setProps&&setProps({editedData:{...layerEditedData,...data}})}),[setProps,layerEditedData]);return coordinateUnit&&!convert_units__WEBPACK_IMPORTED_MODULE_0___default()().possibilities().includes(coordinateUnit)&&(console.error(`Invalid coordinate unit: '${coordinateUnit}'. Valid units are: ${convert_units__WEBPACK_IMPORTED_MODULE_0___default()().possibilities()}`),coordinateUnit=void 0),react__WEBPACK_IMPORTED_MODULE_1__.createElement(_components_Map__WEBPACK_IMPORTED_MODULE_3__.Ay,_extends({id:id,layers:layerInstances,bounds:bounds,views:views,coords:coords,scale:scale,coordinateUnit:coordinateUnit,colorTables:colorTables,setEditedData:setEditedData,checkDatafileSchema:checkDatafileSchema,onMouseEvent:onMouseEvent,selection:selection,getTooltip:getTooltip,cameraPosition:cameraPosition,getCameraPosition:getCameraPosition,onRenderingProgress:onRenderingProgress,onDragStart:onDragStart,onDragEnd:onDragEnd,triggerHome:triggerHome,triggerResetMultipleWells:triggerResetMultipleWells,lights:lights,verticalScale:verticalScale},args),children)};SubsurfaceViewer.propTypes={id:prop_types__WEBPACK_IMPORTED_MODULE_4___default().string.isRequired,resources:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),layers:prop_types__WEBPACK_IMPORTED_MODULE_4___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any).isRequired),bounds:prop_types__WEBPACK_IMPORTED_MODULE_4___default().any,views:prop_types__WEBPACK_IMPORTED_MODULE_4___default().any,coords:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,multiPicking:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,pickDepth:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number}),scale:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,incrementValue:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number,widthPerUnit:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number,cssStyle:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any)}),coordinateUnit:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOf(convert_units__WEBPACK_IMPORTED_MODULE_0___default()().possibilities()),colorTables:prop_types__WEBPACK_IMPORTED_MODULE_4___default().array,editedData:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),setProps:prop_types__WEBPACK_IMPORTED_MODULE_4___default().func,checkDatafileSchema:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool},__webpack_exports__.A=SubsurfaceViewer,SubsurfaceViewer.__docgenInfo={description:"",methods:[],displayName:"SubsurfaceViewer",props:{layers:{required:!1,tsType:{name:"Array",elements:[{name:"union",raw:"| Record<string, unknown>\n| Layer\n| false\n| null\n| undefined",elements:[{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},{name:"Layer"},{name:"literal",value:"false"},{name:"null"},{name:"undefined"}]}],raw:"TLayerDefinition[]"},description:"Array of externally created layers or layer definition records or JSON strings.\nAdd '@@typedArraySupport' : true in a layer definition in order to\nuse typed arrays as inputs.",type:{name:"arrayOf",value:{name:"objectOf",value:{name:"any"}}}},setProps:{required:!1,tsType:{name:"signature",type:"function",raw:"(data: Record<string, unknown>) => void",signature:{arguments:[{type:{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},name:"data"}],return:{name:"void"}}},description:"@deprecated Used by layers to propagate state to component, eg. selected\nwells from the Wells layer. Use client code to handle layer state\ninstead.",type:{name:"func"}},id:{description:"The ID of this component, used to identify dash components\nin callbacks. The ID needs to be unique across all of the\ncomponents in an app.",type:{name:"string"},required:!0},resources:{description:'Resource dictionary made available in the DeckGL specification as an enum.\nThe values can be accessed like this: `"@@#resources.resourceId"`, where\n`resourceId` is the key in the `resources` dict. For more information,\nsee the DeckGL documentation on enums in the json spec:\nhttps://deck.gl/docs/api-reference/json/conversion-reference#enumerations-and-using-the--prefix',type:{name:"objectOf",value:{name:"any"}},required:!1},bounds:{description:"Coordinate boundary for the view defined as [left, bottom, right, top].\nIt can be either an array or a callback returning [number, number, number, number].",type:{name:"any"},required:!1},views:{description:'Views configuration for map. If not specified, all the layers will be\ndisplayed in a single 2D viewport.\nExample:\n     views = {\n         "layout": [1, 1],\n         "showLabel": false,\n         "viewports": [\n             {\n                 "id": "view_1",\n                 "name"?: "View 1"\n                 "show3D"?: false,\n                 "layerIds": ["layer-ids"],\n                 "isSync?": true,\n             }\n         ]\n     }',type:{name:"any"},required:!1},coords:{description:"Parameters for the InfoCard component",type:{name:"shape",value:{visible:{name:"bool",description:"Toggle component visibility.",required:!1},multiPicking:{name:"bool",description:"Enable or disable multi picking. Might have a performance penalty.\nSee https://deck.gl/docs/api-reference/core/deck#pickmultipleobjects",required:!1},pickDepth:{name:"number",description:"Number of objects to pick. The more objects picked, the more picking operations will be done.\nSee https://deck.gl/docs/api-reference/core/deck#pickmultipleobjects",required:!1}}},required:!1},scale:{description:"Parameters for the Distance Scale component",type:{name:"shape",value:{visible:{name:"bool",description:"Toggle component visibility.",required:!1},incrementValue:{name:"number",description:"Increment value for the scale.",required:!1},widthPerUnit:{name:"number",description:"Scale bar width in pixels per unit value.",required:!1},cssStyle:{name:"objectOf",value:{name:"any"},description:"Scale bar css style can be used for positioning.",required:!1}}},required:!1},coordinateUnit:{description:"Parameters for the Distance Scale component\nUnit for the scale ruler",type:{name:"enum",computed:!0,value:"convert().possibilities()"},required:!1},colorTables:{description:"Prop containing color table data",type:{name:"array"},required:!1},editedData:{description:"Prop containing edited data from layers",type:{name:"objectOf",value:{name:"any"}},required:!1},checkDatafileSchema:{description:"Validate JSON datafile against schema",type:{name:"bool"},required:!1}},composes:["Omit"]}},"./packages/subsurface-viewer/src/components/DistanceScale.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{q:function(){return DistanceScale}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/convert-units/lib/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(convert_units__WEBPACK_IMPORTED_MODULE_1__);const DistanceScale=({zoom:zoom=-3,incrementValue:incrementValue=100,widthPerUnit:widthPerUnit=100,style:style,scaleUnit:scaleUnit="m"})=>{if(!(zoom&&widthPerUnit&&incrementValue&&scaleUnit))return null;if(!convert_units__WEBPACK_IMPORTED_MODULE_1___default()().possibilities().includes(scaleUnit))return null;const widthInUnits=widthPerUnit/Math.pow(2,zoom),scaleValue=widthInUnits<incrementValue?Math.round(widthInUnits):(num=widthInUnits,step=incrementValue,Math.floor(num/step+.5)*step);var num,step;const convertedUnit=convert_units__WEBPACK_IMPORTED_MODULE_1___default()(scaleValue).from(scaleUnit).toBest().unit,convertedValue=convert_units__WEBPACK_IMPORTED_MODULE_1___default()(scaleValue).from(scaleUnit).toBest().val,scaleRulerStyle={width:scaleValue*Math.pow(2,zoom),height:"4px",border:"2px solid",borderTop:"none",display:"inline-block",marginLeft:"3px"};return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{style:{position:"absolute",...style}},react__WEBPACK_IMPORTED_MODULE_0__.createElement("label",{style:{...style}},convertedValue.toFixed(0),convertedUnit),react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{style:scaleRulerStyle}))};DistanceScale.__docgenInfo={description:"",methods:[],displayName:"DistanceScale",props:{zoom:{required:!1,tsType:{name:"number"},description:"",defaultValue:{value:"-3",computed:!1}},incrementValue:{required:!1,tsType:{name:"union",raw:"number | null",elements:[{name:"number"},{name:"null"}]},description:"",defaultValue:{value:"100",computed:!1}},widthPerUnit:{required:!1,tsType:{name:"union",raw:"number | null",elements:[{name:"number"},{name:"null"}]},description:"",defaultValue:{value:"100",computed:!1}},style:{required:!1,tsType:{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},description:""},scaleUnit:{required:!1,tsType:{name:"Unit"},description:"",defaultValue:{value:'"m"',computed:!1}}}}},"./packages/subsurface-viewer/src/components/InfoCard.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_mui_material__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@mui/material/Table/Table.js"),_mui_material__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/@mui/material/TableCell/TableCell.js"),_mui_material__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./node_modules/@mui/material/TableRow/TableRow.js"),_mui_material__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__("./node_modules/@mui/material/Collapse/Collapse.js"),_mui_material__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__("./node_modules/@mui/material/TableBody/TableBody.js"),_mui_material__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__("./node_modules/@mui/material/TableContainer/TableContainer.js"),_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Icon/index.js"),_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Button/index.js"),_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-icons/dist/esm/index.js"),_mui_system__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@mui/system/esm/styled.js"),d3_color__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__("./node_modules/d3-color/src/color.js");_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.I.add({arrow_drop_up:_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__.u7t,arrow_drop_down:_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__.FxC});const StyledTable=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.A)(_mui_material__WEBPACK_IMPORTED_MODULE_4__.A)({"& > *":{backgroundColor:"#ffffffcc",color:"#000000ff",border:"2px solid #ccc",padding:"0px",borderRadius:"5px",position:"absolute",bottom:0,left:0,marginLeft:"3px",marginBottom:"3px"}}),StyledTableCell=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.A)(_mui_material__WEBPACK_IMPORTED_MODULE_5__.A)({border:"none",padding:0,width:"20px"}),StyledTableRow=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.A)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.A)({"& > *":{padding:0}});function Row(props){const{layer_data:layer_data}=props,[open,setOpen]=react__WEBPACK_IMPORTED_MODULE_0__.useState(!0);return 0==layer_data.properties?.length?null:react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableCell,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_7__.$,{style:{padding:0},variant:"ghost",onClick:()=>setOpen(!open)},open?react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.I,{color:"currentColor",name:"arrow_drop_up"}):react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.I,{color:"currentColor",name:"arrow_drop_down"}))),react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.A,null," ",layer_data.layerName," ")),react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.A,{style:{paddingBottom:0,paddingTop:0},colSpan:2},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_8__.A,{in:open,timeout:"auto",unmountOnExit:!0},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_4__.A,{size:"small","aria-label":"properties"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_9__.A,null,layer_data.properties?.map((propertyRow=>{return react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,{key:propertyRow.name},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.A,{style:{border:"none",paddingLeft:10,paddingRight:10}},propertyRow.color&&react__WEBPACK_IMPORTED_MODULE_0__.createElement("span",{style:{color:(0,d3_color__WEBPACK_IMPORTED_MODULE_10__.Qh)(...propertyRow.color).toString()}},"⬤"),propertyRow.name),react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.A,{style:{border:"none",textAlign:"right"}},"number"==typeof propertyRow.value?(num=propertyRow.value,parseFloat(num.toExponential(Math.max(1,2+Math.log10(Math.abs(num)))))):propertyRow.value));var num}))))))))}const InfoCard=props=>{const[infoCardData,setInfoCardData]=react__WEBPACK_IMPORTED_MODULE_0__.useState(null);return react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{if(0===props.pickInfos.length)return void setInfoCardData(null);const topObject=props.pickInfos[0];if(void 0===topObject.coordinate||topObject.coordinate.length<2)return;const xy_properties=[];xy_properties.push({name:"x",value:Number(topObject.coordinate[0]).toFixed(2).toString()+" m"}),xy_properties.push({name:"y",value:Number(topObject.coordinate[1]).toFixed(2).toString()+" m"});const info_card_data=[];info_card_data.push({layerName:"Position",properties:xy_properties}),props.pickInfos.forEach((info=>{const layer_properties=info.properties,layer_name=info.layer?.props?.name,zValue=info.propertyValue;if(void 0!==zValue){const property=xy_properties.find((item=>item.name===layer_name));property?property.value=zValue:xy_properties.push({name:layer_name,value:zValue})}const layer=info_card_data.find((item=>item.layerName===layer_name));layer?layer_properties?.forEach((layer_prop=>{const property=layer.properties?.find((item=>item.name===layer_prop.name));property?property.value=layer_prop.value:layer.properties?.push(layer_prop)})):info_card_data.push({layerName:layer_name||"unknown-layer",properties:layer_properties})})),setInfoCardData(info_card_data)}),[props.pickInfos]),infoCardData&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_11__.A,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTable,{"aria-label":"info-card"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_9__.A,null,infoCardData.map((card_data=>card_data.properties&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(Row,{key:card_data.layerName,layer_data:card_data}))))))};__webpack_exports__.A=InfoCard,InfoCard.__docgenInfo={description:"",methods:[],displayName:"InfoCard",props:{pickInfos:{required:!0,tsType:{name:"Array",elements:[{name:"LayerPickInfo"}],raw:"LayerPickInfo[]"},description:"List of JSON object describing picking information of layers\nthat are under the cursor."}}}},"./packages/subsurface-viewer/src/components/Map.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{fW:function(){return createLayers},Ay:function(){return components_Map},kS:function(){return useHoverInfo}});var views_namespaceObject={};__webpack_require__.r(views_namespaceObject),__webpack_require__.d(views_namespaceObject,{IntersectionView:function(){return IntersectionView}});var react=__webpack_require__("./node_modules/react/index.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),json_converter=__webpack_require__("./node_modules/@deck.gl/json/dist/json-converter.js"),json_configuration=__webpack_require__("./node_modules/@deck.gl/json/dist/json-configuration.js"),deckgl=__webpack_require__("./node_modules/@deck.gl/react/dist/deckgl.js"),ambient_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/ambient-light.js"),camera_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/camera-light.js"),point_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/point-light.js"),directional_light=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/directional-light.js"),lighting_effect=__webpack_require__("./node_modules/@deck.gl/core/dist/effects/lighting/lighting-effect.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),orbit_view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/orbit-view.js"),orbit_controller=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/orbit-controller.js"),orthographic_view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/orthographic-view.js"),orthographic_controller=__webpack_require__("./node_modules/@deck.gl/core/dist/controllers/orthographic-controller.js"),line_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/line-layer/line-layer.js"),matrix4=__webpack_require__("./node_modules/@math.gl/core/dist/classes/matrix4.js"),dist=__webpack_require__("./node_modules/@math.gl/web-mercator/dist/index.js"),color_tables_dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),wsc_common_dist=__webpack_require__("./packages/wsc-common/dist/index.js"),src_layers=__webpack_require__("./packages/subsurface-viewer/src/layers/index.ts"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");const isEmpty=box=>{if(null==box)return!0;const xmin=box[0],ymin=box[1],xmax=box[2],ymax=box[3];return!(xmax>xmin&&ymax>ymin)},BoundingBox3D_boxCenter=box=>{const xmin=box[0],ymin=box[1],zmin=box[2];return[xmin+.5*(box[3]-xmin),ymin+.5*(box[4]-ymin),zmin+.5*(box[5]-zmin)]},BoundingBox3D_isEmpty=box=>{if(null==box)return!0;const xmin=box[0],ymin=box[1],zmin=box[2],xmax=box[3],ymax=box[4],zmax=box[5];return!(xmax>xmin&&ymax>ymin&&zmax!=zmin)};var first_person_view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/first-person-view.js"),map_view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/map-view.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),aggregation_layers_dist=__webpack_require__("./node_modules/@deck.gl/aggregation-layers/dist/index.js"),geo_layers_dist=__webpack_require__("./node_modules/@deck.gl/geo-layers/dist/index.js"),layers_dist=__webpack_require__("./node_modules/@deck.gl/layers/dist/index.js"),mesh_layers_dist=__webpack_require__("./node_modules/@deck.gl/mesh-layers/dist/index.js"),register_loaders=__webpack_require__("./node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js"),view=__webpack_require__("./node_modules/@deck.gl/core/dist/views/view.js"),intersectionViewport=__webpack_require__("./packages/subsurface-viewer/src/viewports/intersectionViewport.ts");class IntersectionView extends view.A{static displayName="IntersectionView";constructor(props){super({...props,controller:!1,viewState:{target:[275,0,-500]}})}get ViewportType(){return intersectionViewport.A}get ControllerType(){throw new Error("Method not implemented.")}}(0,register_loaders.mk)([]);var utils_configuration={classes:Object.assign({FirstPersonView:first_person_view.A,MapView:map_view.A,OrbitView:orbit_view.A,OrthographicView:orthographic_view.A,...views_namespaceObject},layers_dist,aggregation_layers_dist,geo_layers_dist,mesh_layers_dist,src_layers),functions:{},enumerations:{COORDINATE_SYSTEM:constants.rf},constants:{}};const log2=Math.log2||function ieLog2(x){return Math.log(x)*Math.LOG2E};function fitBounds({width:width,height:height,bounds:bounds,minExtent:minExtent=0,maxZoom:maxZoom=24,padding:padding=0,offset:offset=[0,0]}){if(Number.isFinite(padding)){padding={top:padding,bottom:padding,left:padding,right:padding}}else console.assert(Number.isFinite(padding.top)&&Number.isFinite(padding.bottom)&&Number.isFinite(padding.left)&&Number.isFinite(padding.right));const[west,south]=[bounds[0],bounds[1]],[east,north]=[bounds[2],bounds[3]],nw=[west,north],se=[east,south],size=[Math.max(Math.abs(se[0]-nw[0]),minExtent),Math.max(Math.abs(se[1]-nw[1]),minExtent)],targetSize=[width-padding.left-padding.right-2*Math.abs(offset[0]),height-padding.top-padding.bottom-2*Math.abs(offset[1])],scaleX=targetSize[0]/size[0],scaleY=targetSize[1]/size[1],offsetX=(padding.right-padding.left)/2/scaleX,offsetY=(padding.bottom-padding.top)/2/scaleY,centerLngLat=[(se[0]+nw[0])/2+offsetX,(se[1]+nw[1])/2+offsetY];let zoom=Math.min(maxZoom,log2(Math.abs(Math.min(scaleX,scaleY))));return Number.isFinite(zoom)||(zoom=0),{x:centerLngLat[0],y:centerLngLat[1],zoom:zoom}}var DistanceScale=__webpack_require__("./packages/subsurface-viewer/src/components/DistanceScale.tsx"),InfoCard=__webpack_require__("./packages/subsurface-viewer/src/components/InfoCard.tsx"),CircularProgress=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Progress/Circular/CircularProgress.js");const StatusIndicator=({progress:progress,label:label})=>("boolean"==typeof progress&&(progress=progress?100:0),progress>=100?null:react.createElement("div",null,react.createElement(CircularProgress.P,{size:48,value:progress,variant:"determinate"}),react.createElement("br",null),label));var components_StatusIndicator=StatusIndicator;StatusIndicator.__docgenInfo={description:"",methods:[],displayName:"StatusIndicator",props:{progress:{required:!0,tsType:{name:"union",raw:"number | boolean",elements:[{name:"number"},{name:"boolean"}]},description:""},label:{required:!0,tsType:{name:"string"},description:""}}};var camera=__webpack_require__("./packages/subsurface-viewer/src/utils/camera.ts"),utils_event=__webpack_require__("./packages/subsurface-viewer/src/utils/event.ts");var esm=__webpack_require__("./node_modules/merge-refs/dist/esm/index.js");function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}const minZoom3D=-12,maxZoom3D=12,minZoom2D=-12,maxZoom2D=12,DEFAULT_VIEWS={layout:[1,1],showLabel:!1,marginPixels:0,viewports:[{id:"main-view",show3D:!1,layerIds:[]}]};function mapBoundingBoxReducer(mapBoundingBox,action){const union=((box1,box2,defaultBox=[0,0,0,1,1,1])=>void 0===box1?box2??defaultBox:void 0===box2?box1??defaultBox:[Math.min(box1[0],box2[0]),Math.min(box1[1],box2[1]),Math.min(box1[2],box2[2]),Math.max(box1[3],box2[3]),Math.max(box1[4],box2[4]),Math.max(box1[5],box2[5])])(mapBoundingBox,action.layerBoundingBox);return(0,lodash.isEqual)(union,mapBoundingBox)?mapBoundingBox:union}function useHoverInfo(){const[hoverInfo,setHoverInfo]=(0,react.useState)([]);return[hoverInfo,(0,react.useCallback)((pickEvent=>{setHoverInfo(pickEvent.infos)}),[])]}function defaultTooltip(info){if(info?.logName)return info?.logName;if("drawing-layer"===info.layer?.id)return info.propertyValue?.toFixed(2);const feat=info.object;return feat?.properties?.name}const Map=({id:id,layers:layers,bounds:bounds,cameraPosition:cameraPosition,triggerHome:triggerHome,views:views=DEFAULT_VIEWS,coords:coords={visible:!0,multiPicking:!0,pickDepth:10},scale:scale={visible:!0,cssStyle:{top:10,left:10}},coordinateUnit:coordinateUnit="m",colorTables:colorTables=color_tables_dist.$d,setEditedData:setEditedData,checkDatafileSchema:checkDatafileSchema=!1,onMouseEvent:onMouseEvent,selection:selection,children:children,getTooltip:getTooltip=defaultTooltip,getCameraPosition:getCameraPosition,onRenderingProgress:onRenderingProgress,onDragStart:onDragStart,onDragEnd:onDragEnd,lights:lights,triggerResetMultipleWells:triggerResetMultipleWells,verticalScale:verticalScale,innerRef:innerRef})=>{const deckRef=react.useRef(null),[applyViewController,forceUpdate]=react.useReducer((x=>x+1),0),viewController=(0,react.useMemo)((()=>new ViewController(forceUpdate)),[]),[deckSize,setDeckSize]=(0,react.useState)({width:0,height:0}),onResize=(0,react.useCallback)((size=>{size.width>0&&size.height>0&&setDeckSize((prevSize=>prevSize?.width!==size.width||prevSize?.height!==size.height?size:prevSize))}),[]),[dataBoundingBox3d,dispatchBoundingBox]=react.useReducer(mapBoundingBoxReducer,void 0),viewportVerticalScale=(viewports=views?.viewports,react.useMemo((()=>viewports?viewports.find((item=>!!item.verticalScale))?.verticalScale:1),[viewports]));var viewports;const{factor:zReScale,elementRef:zScaleRef}=(0,utils_event.f)(),{shiftHeld:shiftHeld,divRef:shiftHeldRef}=(0,utils_event.h)(),overrideVerticalScaling=verticalScale??viewportVerticalScale,divRef=(0,esm.A)(overrideVerticalScaling?void 0:zScaleRef,shiftHeldRef,innerRef),zScale=verticalScale??viewportVerticalScale??zReScale,viewPortMargins=react.useMemo((()=>{if(!layers?.length)return{left:0,right:0,top:0,bottom:0};const axes2DLayer=layers?.find((e=>e?.constructor===src_layers.Axes2DLayer)),axes2DProps=axes2DLayer?.props;return{left:axes2DProps?.isLeftRuler?axes2DProps.marginH:0,right:axes2DProps?.isRightRuler?axes2DProps.marginH:0,top:axes2DProps?.isTopRuler?axes2DProps.marginV:0,bottom:axes2DProps?.isBottomRuler?axes2DProps.marginV:0}}),[layers]);(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(layers){const wellslayer=(0,layerTools.eo)(layers,src_layers.WellsLayer.name)?.[0];wellslayer?.setSelection(selection?.well,selection?.selection)}}),[selection]);const[multipleWells,setMultipleWells]=(0,react.useState)([]),[selectedWell,setSelectedWell]=(0,react.useState)("");(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(layers){const wellslayer=(0,layerTools.M1)(layers,"WellsLayer",selectedWell)?.[0];wellslayer?.setMultiSelection(multipleWells)}}),[multipleWells,selectedWell]),(0,react.useEffect)((()=>{void 0!==triggerResetMultipleWells&&setMultipleWells([])}),[triggerResetMultipleWells]);const getPickingInfos=(0,react.useCallback)(((pickInfo,event)=>{if(coords?.multiPicking&&pickInfo.layer?.context.deck){const pickInfos=pickInfo.layer.context.deck.pickMultipleObjects({x:event.offsetCenter.x,y:event.offsetCenter.y,depth:coords.pickDepth?coords.pickDepth:void 0,unproject3D:!0});return pickInfos.forEach((item=>{if(item.properties){let unit=item.sourceLayer?.props.data?.unit;null==unit&&(unit=" "),item.properties.forEach((element=>{(element.name.includes("MD")||element.name.includes("TVD"))&&(element.value=Number(element.value).toFixed(2).toString()+" "+unit)}))}})),pickInfos}return[pickInfo]}),[coords?.multiPicking,coords?.pickDepth]),callOnMouseEvent=(0,react.useCallback)(((type,infos,event)=>{if(event.leftButton&&2==event.tapCount&&infos.length>=1&&infos[0].coordinate&&viewController.setScaledTarget(infos[0].coordinate),!onMouseEvent)return;const ev=function handleMouseEvent(type,infos,event){const ev={type:type,infos:infos};"click"===ev.type&&event.rightButton&&(ev.type="contextmenu");for(const info of infos)if(info.coordinate&&(ev.x=info.coordinate[0],ev.y=info.coordinate[1]),info.layer&&"wells-layer"===info.layer.id){{const feat=info.object,properties=feat?.properties;properties&&(ev.wellname=properties.name,ev.wellcolor=properties.color)}if(ev.wellname||info.object&&(ev.wellname=info.object.header?.well),info.properties)for(const property of info.properties){ev.wellcolor||(ev.wellcolor=property.color);let propname=property.name;if(propname){const sep=propname.indexOf(" ");sep>=0&&(ev.wellname||(ev.wellname=propname.substring(sep+1)),propname=propname.substring(0,sep))}const names_tvd=["TVD","TVDSS","DVER","TVD_MSL"];if(["DEPTH","DEPT","MD","TDEP","MD_RKB"].find((name=>name==propname))?ev.md=parseFloat(property.value):names_tvd.find((name=>name==propname))&&(ev.tvd=parseFloat(property.value)),void 0!==ev.md&&void 0!==ev.tvd&&void 0!==ev.wellname)break}break}return ev}(type,infos,event);onMouseEvent(ev)}),[onMouseEvent,viewController]),[hoverInfo,setHoverInfo]=(0,react.useState)([]),onHover=(0,react.useCallback)(((pickInfo,event)=>{const infos=getPickingInfos(pickInfo,event);setHoverInfo(infos),callOnMouseEvent?.("hover",infos,event)}),[callOnMouseEvent,getPickingInfos]),onClick=(0,react.useCallback)(((pickInfo,event)=>{const infos=getPickingInfos(pickInfo,event);callOnMouseEvent?.("click",infos,event)}),[callOnMouseEvent,getPickingInfos]),deckGLLayers=react.useMemo((()=>{if(!layers)return[];if(0===layers.length){const dummy_layer=new line_layer.A({id:"webviz_internal_dummy_layer",visible:!1});layers.push(dummy_layer)}const m=(0,layerTools.d8)(zScale);return layers.map((item=>item?.constructor.name===src_layers.NorthArrow3DLayer.name?item:item.clone({reportBoundingBox:dispatchBoundingBox,modelMatrix:m})))}),[layers,zScale]),[loadingProgress,setLoadingProgress]=(0,react.useState)(0),onAfterRender=(0,react.useCallback)((()=>{if(deckGLLayers){let progress=100;if(!(1==deckGLLayers.length&&"webviz_internal_dummy_layer"===deckGLLayers[0].id)){const visibleLayers=deckGLLayers.filter((layer=>layer.props.visible)),loaded=visibleLayers?.filter((layer=>layer?.isLoaded)).length;progress=Math.ceil(100*loaded/visibleLayers?.length)}setLoadingProgress(progress),onRenderingProgress&&onRenderingProgress(progress)}}),[deckGLLayers,onRenderingProgress]),[errorText,setErrorText]=(0,react.useState)();(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(checkDatafileSchema&&layers&&100===loadingProgress)try{(0,wsc_common_dist.Dd)(layers),colorTables&&(0,wsc_common_dist.Vr)(colorTables)}catch(e){setErrorText(String(e))}else setErrorText(void 0)}),[checkDatafileSchema,colorTables,deckRef?.current?.deck?.props.layers,loadingProgress]);const layerFilter=(0,react.useCallback)((args=>{if(!views?.viewports||!views?.layout)return!0;const cur_view=views.viewports.find((({id:id})=>args.viewport.id&&id===args.viewport.id));if(cur_view?.layerIds&&cur_view.layerIds.length>0){return cur_view.layerIds.some((layer_id=>layer_id===args.layer.id))}return!0}),[views]),onViewStateChange=(0,react.useCallback)((({viewId:viewId,viewState:viewState})=>{viewController.onViewStateChange(viewId,viewState),getCameraPosition&&getCameraPosition(viewState)}),[getCameraPosition,viewController]),effects=function parseLights(lights){if(!lights)return;const effects=[],lightsObj={};lights.ambientLight&&(lightsObj.AmbientLight=new ambient_light.$({intensity:lights.ambientLight.intensity,color:lights.ambientLight.color??[255,255,255]})),lights.headLight&&(lightsObj.HeadLight=new camera_light.A({intensity:lights.headLight.intensity,color:lights.headLight.color??[255,255,255]})),lights.pointLights?.forEach(((light,index)=>{lightsObj[`PointLight_${index}`]=new point_light.H({...light,color:light.color??[255,255,255]})})),lights.directionalLights?.forEach(((light,index)=>{lightsObj[`DirectionalLight_${index}`]=new directional_light.Z({...light,color:light.color??[255,255,255]})}));const lightingEffect=new lighting_effect.A(lightsObj);return effects.push(lightingEffect),effects}(lights)??[],[deckGlViews,deckGlViewState]=(0,react.useMemo)((()=>{const state={triggerHome:triggerHome,camera:cameraPosition,bounds:bounds,boundingBox3d:dataBoundingBox3d,viewPortMargins:viewPortMargins,deckSize:deckSize,zScale:zScale};return viewController.getViews(views,state)}),[triggerHome,cameraPosition,bounds,dataBoundingBox3d,viewPortMargins,deckSize,views,zScale,applyViewController,viewController]),lateralZoom=(0,camera.Qh)(deckGlViewState);return!deckGlViews||(0,lodash.isEmpty)(deckGlViews)||(0,lodash.isEmpty)(deckGLLayers)?null:react.createElement("div",{ref:divRef,onContextMenu:event=>event.preventDefault()},react.createElement(deckgl.A,{id:id,viewState:deckGlViewState,views:deckGlViews,layerFilter:layerFilter,layers:deckGLLayers,userData:{setEditedData:updated_prop=>{if(setSelectedWell(updated_prop.selectedWell),Object.keys(updated_prop).includes("selectedWell"))if(shiftHeld)if(multipleWells.includes(updated_prop.selectedWell)){const temp=multipleWells.filter((item=>item!==updated_prop.selectedWell));setMultipleWells(temp)}else{const temp=multipleWells.concat(updated_prop.selectedWell);setMultipleWells(temp)}else setMultipleWells([]);setEditedData?.(updated_prop)},colorTables:colorTables},getCursor:({isDragging:isDragging})=>isDragging?"grabbing":"default",getTooltip:getTooltip,ref:deckRef,onViewStateChange:onViewStateChange,onHover:onHover,onClick:onClick,onAfterRender:onAfterRender,effects:effects,onDragStart:onDragStart,onDragEnd:onDragEnd,onResize:onResize},children),scale?.visible?react.createElement(DistanceScale.q,_extends({},scale,{zoom:lateralZoom,scaleUnit:coordinateUnit,style:scale.cssStyle??{}})):null,!onRenderingProgress&&loadingProgress<100&&react.createElement("div",{style:{display:"flex",alignItems:"flex-end",justifyContent:"right",position:"absolute",height:"10%",width:"10%",bottom:"10px",right:"10px",zIndex:200}},react.createElement(components_StatusIndicator,{progress:loadingProgress,label:"Loading assets..."})),coords?.visible&&react.createElement(InfoCard.A,{pickInfos:hoverInfo}),errorText&&react.createElement("pre",{style:{flex:"0, 0",color:"rgb(255, 64, 64)",backgroundColor:"rgb(255, 255, 192)"}},errorText))};var components_Map=Map;function createLayers(layers,enums=void 0){const configuration=createConfiguration(enums),filtered_layers=layers.filter((value=>!(0,lodash.isEmpty)(value))),layersList=new Array(filtered_layers.length),jsonLayerIndices=[],jsonLayerDefs=[];filtered_layers.forEach(((layer,index)=>{layer instanceof lib_layer.A?layersList[index]=layer:layer["@@typedArraySupport"]?layersList[index]=function createLayer(layerData,configuration){const typeKey=configuration.typeKey,classes=configuration.classes;if(layerData[typeKey]){const type=layerData[typeKey];if(type in classes){const Class=classes[type],props={...layerData};return delete props[typeKey],new Class(props)}}return null}(layer,configuration):(jsonLayerDefs.push(layer),jsonLayerIndices.push(index))}));const jsonLayers=function jsonToObject(data,enums){if(!data)return[];const configuration=createConfiguration(enums),jsonConverter=new json_converter.A({configuration:configuration}),filtered_data=data.filter((value=>!(0,lodash.isEmpty)(value)));return jsonConverter.convert(filtered_data)}(jsonLayerDefs,enums);return jsonLayers.forEach(((layer,index)=>{const layerIndex=jsonLayerIndices[index];layersList[layerIndex]=layer})),layersList.filter((value=>!(0,lodash.isEmpty)(value)))}function createConfiguration(enums=void 0){const configuration=new json_configuration.A(utils_configuration);return enums?.forEach((enumeration=>{enumeration&&configuration.merge({enumerations:{...enumeration}})})),configuration}class ViewController{derivedState_={scaledCameraClone:void 0,eventTarget:void 0,readyForInteraction:!1,viewStateChanged:!1};state_={triggerHome:void 0,camera:void 0,bounds:void 0,boundingBox3d:void 0,deckSize:{width:0,height:0},zScale:1,viewPortMargins:{left:0,right:0,top:0,bottom:0},...this.derivedState_};views_=void 0;result_={views:[],viewState:{}};constructor(rerender){this.rerender_=rerender}setScaledTarget=target=>{this.derivedState_.eventTarget=[target[0],target[1],target[2]],this.rerender_()};getViews=(views,state)=>{const fullState=this.consolidateState(state),newViews=this.getDeckGlViews(views,fullState),newViewState=this.getDeckGlViewState(views,fullState);return(0,lodash.isEmpty)(newViewState)||(this.state_=fullState),this.views_=views,this.result_.views=newViews,this.result_.viewState=newViewState,[newViews,newViewState]};consolidateState=state=>{const fullState={...state,...this.derivedState_};return fullState.camera==this.state_.camera&&fullState.scaledCameraClone||(fullState.scaledCameraClone=fullState.camera?{...(0,lodash.cloneDeep)(fullState.camera),scale:1}:void 0),fullState};getDeckGlViews=(views,state)=>views!=this.views_||state.deckSize!=this.state_.deckSize?function buildDeckGlViews(views,size){const isOk=areViewsValid(views,size);if(!views||!isOk)return[new orthographic_view.A({id:"main",controller:null,x:"0%",y:"0%",width:"100%",height:"100%",flipY:!1,far:99999,near:-99999})];const[nY,nX]=views.layout;if(1===nX&&1===nY)return[newView(views.viewports[0],0,0,"99.5%","99.5%")];const result=[],w=99.5/nX,h=99.5/nY,marginPixels=views.marginPixels??0,marginHorPercentage=marginPixels/(w*size.width)*1e4,marginVerPercentage=marginPixels/(h*size.height)*1e4;let yPos=0;for(let y=1;y<=nY;y++){let xPos=0;for(let x=1;x<=nX;x++){if(result.length>=views.viewports.length)return result;const currentViewport=views.viewports[result.length],viewX=xPos+marginHorPercentage/nX+"%",viewY=yPos+marginVerPercentage/nY+"%",viewWidth=w*(1-marginHorPercentage/100*2)+"%",viewHeight=h*(1-marginVerPercentage/100*2)+"%";result.push(newView(currentViewport,viewX,viewY,viewWidth,viewHeight)),xPos+=w}yPos+=h}return result}(views,state.deckSize):this.result_.views;getDeckGlViewState=(views,state)=>{const viewsChanged=views!=this.views_,triggerHome=state.triggerHome!==this.state_.triggerHome,updateTarget=(viewsChanged||state.eventTarget!==this.state_.eventTarget)&&null!=state.eventTarget;state.camera!=this.state_.camera&&(this.state_.zScale=1);const updateZScale=viewsChanged||state.zScale!==this.state_?.zScale||triggerHome,updateViewState=viewsChanged||triggerHome||state.camera!=this.state_.camera||state.bounds!=this.state_.bounds||!state.viewStateChanged&&(state.boundingBox3d!==this.state_.boundingBox3d||state.deckSize!=this.state_.deckSize),needUpdate=updateZScale||updateTarget||updateViewState,isCacheEmpty=(0,lodash.isEmpty)(this.result_.viewState);if(!isCacheEmpty&&!needUpdate)return this.result_.viewState;const prevViewState=this.result_.viewState;let viewState=prevViewState;if((updateViewState||isCacheEmpty)&&(viewState=function buildDeckGlViewStates(views,viewPortMargins,scaledCamera,boundingBox,zScale,bounds,size){const isOk=areViewsValid(views,size);if(!views||!isOk)return{};const[nY,nX]=views.layout;if(1===nX&&1===nY){const viewState=computeViewState(views.viewports[0],scaledCamera,boundingBox,zScale,bounds,viewPortMargins,views,size);return{[views.viewports[0].id]:viewState}}let result={};for(let y=1;y<=nY;y++)for(let x=1;x<=nX;x++){const resultLength=Object.keys(result).length;if(resultLength>=views.viewports.length)return result;const currentViewport=views.viewports[resultLength],currentViewState=computeViewState(currentViewport,scaledCamera,boundingBox,zScale,bounds,viewPortMargins,views,size);currentViewState&&(result={...result,[currentViewport.id]:currentViewState})}return result}(views,state.viewPortMargins,state.scaledCameraClone,state.boundingBox3d,state.zScale,state.bounds,state.deckSize),this.derivedState_.readyForInteraction=function canCameraBeDefined(camera,boundingBox,bounds,size){if(isCameraDefined(camera))return!0;return size.height>0&&size.width>0&&(function cameraDefinesBoundingBox(camera){return Array.isArray(camera?.zoom)&&!BoundingBox3D_isEmpty(camera.zoom)}(camera)||!BoundingBox3D_isEmpty(boundingBox)||!isEmpty("function"==typeof bounds?bounds():bounds))}(state.scaledCameraClone,state.boundingBox3d,state.bounds,state.deckSize),this.derivedState_.viewStateChanged=!1),(0,lodash.isEmpty)(viewState))return viewState;const viewStateKeys=Object.keys(viewState);if(updateTarget&&this.derivedState_.eventTarget&&1===viewStateKeys?.length&&(viewState===prevViewState&&(viewState=(0,lodash.cloneDeep)(prevViewState)),viewState[viewStateKeys[0]].target=this.derivedState_.eventTarget,viewState[viewStateKeys[0]].transitionDuration=1e3,this.derivedState_.eventTarget=void 0),updateZScale){viewState===prevViewState&&(viewState=(0,lodash.cloneDeep)(prevViewState));const targetScale=state.zScale/(triggerHome?state.zScale:this.state_.zScale);for(const key in viewState)viewState[key].target&&applyZScale(viewState[key].target,targetScale)}return viewState};onViewStateChange=(viewId,viewState)=>{if(!this.derivedState_.readyForInteraction)return;const viewports=this.views_?.viewports??[];2===viewState.target?.length&&viewState.target.push(this.result_.viewState[viewId].target?.[2]??1);const isSyncIds=viewports.filter((item=>item.isSync)).map((item=>item.id));if(isSyncIds?.includes(viewId)){const viewStateTable=this.views_?.viewports.filter((item=>item.isSync)).map((item=>[item.id,viewState])),tempViewStates=Object.fromEntries(viewStateTable??[]);this.result_.viewState={...this.result_.viewState,...tempViewStates}}else this.result_.viewState={...this.result_.viewState,[viewId]:viewState};this.derivedState_.viewStateChanged=!0,this.rerender_()}}function getViewStateFromBounds(viewPortMargins,bounds_accessor,target,views,viewPort,size){const bounds="function"==typeof bounds_accessor?bounds_accessor():bounds_accessor;let w=bounds[2]-bounds[0],h=bounds[3]-bounds[1];const z=target[2],fb=fitBounds({width:w,height:h,bounds:bounds});let fb_target=[fb.x,fb.y,z],fb_zoom=fb.zoom;if(size.width>0&&size.height>0){const w_bounds=w,h_bounds=h,ml=viewPortMargins.left,mr=viewPortMargins.right,mb=viewPortMargins.bottom,mt=viewPortMargins.top,marginH=(ml>0?ml:0)+(mr>0?mr:0),marginV=(mb>0?mb:0)+(mt>0?mt:0);if(w=size.width-marginH,h=size.height-marginV,views?.layout){const[nY,nX]=views.layout;if(1!==nX||1!==nY){const mPixels=views?.marginPixels??0,w_=99.5/nX,h_=99.5/nY,marginHorPercentage=mPixels/(w_*size.width)*1e4,marginVerPercentage=mPixels/(h_*size.height)*1e4;w=w_/100*size.width*(1-marginHorPercentage/100*2)-marginH,h=h_/100*size.height*(1-marginVerPercentage/100*2)-marginV}}const m_pr_pixel=h_bounds/w_bounds>h/w?h_bounds/h:w_bounds/w;let translate_x=0;ml>0&&0===mr?translate_x=.5*ml*m_pr_pixel:0===ml&&mr>0&&(translate_x=-.5*mr*m_pr_pixel);let translate_y=0;mb>0&&0===mt?translate_y=.5*mb*m_pr_pixel:0===mb&&mt>0&&(translate_y=-.5*mt*m_pr_pixel);const fb=fitBounds({width:w,height:h,bounds:bounds});fb_target=[fb.x-translate_x,fb.y-translate_y,z],fb_zoom=fb.zoom}const max2DZoom=Math.max(bounds[0],bounds[1])>99999?3:maxZoom2D;return{target:viewPort.target??fb_target,zoom:(0,camera.IX)(viewPort,fb_zoom),rotationX:90,rotationOrbit:0,minZoom:viewPort.show3D?minZoom3D:minZoom2D,maxZoom:viewPort.show3D?maxZoom3D:max2DZoom}}function areViewsValid(views,size){return!!(null!=views?.viewports&&null!=views?.layout&&views?.layout?.[0]&&views?.layout?.[1]&&size.width&&size.height)}function newView(viewport,x,y,width,height){const near=viewport.show3D?.1:-9999,[ViewType,Controller]=function getViewType(viewport){return viewport.show3D?[orbit_view.A,orbit_controller.A]:["intersection_view"===viewport.id?IntersectionView:orthographic_view.A,orthographic_controller.A]}(viewport);return new ViewType({id:viewport.id,controller:{type:Controller,doubleClickZoom:!1},x:x,y:y,width:width,height:height,flipY:!1,far:9999,near:near})}function cameraHasZoom(camera){const zoom=camera?.zoom,isNumber="number"==typeof zoom&&!Number.isNaN(zoom),isXy=Array.isArray(zoom)&&2==zoom.length;return isNumber||isXy}function cameraHasTarget(camera){return Array.isArray(camera?.target)&&camera.target.length>=2&&camera.target.length<=3}function isCameraDefined(camera){return cameraHasZoom(camera)&&cameraHasTarget(camera)}function applyZScale(target,zScale){target?.[2]&&(target[2]=target[2]*zScale)}function updateViewState(camera,boundingBox,zScale,size,is3D=!0){return isCameraDefined(camera)?(is3D&&applyZScale(camera.target,zScale),camera):(Array.isArray(camera.zoom)&&!BoundingBox3D_isEmpty(camera.zoom)&&(boundingBox=camera.zoom),is3D||(boundingBox[2]=0,boundingBox[5]=0),cameraHasZoom(camera)||(camera.zoom=function computeCameraZoom(camera,boundingBox,size,fovy=50){const DEGREES_TO_RADIANS=Math.PI/180,RADIANS_TO_DEGREES=180/Math.PI,fD=(0,dist.wZ)(fovy),angle_ver=25*DEGREES_TO_RADIANS,r=size.height/2/Math.sin(angle_ver)*Math.cos(angle_ver),angle_hor=2*Math.atan(size.width/2/r)*RADIANS_TO_DEGREES/2*DEGREES_TO_RADIANS,fwX=fD*Math.tan(angle_hor),fwY=fD*Math.tan(angle_ver),m=new matrix4.k([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);m.rotateX(camera.rotationX*DEGREES_TO_RADIANS),m.rotateZ(camera.rotationOrbit*DEGREES_TO_RADIANS);const xMin=boundingBox[0],yMin=boundingBox[1],zMin=boundingBox[2],xMax=boundingBox[3],yMax=boundingBox[4],zMax=boundingBox[5],target=[xMin+(xMax-xMin)/2,yMin+(yMax-yMin)/2,zMin+(zMax-zMin)/2],points=[[xMin,yMin,zMin],[xMin,yMax,zMin],[xMax,yMax,zMin],[xMax,yMin,zMin],[xMin,yMin,zMax],[xMin,yMax,zMax],[xMax,yMax,zMax],[xMax,yMin,zMax]];let zoom=999;for(const point of points){const x_=(point[0]-target[0])/size.height,y_=(point[1]-target[1])/size.height,z_=(point[2]-target[2])/size.height,[x,y,z]=m.transformAsVector([x_,y_,z_]);if(y>=0)continue;let y_new=fwX/(Math.abs(x)/y-fwX/fD);const zoom_x=Math.log2(y_new/y);y_new=fwY/(Math.abs(z)/y-fwY/fD);const zoom_z=Math.log2(y_new/y);zoom=zoom_x<zoom?zoom_x:zoom,zoom=zoom_z<zoom?zoom_z:zoom}return zoom}(camera,boundingBox,size)),cameraHasTarget(camera)||(camera.target=BoundingBox3D_boxCenter(boundingBox),is3D&&applyZScale(camera.target,zScale)),camera.minZoom=camera.minZoom??minZoom3D,camera.maxZoom=camera.maxZoom??maxZoom3D,camera)}function computeViewState(viewPort,scaledCamera,boundingBox,zScale,bounds,viewportMargins,views,size){const isCameraPositionDefined=null!=scaledCamera,isBoundsDefined=bounds&&!isEmpty("function"==typeof bounds?bounds():bounds);if(boundingBox&&!BoundingBox3D_isEmpty(boundingBox)||(boundingBox=[-1,-1,-1,1,1,1]),viewPort.show3D){if(isCameraPositionDefined)return updateViewState(scaledCamera,boundingBox,zScale/(scaledCamera.scale||1),size);if(isBoundsDefined){return getViewStateFromBounds(viewportMargins,bounds,BoundingBox3D_boxCenter(boundingBox),views,viewPort,size)}return updateViewState({target:void 0,zoom:NaN,rotationX:45,rotationOrbit:0},boundingBox,zScale,size)}{if(isCameraPositionDefined)return updateViewState(scaledCamera,boundingBox,zScale,size,!1);const centerOfData=BoundingBox3D_boxCenter(boundingBox);return centerOfData[2]=0,getViewStateFromBounds(viewportMargins,isBoundsDefined?bounds:[boundingBox[0],boundingBox[1],boundingBox[3],boundingBox[4]],centerOfData,views,viewPort,size)}}Map.__docgenInfo={description:"",methods:[],displayName:"Map",props:{id:{required:!0,tsType:{name:"string"},description:"The ID of this component, used to identify dash components\nin callbacks. The ID needs to be unique across all of the\ncomponents in an app."},resources:{required:!1,tsType:{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},description:'Resource dictionary made available in the DeckGL specification as an enum.\nThe values can be accessed like this: `"@@#resources.resourceId"`, where\n`resourceId` is the key in the `resources` dict. For more information,\nsee the DeckGL documentation on enums in the json spec:\nhttps://deck.gl/docs/api-reference/json/conversion-reference#enumerations-and-using-the--prefix'},layers:{required:!1,tsType:{name:"LayersList"},description:""},bounds:{required:!1,tsType:{name:"union",raw:"BoundingBox2D | BoundsAccessor",elements:[{name:"tuple",raw:"[number, number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"},{name:"number"}]},{name:"signature",type:"function",raw:"() => BoundingBox2D",signature:{arguments:[],return:{name:"tuple",raw:"[number, number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"},{name:"number"}]}}}]},description:"Coordinate boundary for the view defined as [left, bottom, right, top].\nShould be used for 2D view only."},cameraPosition:{required:!1,tsType:{name:"ViewStateType"},description:"Camera state for the view defined as a ViewStateType.\nShould be used for 3D view only.\nIf the zoom is given as a 3D bounding box, the camera state is computed to\ndisplay the full box."},triggerHome:{required:!1,tsType:{name:"number"},description:"If changed will reset view settings (bounds or camera) to default position."},views:{required:!1,tsType:{name:"ViewsType"},description:"Views configuration for map. If not specified, all the layers will be\ndisplayed in a single 2D viewport",defaultValue:{value:'{\n    layout: [1, 1],\n    showLabel: false,\n    marginPixels: 0,\n    viewports: [{ id: "main-view", show3D: false, layerIds: [] }],\n}',computed:!1}},coords:{required:!1,tsType:{name:"signature",type:"object",raw:"{\n    visible?: boolean | null;\n    multiPicking?: boolean | null;\n    pickDepth?: number | null;\n}",signature:{properties:[{key:"visible",value:{name:"union",raw:"boolean | null",elements:[{name:"boolean"},{name:"null"}],required:!1}},{key:"multiPicking",value:{name:"union",raw:"boolean | null",elements:[{name:"boolean"},{name:"null"}],required:!1}},{key:"pickDepth",value:{name:"union",raw:"number | null",elements:[{name:"number"},{name:"null"}],required:!1}}]}},description:"Parameters for the InfoCard component",defaultValue:{value:"{ visible: true, multiPicking: true, pickDepth: 10 }",computed:!1}},scale:{required:!1,tsType:{name:"signature",type:"object",raw:"{\n    visible?: boolean | null;\n    incrementValue?: number | null;\n    widthPerUnit?: number | null;\n    cssStyle?: Record<string, unknown> | null;\n}",signature:{properties:[{key:"visible",value:{name:"union",raw:"boolean | null",elements:[{name:"boolean"},{name:"null"}],required:!1}},{key:"incrementValue",value:{name:"union",raw:"number | null",elements:[{name:"number"},{name:"null"}],required:!1}},{key:"widthPerUnit",value:{name:"union",raw:"number | null",elements:[{name:"number"},{name:"null"}],required:!1}},{key:"cssStyle",value:{name:"union",raw:"Record<string, unknown> | null",elements:[{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},{name:"null"}],required:!1}}]}},description:"Parameters for the Distance Scale component",defaultValue:{value:"{ visible: true, cssStyle: { top: 10, left: 10 } }",computed:!1}},coordinateUnit:{required:!1,tsType:{name:"Unit"},description:"",defaultValue:{value:'"m"',computed:!1}},toolbar:{required:!1,tsType:{name:"signature",type:"object",raw:"{\n    visible?: boolean | null;\n}",signature:{properties:[{key:"visible",value:{name:"union",raw:"boolean | null",elements:[{name:"boolean"},{name:"null"}],required:!1}}]}},description:"@deprecated Not in use"},colorTables:{required:!1,tsType:{name:"colorTablesArray"},description:"Prop containing color table data",defaultValue:{value:"defaultColorTables",computed:!0}},editedData:{required:!1,tsType:{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},description:"@deprecated Used by layers to propagate state to component, eg. selected\nwells from the Wells layer. Use client code to handle layer state\ninstead."},setEditedData:{required:!1,tsType:{name:"signature",type:"function",raw:"(data: Record<string, unknown>) => void",signature:{arguments:[{type:{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},name:"data"}],return:{name:"void"}}},description:"@deprecated Used by layers to propagate state to component, eg. selected\nwells from the Wells layer. Use client code to handle layer state\ninstead."},checkDatafileSchema:{required:!1,tsType:{name:"boolean"},description:"Validate JSON datafile against schema",defaultValue:{value:"false",computed:!1}},onMouseEvent:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: MapMouseEvent) => void",signature:{arguments:[{type:{name:"MapMouseEvent"},name:"event"}],return:{name:"void"}}},description:"For get mouse events"},getCameraPosition:{required:!1,tsType:{name:"signature",type:"function",raw:"(input: ViewStateType) => void",signature:{arguments:[{type:{name:"ViewStateType"},name:"input"}],return:{name:"void"}}},description:""},onRenderingProgress:{required:!1,tsType:{name:"signature",type:"function",raw:"(progress: number) => void",signature:{arguments:[{type:{name:"number"},name:"progress"}],return:{name:"void"}}},description:"Will be called while layers have rendered data.\n@param progress value between 0 and 100."},onDragStart:{required:!1,tsType:{name:"signature",type:"function",raw:"(info: PickingInfo, event: MjolnirGestureEvent) => void",signature:{arguments:[{type:{name:"PickingInfo"},name:"info"},{type:{name:"MjolnirGestureEvent"},name:"event"}],return:{name:"void"}}},description:""},onDragEnd:{required:!1,tsType:{name:"signature",type:"function",raw:"(info: PickingInfo, event: MjolnirGestureEvent) => void",signature:{arguments:[{type:{name:"PickingInfo"},name:"info"},{type:{name:"MjolnirGestureEvent"},name:"event"}],return:{name:"void"}}},description:""},triggerResetMultipleWells:{required:!1,tsType:{name:"number"},description:""},selection:{required:!1,tsType:{name:"signature",type:"object",raw:"{\n    well: string | undefined;\n    selection: [number | undefined, number | undefined] | undefined;\n}",signature:{properties:[{key:"well",value:{name:"union",raw:"string | undefined",elements:[{name:"string"},{name:"undefined"}],required:!0}},{key:"selection",value:{name:"union",raw:"[number | undefined, number | undefined] | undefined",elements:[{name:"tuple",raw:"[number | undefined, number | undefined]",elements:[{name:"union",raw:"number | undefined",elements:[{name:"number"},{name:"undefined"}]},{name:"union",raw:"number | undefined",elements:[{name:"number"},{name:"undefined"}]}]},{name:"undefined"}],required:!0}}]}},description:"Range selection of the current well"},lights:{required:!1,tsType:{name:"signature",type:"object",raw:"{\n    headLight?: {\n        intensity: number;\n        color?: [number, number, number];\n    };\n    ambientLight?: {\n        intensity: number;\n        color?: [number, number, number];\n    };\n    pointLights?: [\n        {\n            intensity: number;\n            position: [number, number, number];\n            color?: [number, number, number];\n        },\n    ];\n\n    directionalLights?: [\n        {\n            intensity: number;\n            direction: [number, number, number];\n            color?: [number, number, number];\n        },\n    ];\n}",signature:{properties:[{key:"headLight",value:{name:"signature",type:"object",raw:"{\n    intensity: number;\n    color?: [number, number, number];\n}",signature:{properties:[{key:"intensity",value:{name:"number",required:!0}},{key:"color",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!1}}]},required:!1}},{key:"ambientLight",value:{name:"signature",type:"object",raw:"{\n    intensity: number;\n    color?: [number, number, number];\n}",signature:{properties:[{key:"intensity",value:{name:"number",required:!0}},{key:"color",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!1}}]},required:!1}},{key:"pointLights",value:{name:"tuple",raw:"[\n    {\n        intensity: number;\n        position: [number, number, number];\n        color?: [number, number, number];\n    },\n]",elements:[{name:"signature",type:"object",raw:"{\n    intensity: number;\n    position: [number, number, number];\n    color?: [number, number, number];\n}",signature:{properties:[{key:"intensity",value:{name:"number",required:!0}},{key:"position",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!0}},{key:"color",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!1}}]}}],required:!1}},{key:"directionalLights",value:{name:"tuple",raw:"[\n    {\n        intensity: number;\n        direction: [number, number, number];\n        color?: [number, number, number];\n    },\n]",elements:[{name:"signature",type:"object",raw:"{\n    intensity: number;\n    direction: [number, number, number];\n    color?: [number, number, number];\n}",signature:{properties:[{key:"intensity",value:{name:"number",required:!0}},{key:"direction",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!0}},{key:"color",value:{name:"tuple",raw:"[number, number, number]",elements:[{name:"number"},{name:"number"},{name:"number"}],required:!1}}]}}],required:!1}}]}},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""},getTooltip:{required:!1,tsType:{name:"signature",type:"function",raw:"(\n    info: PickingInfo\n) => string | Record<string, unknown> | null",signature:{arguments:[{type:{name:"PickingInfo"},name:"info"}],return:{name:"union",raw:"string | Record<string, unknown> | null",elements:[{name:"string"},{name:"Record",elements:[{name:"string"},{name:"unknown"}],raw:"Record<string, unknown>"},{name:"null"}]}}},description:"Override default tooltip with a callback.",defaultValue:{value:'function defaultTooltip(info: PickingInfo) {\n    if ((info as WellsPickInfo)?.logName) {\n        return (info as WellsPickInfo)?.logName;\n    } else if (info.layer?.id === "drawing-layer") {\n        return (info as LayerPickInfo).propertyValue?.toFixed(2);\n    }\n    const feat = info.object as Feature;\n    return feat?.properties?.["name"];\n}',computed:!1}},verticalScale:{required:!1,tsType:{name:"number"},description:"A vertical scale factor, used to scale items in the view vertically"},innerRef:{required:!1,tsType:{name:"ReactRef",raw:"React.Ref<HTMLElement>",elements:[{name:"HTMLElement"}]},description:"A reference to a wrapped div element, which can be used to attach\nan event listener."}}}},"./packages/subsurface-viewer/src/layers/BoxSelectionLayer/boxSelectionLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return BoxSelectionLayer}});var _deck_gl_community_editable_layers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@deck.gl-community/editable-layers/dist/index.js"),_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),_deck_gl_layers__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js"),_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts");class BoxSelectionLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__.A{setMultiSelection(pickingInfos){if(this.internalState){const data=pickingInfos.map((item=>item.object)).filter((item=>"Feature"===item.type));this.setState({pickingInfos:pickingInfos,data:data})}}renderLayers(){if(0==this.props.visible)return[];const positionFormat="OrthographicViewport"===this.context.viewport.constructor.name?"XY":"XYZ",geoJsonLayer=new _deck_gl_layers__WEBPACK_IMPORTED_MODULE_3__.A({id:"geoJson",data:this.state.data,pickable:!1,stroked:!1,positionFormat:positionFormat,pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale?this.props.pointRadiusScale:1,lineWidthScale:this.props.lineWidthScale?this.props.lineWidthScale:1,getLineWidth:(0,_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__.YC)("line",this.props.lineStyle?.width,-1),getPointRadius:(0,_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__.YC)("point",this.props.wellHeadStyle?.size,2),getFillColor:[255,140,0],getLineColor:[255,140,0]});return[new _deck_gl_community_editable_layers__WEBPACK_IMPORTED_MODULE_0__.cW(this.getSubLayerProps({id:"selection",selectionType:"rectangle",onSelect:({pickingInfos:pickingInfos})=>{this.setMultiSelection(pickingInfos),this.props.handleSelection&&this.props.handleSelection(pickingInfos)},layerIds:this.props.layerIds,getTentativeFillColor:()=>[255,0,255,100],getTentativeLineColor:()=>[0,0,255,255],getTentativeLineDashArray:()=>[0,0],lineWidthMinPixels:3})),geoJsonLayer]}}BoxSelectionLayer.layerName="BoxSelectionLayer",BoxSelectionLayer.defaultProps={name:"boxSelection",id:"boxSelection-layer",pickable:!0,visible:!0,selectedFeatureIndexes:[],data:{type:"FeatureCollection",features:[]}}},"./packages/subsurface-viewer/src/layers/axes/axesLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return AxesLayer}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),text_layer_text_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/text-layer/text-layer.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js");const defaultProps={name:"Box",id:"box-layer",coordinateSystem:constants.rf.CARTESIAN,lines:[],color:[0,0,0,1]};class BoxLayer extends lib_layer.A{initializeState(context){this.setState(this._getModels(context.device))}shouldUpdateState(){return!0}updateState({context:context}){this.setState(this._getModels(context.device))}_getModels(device){const color=this.props.color.map((x=>(x??0)/255)),grids=new model.K(device,{id:`${this.props.id}-grids`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",uniforms:{uColor:Array.from(color)},geometry:new geometry.V({topology:"line-list",attributes:{positions:new Float32Array(this.props.lines)},vertexCount:this.props.lines.length/3}),modules:[project32.A],isInstanced:!1});return{model:grids,models:[grids].filter(Boolean),modelsByName:{grids:grids}}}}BoxLayer.layerName="BoxLayer",BoxLayer.defaultProps=defaultProps;class AxesLayer extends composite_layer.A{rebuildData(reportBoundingBox){const bounds=(0,lodash.cloneDeep)(this.props.bounds);this.props.ZIncreasingDownwards&&(bounds[2]*=-1,bounds[5]*=-1),bounds[2]>bounds[5]&&([bounds[2],bounds[5]]=[bounds[5],bounds[2]]),bounds[0]>bounds[3]&&([bounds[0],bounds[3]]=[bounds[3],bounds[0]]),bounds[1]>bounds[4]&&([bounds[1],bounds[4]]=[bounds[4],bounds[1]]);const box_lines=function GetBoxLines(bounds){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5];return[x_min,y_min,z_min,x_max,y_min,z_min,x_min,y_min,z_min,x_min,y_max,z_min,x_min,y_max,z_min,x_max,y_max,z_min,x_max,y_max,z_min,x_max,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_max,x_min,y_min,z_max,x_min,y_max,z_max,x_min,y_max,z_max,x_max,y_max,z_max,x_max,y_max,z_max,x_max,y_min,z_max,x_min,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_min,x_max,y_min,z_max,x_max,y_max,z_min,x_max,y_max,z_max,x_min,y_max,z_min,x_min,y_max,z_max]}(bounds),is_orthographic=this.context.viewport.constructor===orthographic_viewport.A,[tick_lines,tick_labels]=function GetTickLines(isZIncreasingDownwards,is_orthographic,bounds,viewport){const ndecimals=0,n_minor_ticks=3,x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],lines=[],tick_labels=[];let x_tick=0,y_tick=0,z_tick=0;const delta=(x_max-x_min+(y_max-y_min)+(z_max-z_min))/3*.025,Lz=LineLengthInPixels([x_min,y_min,z_min],[x_min,y_min,z_max],viewport);if(!is_orthographic){const z_ticks=GetTicks(z_min,z_max,Lz);x_tick=x_min,y_tick=y_min;for(let i=0;i<z_ticks.length;i++){const tick=z_ticks[i],label=((isZIncreasingDownwards?-1:1)*tick).toFixed(ndecimals);tick_labels.push(label),lines.push(x_tick,y_tick,tick);const x=-delta*Math.cos(.7853925),y=-delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}if(z_ticks.length>1){const tick1=z_ticks[0],d=(z_ticks[1]-tick1)/(n_minor_ticks+1),z_start=tick1;let i=0;for(;z_start+(i+1)*d<z_max;){const tick=z_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}for(i=0;z_start-(i+1)*d>z_min;){const tick=z_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}}}const Lx=LineLengthInPixels([x_min,y_min,z_min],[x_max,y_min,z_min],viewport),x_ticks=GetTicks(x_min,x_max,Lx);y_tick=y_min,z_tick=z_min;for(let i=0;i<x_ticks.length;i++){const tick=x_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label),lines.push(tick,y_tick,z_tick);const z=0,y=-delta;lines.push(tick,y_tick+y,z_tick+z)}if(x_ticks.length>1){const tick1=x_ticks[0],d=(x_ticks[1]-tick1)/(n_minor_ticks+1),x_start=tick1;let i=0;for(;x_start+(i+1)*d<x_max;){const tick=x_start+(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}for(i=0;x_start-(i+1)*d>x_min;){const tick=x_start-(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}}const Ly=LineLengthInPixels([x_min,y_min,z_min],[x_min,y_max,z_min],viewport),y_ticks=GetTicks(y_min,y_max,Ly);for(let i=0;i<y_ticks.length;i++){const tick=y_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label);const x_tick=x_min,z_tick=z_min;lines.push(x_tick,tick,z_tick);const z=0,x=-delta;if(lines.push(x_tick+x,tick,z_tick+z),y_ticks.length>1){const tick1=y_ticks[0],d=(y_ticks[1]-tick1)/(n_minor_ticks+1),y_start=tick1;let i=0;for(;y_start+(i+1)*d<y_max;){const tick=y_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}for(i=0;y_start-(i+1)*d>y_min;){const tick=y_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}}}return[lines,tick_labels]}(this.props.ZIncreasingDownwards,is_orthographic,bounds,this.context.viewport),textlayerData=function maketextLayerData(is_orthographic,tick_lines,tick_labels,bounds,labelFontSize){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],dx=Math.abs(x_max-x_min),dy=Math.abs(y_max-y_min),dz=Math.abs(z_max-z_min),offset=(dx+dy+dz)/3*.1,data=[{label:"X",from:[0,0,0],to:[x_max+offset,y_min,z_min],size:labelFontSize??26},{label:"Y",from:[0,0,0],to:[x_min,y_max+offset,z_min],size:labelFontSize??26}];if(!is_orthographic){const z_axis_annotaion={label:"Z",from:[0,0,0],to:[x_min,y_min,z_max+offset],size:labelFontSize??26};data.push(z_axis_annotaion)}for(let i=0;i<tick_lines.length/6;i++){const from=[tick_lines[6*i+0],tick_lines[6*i+1],tick_lines[6*i+2]],to=[tick_lines[6*i+3],tick_lines[6*i+4],tick_lines[6*i+5]],label=tick_labels[i];data.push({label:label,from:from,to:to,size:labelFontSize??11})}return data}(is_orthographic,tick_lines,tick_labels,bounds,this.props.labelFontSize);this.setState({box_lines:box_lines,tick_lines:tick_lines,textlayerData:textlayerData}),void 0!==this.props.reportBoundingBox&&reportBoundingBox&&this.props.reportBoundingBox({layerBoundingBox:bounds})}initializeState(){this.rebuildData(!0)}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.viewportChanged}updateState(){this.rebuildData(!1)}getAnchor(d,is_orthographic){const is_xaxis=d.from[1]!==d.to[1];if(is_orthographic&&is_xaxis)return"middle";const screen_from=this.context.viewport.project(d.from),screen_to=this.context.viewport.project(d.to);return"X"!==d.label&&"Y"!==d.label&&"Z"!==d.label&&screen_from[0]<screen_to[0]?"start":"end"}getLabelPosition(d){if("X"!==d.label&&"Y"!==d.label&&"Z"!==d.label){const tick_vec=[d.to[0]-d.from[0],d.to[1]-d.from[1]];d.to[2]&&d.from[2]&&tick_vec.push(d.to[2]-d.from[2]);const s=.5;return[d.to[0]+s*tick_vec[0],d.to[1]+s*tick_vec[1],d.to[2]+s*tick_vec[2]]}return d.to}getBaseLine(d,is_orthographic){if("X"===d.label)return"center";const is_xaxis_label=d.from[1]!==d.to[1];return is_orthographic&&is_xaxis_label?"top":"center"}renderLayers(){const is_orthographic=this.context.viewport.constructor===orthographic_viewport.A,lines=[...this.state.box_lines,...this.state.tick_lines];return[new BoxLayer(this.getSubLayerProps({lines:lines,coordinateSystem:constants.rf.CARTESIAN,color:this.props.axisColor||[0,0,0,255]})),new text_layer_text_layer.A(this.getSubLayerProps({fontFamily:this.props.fontFamily??"Monaco, monospace",data:this.state.textlayerData,id:"text-layer",pickable:!0,getPosition:d=>this.getLabelPosition(d),getText:d=>d.label,sizeUnits:"pixels",getSize:d=>d.size,getAngle:0,getTextAnchor:d=>this.getAnchor(d,is_orthographic),getAlignmentBaseline:d=>this.getBaseLine(d,is_orthographic),coordinateSystem:constants.rf.CARTESIAN,getColor:this.props.labelColor||[0,0,0,255]}))]}}function LineLengthInPixels(p0,p1,viewport){const screen_from=viewport.project(p0),screen_to=viewport.project(p1),v=[screen_from[0]-screen_to[0],screen_from[1]-screen_to[1],screen_from[2]-screen_to[2]];return Math.sqrt(v[0]*v[0]+v[1]*v[1])}function GetTicks(min,max,axis_pixel_length){let step=Math.min(Math.round(axis_pixel_length/100)+1,20);const range=max-min,delta=Math.abs(range)/step;let decade=1;if(delta>=10){const logde=Math.log10(delta),pot=Math.floor(logde);decade=Math.pow(10,pot)}let scaled_delta=Math.round(delta/decade);3==scaled_delta?scaled_delta=2:4==scaled_delta||6==scaled_delta||7==scaled_delta?scaled_delta=5:scaled_delta>7?scaled_delta=10:scaled_delta<1&&(scaled_delta=1);const incr=scaled_delta*decade,start=Math.ceil(min/incr)*incr,stop=Math.floor(max/incr)*incr,calc_step=Math.floor(Math.abs(stop-start)/incr);step=calc_step>0?calc_step:0;const ticks=[];for(let i=0;i<=step;i++){const x=start+i*incr;ticks.push(x)}return ticks}AxesLayer.layerName="AxesLayer",AxesLayer.defaultProps={"@@type":"AxesLayer",name:"Axes",id:"axes-layer",visible:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/grid3d/grid3dLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{e:function(){return TGrid3DColoringMode},A:function(){return Grid3DLayer}});var lodash=__webpack_require__("./node_modules/lodash/lodash.js"),composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),load=__webpack_require__("./node_modules/@loaders.gl/core/dist/lib/api/load.js"),json_loader=__webpack_require__("./node_modules/@loaders.gl/loader-utils/dist/json-loader.js"),workerpool=__webpack_require__("./node_modules/workerpool/dist/workerpool.js"),workerpool_default=__webpack_require__.n(workerpool),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js"),shader_modules=__webpack_require__("./packages/subsurface-viewer/src/layers/shader_modules/index.ts"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");const DEFAULT_TEXTURE_PARAMETERS={addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",minFilter:"linear",magFilter:"linear"},DISCRETE_TEXTURE_PARAMETERS={minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},defaultProps={colorMapName:"",colorMapClampColor:[200,200,200],coloringMode:0,coordinateSystem:constants.rf.CARTESIAN,propertyValueRange:[0,1],depthTest:!0,ZIncreasingDownwards:!0};class PrivateLayer extends lib_layer.A{get isLoaded(){return this.state.isLoaded??!1}initializeState(context){const[model_mesh,mesh_lines_model]=this._getModels(context);this.setState({models:[model_mesh,mesh_lines_model],isLoaded:!1})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(context){const propertyUniforms=this.getPropertyUniforms(),colormap=this.getTexture(context);return[new model.K(context.device,{id:`${this.props.id}-mesh`,vs:"#version 300 es\n#define SHADER_NAME grid3d-vertex-shader\nprecision highp float;\n\nin vec3 positions;\nin float properties;\nin vec3 normals;\n\nuniform lowp int coloringMode;\n\n// Outputs to fragment shader\nout vec3 cameraPosition;\nout vec4 position_commonspace;\nflat out float property;\nout float property_interpolated;\n\nflat out vec3 normal;\nflat out int vertexIndex;\n\nuniform bool ZIncreasingDownwards;\n\nconst vec3 pickingColor = vec3(1.0, 1.0, 0.0);\n\nvoid main(void) { \n   \n   vertexIndex = gl_VertexID;\n   cameraPosition = project_uCameraPosition;   \n   geometry.pickingColor = pickingColor;\n\n   normal = normals;\n   vec3 position = positions;\n\n   float zSign = ZIncreasingDownwards ? -1.0 : 1.0;\n\n   position.z *= zSign;\n   normal.z   *= zSign;\n\n   switch(coloringMode) {\n      case 0: property = properties; break;\n      case 1: property_interpolated = position.x; break;\n      case 2: property_interpolated = position.y; break;\n      case 3: property_interpolated = position.z; break;\n      default: property = properties; break;\n   }\n\n   position_commonspace = vec4(project_position(position), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n   DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n   vec4 color = vec4(0.0);\n   DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:'#version 300 es\n#define SHADER_NAME grid3d-fragment-shader\n\nprecision highp float;\n\nin vec3 cameraPosition;\nin vec4 position_commonspace;\nflat in float property;\nin float property_interpolated;\n\nflat in vec3 normal;\nflat in int vertexIndex;\n\nout vec4 fragColor;\n\nuniform sampler2D colormap;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform bool isColoringDiscrete;\nuniform float colorMapSize;\nuniform lowp int coloringMode;\n\nuniform vec3 colorMapClampColor;\nuniform vec3 undefinedPropertyColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\n\nvec4 getContinuousPropertyColor (float propertyValue) {\n   \n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n   float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n   if (x < 0.0 || x > 1.0) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n      }\n      else {\n         // Use min/max color to clamp.\n         x = clamp (x, 0.0, 1.0);         \n         color = texture(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      color = texture(colormap, vec2(x, 0.5));\n   }\n   return color;\n}\n\n// Calculate color from propertyValue using discrete colormap.\nvec4 getDiscretePropertyColor (float propertyValue) {\n\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n   float tolerance = (1.0 / colorMapSize) * 0.5;\n\n   if (propertyValue < colorMapRangeMin - tolerance || propertyValue > colorMapRangeMax + tolerance) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n      }\n      else {\n         // Use min/max color to clamp.\n         float p = clamp (propertyValue, colorMapRangeMin, colorMapRangeMax);\n         float x = p / colorMapSize;\n         color = texture(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      float x = propertyValue / colorMapSize;\n      color = texture(colormap, vec2(x + tolerance, 0.5));\n   }\n   return color;\n}\n\nvec4 getPropertyColor (float propertyValue) {\n   if(isColoringDiscrete) {\n      return getDiscretePropertyColor (propertyValue);\n   }\n   return getContinuousPropertyColor (propertyValue);\n}\n\nvoid main(void) {\n\n   if (picking.isActive > 0.5 && !(picking.isAttribute > 0.5)) {\n      fragColor = encodeVertexIndexToRGB(vertexIndex);      \n      return;\n   }\n\n   if (coloringMode == 0 && isnan(property)) {\n      vec3 lightColor = getPhongLightColor(undefinedPropertyColor.rgb, cameraPosition, position_commonspace.xyz, normal);\n      fragColor = vec4(lightColor, 1.0);      \n      return;\n   } \n       \n   // Property values other than X,Y or Z are passed as "flat" i.e. constant over faces.\n   float propertyValue = coloringMode == 0 ? property : property_interpolated;\n   propertyValue = clamp(propertyValue, valueRangeMin, valueRangeMax);\n\n   vec4 color = getPropertyColor(propertyValue);\n\n   // Use two sided phong lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = getPhongLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',geometry:new geometry.V({topology:this.props.mesh.drawMode??"triangle-list",attributes:{positions:this.props.mesh.attributes.positions,properties:this.props.mesh.attributes.properties,normals:this.props.mesh.attributes.normals},vertexCount:this.props.mesh.vertexCount}),bufferLayout:this.getAttributeManager().getBufferLayouts(),uniforms:{...propertyUniforms,coloringMode:this.props.coloringMode,ZIncreasingDownwards:this.props.ZIncreasingDownwards},bindings:{colormap:colormap},modules:[project32.A,picking.A,shader_modules.oS,shader_modules.BF],isInstanced:!1}),new model.K(context.device,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nuniform bool ZIncreasingDownwards;\n\nvoid main(void) {\n   vec3 position = positions;\n   position[2] *= ZIncreasingDownwards ? -1.0 : 1.0;\n\n   vec3 position_commonspace = project_position(position);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.V(this.props.meshLines),bufferLayout:this.getAttributeManager().getBufferLayouts(),uniforms:{ZIncreasingDownwards:this.props.ZIncreasingDownwards},modules:[project32.A,picking.A],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{context:context}=args,{gl:gl}=context,[model_mesh,mesh_lines_model]=this.state.models;gl.enable(gl.POLYGON_OFFSET_FILL),gl.polygonOffset(1,1),this.props.depthTest||gl.disable(gl.DEPTH_TEST),model_mesh.draw(context.renderPass),gl.disable(gl.POLYGON_OFFSET_FILL),this.props.gridLines&&mesh_lines_model.draw(context.renderPass),this.props.depthTest||gl.enable(gl.DEPTH_TEST),this.state.isLoaded||this.setState({...this.state,isLoaded:!0})}decodePickingColor(){return this.nullPickingColor()}encodePickingColor(){return this.nullPickingColor()}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],vertexIndex=65536*info.color[0]+256*info.color[1]+info.color[2],zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1;if(void 0!==info.coordinate?.[2]){const depth=(this.props.ZIncreasingDownwards?-info.coordinate[2]:info.coordinate[2])/Math.max(.001,zScale);layer_properties.push((0,layerTools.e2)("Depth",depth))}const propertyIndex=this.props.mesh.attributes.properties.value[vertexIndex];if(Number.isFinite(propertyIndex)){const propertyText=this.getPropertyText(propertyIndex);propertyText?(layer_properties.push((0,layerTools.e2)("Property",propertyText.text)),layer_properties.push((0,layerTools.e2)("Value",propertyText.value))):layer_properties.push((0,layerTools.e2)("Property",propertyIndex))}return{...info,properties:layer_properties}}getPropertyText(index){if(!this.props.discretePropertyValueNames)return;if(index<0||index>=this.props.discretePropertyValueNames.length)return;const valueName=this.props.discretePropertyValueNames[index];return{text:valueName.name,value:valueName.value}}getDefaultImageData(){return{data:new Uint8Array([0,0,0]),count:1,parameters:DISCRETE_TEXTURE_PARAMETERS,isColoringDiscrete:!0}}getImageData(){if(this.props.colorMapFunction instanceof Uint8Array){const count=this.props.colorMapFunction.length/3;if(0===count)return this.getDefaultImageData();const parameters=this.props.coloringMode===TGrid3DColoringMode.Property?DISCRETE_TEXTURE_PARAMETERS:DEFAULT_TEXTURE_PARAMETERS,isColoringDiscrete=this.props.coloringMode===TGrid3DColoringMode.Property;return{data:this.props.colorMapFunction,count:count,parameters:parameters,isColoringDiscrete:isColoringDiscrete}}return{data:(0,layerTools.M5)(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction),count:256,parameters:DEFAULT_TEXTURE_PARAMETERS,isColoringDiscrete:!1}}getPropertyUniforms(){const valueRangeMin=this.props.propertyValueRange?.[0]??0,valueRangeMax=this.props.propertyValueRange?.[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,isClampColor=void 0!==this.props.colorMapClampColor&&!0!==this.props.colorMapClampColor&&!1!==this.props.colorMapClampColor,colorMapClampColorUniform=(isClampColor?this.props.colorMapClampColor:[0,0,0]).map((x=>(x??0)/255)),undefinedPropertyColorUniform=this.props.undefinedPropertyColor.map((x=>(x??0)/255)),isColorMapClampColorTransparent=!1===this.props.colorMapClampColor,imageData=this.getImageData();return{valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax,undefinedPropertyColor:undefinedPropertyColorUniform,colorMapClampColor:Array.from(colorMapClampColorUniform),isColorMapClampColorTransparent:isColorMapClampColorTransparent,isClampColor:isClampColor,isColoringDiscrete:imageData.isColoringDiscrete,colorMapSize:imageData.count}}getTexture(context){const textureProps={sampler:DEFAULT_TEXTURE_PARAMETERS,width:256,height:1,format:"rgb8unorm-webgl"};if(this.props.colorMapFunction instanceof Uint8Array){const imageData=this.getImageData();if(0===this.props.colorMapFunction.length/3){return context.device.createTexture({...textureProps,width:imageData.count,data:new Uint8Array([0,0,0,0,0,0]),sampler:DISCRETE_TEXTURE_PARAMETERS})}const sampler=this.props.coloringMode===TGrid3DColoringMode.Property?DISCRETE_TEXTURE_PARAMETERS:DEFAULT_TEXTURE_PARAMETERS;return context.device.createTexture({...textureProps,width:imageData.count,data:imageData.data,sampler:sampler})}const data=(0,layerTools.M5)(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction);return context.device.createTexture({...textureProps,height:1,data:data})}}function makeFullMesh(e){class Node{constructor(i,x,y){this.i=i,this.x=x,this.y=y,this.prev=this,this.next=this,this.z=0,this.prevZ=this,this.nextZ=this,this.steiner=!1}}function earcut(data,dim){dim=dim||2;const outerLen=data.length,outerNode=function linkedList(data,start,end,dim,clockwise){let i,last=null;if(clockwise===function signedArea(data,start,end,dim){let sum=0;for(let i=start,j=end-dim;i<end;i+=dim)sum+=(data[j]-data[i])*(data[i+1]+data[j+1]),j=i;return sum}(data,start,end,dim)>0)for(i=start;i<end;i+=dim)last=insertNode(i,data[i],data[i+1],last);else for(i=end-dim;i>=start;i-=dim)last=insertNode(i,data[i],data[i+1],last);last&&equals(last,last.next)&&(removeNode(last),last=last.next);return last}(data,0,outerLen,dim,!0),triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let x,y,minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY,maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY,invSize=0;if(data.length>80*dim){minX=maxX=data[0],minY=maxY=data[1];for(let i=dim;i<outerLen;i+=dim)x=data[i],y=data[i+1],x<minX&&(minX=x),y<minY&&(minY=y),x>maxX&&(maxX=x),y>maxY&&(maxY=y);invSize=Math.max(maxX-minX,maxY-minY),invSize=0!==invSize?32767/invSize:0}return earcutLinked(outerNode,triangles,dim,minX,minY,invSize,0),triangles;function filterPoints(start,end){if(!start)return start;end||(end=start);let again,p=start;do{if(again=!1,p.steiner||!equals(p,p.next)&&0!==area(p.prev,p,p.next))p=p.next;else{if(removeNode(p),p=end=p.prev,p===p.next)break;again=!0}}while(again||p!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;!pass&&invSize&&function indexCurve(start,minX,minY,invSize){let p=start;do{0===p.z&&(p.z=zOrder(p.x,p.y,minX,minY,invSize)),p.prevZ=p.prev,p.nextZ=p.next,p=p.next}while(p!==start);p.prevZ&&(p.prevZ.nextZ=null);p.prevZ=null,function sortLinked(list){let i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{for(p=list,list=null,tail=null,numMerges=0;p;){for(numMerges++,q=p,pSize=0,i=0;i<inSize&&(pSize++,q=q.nextZ,q);i++);for(qSize=inSize;pSize>0||qSize>0&&q;)p&&0!==pSize&&(0===qSize||!q||p.z<=q.z)?(e=p,p=p?.nextZ,pSize--):(e=q,q=q?.nextZ,qSize--),tail?tail.nextZ=e:list=e,e?.prevZ&&(e.prevZ=tail),tail=e;p=q}tail&&(tail.nextZ=null),inSize*=2}while(numMerges>1);return list}(p)}(ear,minX,minY,invSize);let prev,next,stop=ear;for(;ear.prev!==ear.next;)if(prev=ear.prev,next=ear.next,invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear))triangles.push(prev.i/dim|0),triangles.push(ear.i/dim|0),triangles.push(next.i/dim|0),removeNode(ear),ear=next.next,stop=next.next;else if((ear=next)===stop){pass?1===pass?earcutLinked(ear=cureLocalIntersections(filterPoints(ear),triangles,dim),triangles,dim,minX,minY,invSize,2):2===pass&&splitEarcut(ear,triangles,dim,minX,minY,invSize):earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);break}}function getMin(a,b,c){return a<b?a<c?a:c:b<c?b:c}function getMax(a,b,c){return a>b?a>c?a:c:b>c?b:c}function triangleBBox(ax,bx,cx,ay,by,cy){return[getMin(ax,bx,cx),getMin(ay,by,cy),getMax(ax,bx,cx),getMax(ay,by,cy)]}function isEar(ear){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,[x0,y0,x1,y1]=triangleBBox(ax,bx,cx,ay,by,cy);let p=c.next;for(;p!==a;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function isEarHashed(ear,minX,minY,invSize){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,[x0,y0,x1,y1]=triangleBBox(ax,bx,cx,ay,by,cy),minZ=zOrder(x0,y0,minX,minY,invSize),maxZ=zOrder(x1,y1,minX,minY,invSize);let p=ear.prevZ,n=ear.nextZ;for(;p&&p.z>=minZ&&n&&n.z<=maxZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}for(;p&&p.z>=minZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;n&&n.z<=maxZ;){if(n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}return!0}function cureLocalIntersections(start,triangles,dim){let p=start;do{const a=p.prev,b=p.next.next;!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)&&(triangles.push(a.i/dim|0),triangles.push(p.i/dim|0),triangles.push(b.i/dim|0),removeNode(p),removeNode(p.next),p=start=b),p=p.next}while(p!==start);return filterPoints(p)}function splitEarcut(start,triangles,dim,minX,minY,invSize){let a=start;do{let b=a.next.next;for(;b!==a.prev;){if(a.i!==b.i&&isValidDiagonal(a,b)){let c=splitPolygon(a,b);return a=filterPoints(a,a.next),c=filterPoints(c,c.next),earcutLinked(a,triangles,dim,minX,minY,invSize,0),void earcutLinked(c,triangles,dim,minX,minY,invSize,0)}b=b.next}a=a.next}while(a!==start)}function zOrder(x,y,minX,minY,invSize){return(x=1431655765&((x=858993459&((x=252645135&((x=16711935&((x=(x-minX)*invSize|0)|x<<8))|x<<4))|x<<2))|x<<1))|(y=1431655765&((y=858993459&((y=252645135&((y=16711935&((y=(y-minY)*invSize|0)|y<<8))|y<<4))|y<<2))|y<<1))<<1}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)>=(ax-px)*(cy-py)&&(ax-px)*(by-py)>=(bx-px)*(ay-py)&&(bx-px)*(cy-py)>=(cx-px)*(by-py)}function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!function intersectsPolygon(a,b){let p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return!0;p=p.next}while(p!==a);return!1}(a,b)&&(locallyInside(a,b)&&locallyInside(b,a)&&function middleInside(a,b){const px=(a.x+b.x)/2,py=(a.y+b.y)/2;let p=a,inside=!1;do{p.y>py!=p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x&&(inside=!inside),p=p.next}while(p!==a);return inside}(a,b)&&(area(a.prev,a,b.prev)||area(a,b.prev,b))||equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0)}function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){const o1=sign(area(p1,q1,p2)),o2=sign(area(p1,q1,q2)),o3=sign(area(p2,q2,p1)),o4=sign(area(p2,q2,q1));return o1!==o2&&o3!==o4||(!(0!==o1||!onSegment(p1,p2,q1))||(!(0!==o2||!onSegment(p1,q2,q1))||(!(0!==o3||!onSegment(p2,p1,q2))||!(0!==o4||!onSegment(p2,q1,q2)))))}function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y)}function sign(num){return num>0?1:num<0?-1:0}function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0}function splitPolygon(a,b){const a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;return a.next=b,b.prev=a,a2.next=an,an.prev=a2,b2.next=a2,a2.prev=b2,bp.next=b2,b2.prev=bp,b2}function insertNode(i,x,y,last){const p=new Node(i,x,y);return last?(p.next=last.next,p.prev=last,last.next.prev=p,last.next=p):(p.prev=p,p.next=p),p}function removeNode(p){p.next.prev=p.prev,p.prev.next=p.next,p.prevZ&&(p.prevZ.nextZ=p.nextZ),p.nextZ&&(p.nextZ.prevZ=p.prevZ)}}const get3DPoint=(points,index)=>points.slice(3*index,3*(index+1)),substractPoints=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],crossProduct=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]],dotProduct=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],normalize=a=>{const len=Math.sqrt(dotProduct(a,a));return[a[0]/len,a[1]/len,a[2]/len]},projectPoint=(u,v,p)=>[dotProduct(p,u),dotProduct(p,v)],projectPolygon=points=>{const p0=get3DPoint(points,0),p1=get3DPoint(points,1),p2=get3DPoint(points,2),v1=substractPoints(p1,p0),v2=substractPoints(p2,p0),normal=normalize(crossProduct(v1,v2)),u=normalize(v1),v=normalize(crossProduct(normal,u)),res=[],count=points.length/3;for(let i=0;i<count;++i){const p=get3DPoint(points,i),fp=projectPoint(u,v,p);res.push(...fp)}return res},averageNormal=(points,triangles)=>{const res=[0,0,0];for(let i=0;i<triangles.length;i+=3){const p0=get3DPoint(points,triangles[i]),p1=get3DPoint(points,triangles[i+1]),p2=get3DPoint(points,triangles[i+2]),v1=substractPoints(p1,p0),v2=substractPoints(p2,p0),normal=crossProduct(v1,v2);res[0]+=normal[0],res[1]+=normal[1],res[2]+=normal[2]}return normalize(res)},tryCreateArrays=counts=>{try{const trianglePoints=new Float32Array(9*counts.triangles),triangleNormals=new Float32Array(9*counts.triangles),properties=new Float32Array(3*counts.triangles);return{trianglePoints:trianglePoints,triangleNormals:triangleNormals,properties:properties,lineIndices:new Uint32Array(2*counts.lineSegments)}}catch(error){return console.log(error),null}},createEmptyMeshes=()=>[{drawMode:"triangle-list",attributes:{positions:{value:new Float32Array,size:3},properties:{value:new Float32Array,size:1},normals:{value:new Float32Array,size:3}},vertexCount:0},{drawMode:"line-list",topology:"line-list",attributes:{positions:{value:new Float32Array,size:3},indices:{value:new Uint32Array,size:1}},vertexCount:0},[propertyValueRangeMin,propertyValueRangeMax]],t0=performance.now(),params=e.data,polys=params.polys,properties=params.properties;let propertyValueRangeMin=Number.POSITIVE_INFINITY,propertyValueRangeMax=Number.NEGATIVE_INFINITY,pn=0,i=0;const counts=(polys=>{let triangles=0,lineSegments=0,i=0;for(;i<polys.length;)triangles+=polys[i]-2,lineSegments+=polys[i],i+=polys[i]+1;return{triangles:triangles,lineSegments:lineSegments}})(polys),meshArrays=(counts=>{const currentCounts={...counts};let res=null;do{res=tryCreateArrays(currentCounts),null===res&&(currentCounts.triangles-=.1*counts.triangles,currentCounts.lineSegments-=.1*counts.lineSegments,console.warn("Arrays size reduced!"))}while(null===res&&currentCounts.triangles>0);return{arrays:res,counts:currentCounts}})(counts);if(!meshArrays?.arrays)return createEmptyMeshes();let arraysIndex=0,propertyIndex=0,linesIndex=0;const trianglesVertexCount=meshArrays.arrays.trianglePoints.length/3,linesVertexCount=meshArrays.arrays.lineIndices.length;try{for(;i<polys.length&&arraysIndex<meshArrays.arrays.trianglePoints.length-3;){const n=polys[i];let propertyValue=properties[pn++];value=propertyValue,undefinedValue=params.undefinedValue,null===value||Number.isNaN(value)||value===undefinedValue?propertyValue=Number.NaN:(propertyValueRangeMin=propertyValue<propertyValueRangeMin?propertyValue:propertyValueRangeMin,propertyValueRangeMax=propertyValue>propertyValueRangeMax?propertyValue:propertyValueRangeMax);for(let j=i+1;j<i+n;++j)meshArrays.arrays.lineIndices[linesIndex]=polys[j],meshArrays.arrays.lineIndices[linesIndex+1]=polys[j+1],linesIndex+=2;meshArrays.arrays.lineIndices[linesIndex]=polys[i+1],meshArrays.arrays.lineIndices[linesIndex+1]=polys[i+n],linesIndex+=2;const polygon=[];for(let p=1;p<=n;++p){const i0=polys[i+p],point=[params.points[3*i0],params.points[3*i0+1],params.points[3*i0+2]];polygon.push(...point)}const triangles=earcut(projectPolygon(polygon),2),normal=averageNormal(polygon,triangles);for(const t of triangles){const point=get3DPoint(polygon,t);meshArrays.arrays.trianglePoints[arraysIndex]=point[0],meshArrays.arrays.trianglePoints[arraysIndex+1]=point[1],meshArrays.arrays.trianglePoints[arraysIndex+2]=point[2],meshArrays.arrays.triangleNormals[arraysIndex]=normal[0],meshArrays.arrays.triangleNormals[arraysIndex+1]=normal[1],meshArrays.arrays.triangleNormals[arraysIndex+2]=normal[2],meshArrays.arrays.properties[propertyIndex]=propertyValue,arraysIndex+=3,propertyIndex+=1}i=i+n+1}console.log("Number of polygons: ",pn),console.log("Number of triangles: ",meshArrays.counts.triangles);const mesh={drawMode:"triangle-list",attributes:{positions:{value:meshArrays.arrays.trianglePoints,size:3},properties:{value:meshArrays.arrays.properties,size:1},normals:{value:meshArrays.arrays.triangleNormals,size:3}},vertexCount:trianglesVertexCount},mesh_lines={drawMode:"line-list",topology:"line-list",attributes:{positions:{value:params.points,size:3},indices:{value:meshArrays.arrays.lineIndices,size:1}},vertexCount:linesVertexCount},t1=performance.now();return console.log(`Task makeMesh took ${.001*(t1-t0)}  seconds.`),[mesh,mesh_lines,[propertyValueRangeMin,propertyValueRangeMax]]}catch(error){return console.log("Grid3d webworker failed with error: ",error),createEmptyMeshes()}var value,undefinedValue}PrivateLayer.layerName="PrivateLayer",PrivateLayer.defaultProps=defaultProps;var SubsurfaceConfig=__webpack_require__("./packages/subsurface-viewer/src/SubsurfaceConfig.json");const workerPoolConfig=(0,__webpack_require__("./packages/subsurface-viewer/src/utils/configTools.ts").u)(SubsurfaceConfig,"config/workerpool","config/layer/Grid3DLayer/workerpool"),pool=workerpool_default().pool({maxWorkers:10,workerType:"web",...workerPoolConfig});async function loadData(data,type){if(data instanceof type)return data;if(Array.isArray(data))return new type(data);if("string"==typeof data){const extension=data.split(".").pop()?.toLowerCase();if("json"===extension){return new type(await(0,load.H)(data,json_loader.q))}const response=await fetch(data);if(response.ok){const blob=await response.blob();return new type(await blob.arrayBuffer())}}return Promise.reject("Grid3DLayer: Unsupported type of input data")}async function load_data(pointsData,polysData,propertiesData,loadProperties){const points=await loadData(pointsData,Float32Array),polys=await loadData(polysData,Uint32Array),properties=loadProperties?await async function loadPropertiesData(propertiesData){return propertiesData instanceof Uint16Array?await loadData(propertiesData,Uint16Array):await loadData(propertiesData,Float32Array)}(propertiesData):new Float32Array;return Promise.all([points,polys,properties])}let TGrid3DColoringMode=function(TGrid3DColoringMode){return TGrid3DColoringMode[TGrid3DColoringMode.Property=0]="Property",TGrid3DColoringMode[TGrid3DColoringMode.X=1]="X",TGrid3DColoringMode[TGrid3DColoringMode.Y=2]="Y",TGrid3DColoringMode[TGrid3DColoringMode.Z=3]="Z",TGrid3DColoringMode}({});const grid3dLayer_defaultProps={"@@type":"Grid3DLayer",name:"Grid 3D",id:"grid-3d-layer",visible:!0,material:!0,coloringMode:TGrid3DColoringMode.Property,colorMapName:"",gridLines:!0,propertyValueRange:[0,1],depthTest:!0,ZIncreasingDownwards:!0};class Grid3DLayer extends composite_layer.A{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinished=this.state?.isFinishedLoading??!1;return isLoaded&&isFinished}rebuildData(reportBoundingBox){load_data(this.props.pointsData,this.props.polysData,this.props.propertiesData,this.props.coloringMode===TGrid3DColoringMode.Property).then((([points,polys,properties])=>{const bbox=function GetBBox(points){let xmax=-99999999,ymax=-99999999,zmax=-99999999,xmin=99999999,ymin=99999999,zmin=99999999;for(let i=0;i<points.length/3;i++)xmax=points[3*i+0]>xmax?points[3*i+0]:xmax,xmin=points[3*i+0]<xmin?points[3*i+0]:xmin,ymax=points[3*i+1]>ymax?points[3*i+1]:ymax,ymin=points[3*i+1]<ymin?points[3*i+1]:ymin,zmax=points[3*i+2]>zmax?points[3*i+2]:zmax,zmin=points[3*i+2]<zmin?points[3*i+2]:zmin;return[xmin,ymin,zmin,xmax,ymax,zmax]}(points),webworkerParams={points:points,polys:polys,properties:properties,undefinedValue:this.getUndefinedPropertyValue()};pool.exec(makeFullMesh,[{data:webworkerParams}]).then((e=>{const[mesh,mesh_lines,propertyValueRange]=e,legend={discrete:!1,valueRange:this.props.colorMapRange??propertyValueRange,colorName:this.props.colorMapName,title:"MapLayer",colorMapFunction:this.props.colorMapFunction};this.setState({mesh:mesh,mesh_lines:mesh_lines,propertyValueRange:propertyValueRange,legend:legend,bbox:bbox}),void 0!==this.props.reportBoundingBox&&reportBoundingBox&&this.props.reportBoundingBox({layerBoundingBox:bbox}),this.setState({...this.state,isFinishedLoading:!0}),function onTerminateWorker(){const stats=pool.stats();0===stats.busyWorkers&&0===stats.pendingTasks&&pool.terminate()}()}))}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.pointsData,oldProps.pointsData)&&(0,lodash.isEqual)(props.polysData,oldProps.polysData)&&(0,lodash.isEqual)(props.propertiesData,oldProps.propertiesData)&&(0,lodash.isEqual)(props.gridLines,oldProps.gridLines)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];const undefinedColor=this.getUndefinedPropertyColor(),undefinedValue=this.getUndefinedPropertyValue();return[new PrivateLayer(this.getSubLayerProps({mesh:this.state.mesh,meshLines:this.state.mesh_lines,pickable:this.props.pickable,colorMapName:this.props.colorMapName,colorMapRange:this.props.colorMapRange,colorMapClampColor:this.props.colorMapClampColor,undefinedPropertyValue:undefinedValue,undefinedPropertyColor:undefinedColor,colorMapFunction:this.props.colorMapFunction,coloringMode:this.props.coloringMode,gridLines:this.props.gridLines,propertyValueRange:this.getPropertyValueRange(),discretePropertyValueNames:this.props.discretePropertyValueNames,material:this.props.material,depthTest:this.props.depthTest,ZIncreasingDownwards:this.props.ZIncreasingDownwards}))]}getPropertyValueRange(){const bbox=this.state.bbox,zSign=this.props.ZIncreasingDownwards?-1:1;switch(this.props.coloringMode){case TGrid3DColoringMode.X:return[bbox[0],bbox[3]];case TGrid3DColoringMode.Y:return[bbox[1],bbox[4]];case TGrid3DColoringMode.Z:return[zSign*bbox[2],zSign*bbox[5]];default:return this.state.propertyValueRange}}getUndefinedPropertyValue(){return"number"==typeof this.props.undefinedPropertyValue?new Float32Array([this.props.undefinedPropertyValue])[0]:this.props.propertiesData instanceof Uint16Array?65535:Number.NaN}getUndefinedPropertyColor(){const colorFunc=this.props.colorMapFunction;return 0===this.props.propertiesData.length&&this.isColorMapFunctionConstantColor(colorFunc)?[colorFunc[0],colorFunc[1],colorFunc[2]]:this.props.undefinedPropertyColor??[204,204,204]}isColorMapFunctionConstantColor(colorFunc){return(Array.isArray(colorFunc)||colorFunc instanceof Uint8Array)&&colorFunc.length>=3}}Grid3DLayer.layerName="Grid3DLayer",Grid3DLayer.defaultProps=grid3dLayer_defaultProps},"./packages/subsurface-viewer/src/layers/index.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Axes2DLayer:function(){return Axes2DLayer},AxesLayer:function(){return axesLayer.A},BoxSelectionLayer:function(){return boxSelectionLayer.A},ColormapLayer:function(){return ColormapLayer},DrawingLayer:function(){return DrawingLayer},FaultPolygonsLayer:function(){return FaultPolygonsLayer},Grid3DLayer:function(){return grid3dLayer.A},Hillshading2DLayer:function(){return Hillshading2DLayer},MapLayer:function(){return mapLayer.A},NorthArrow3DLayer:function(){return northArrow3DLayer.A},PieChartLayer:function(){return PieChartLayer},PointsLayer:function(){return PointsLayer},PolylinesLayer:function(){return polylinesLayer.A},SelectableGeoJsonLayer:function(){return SelectableGeoJsonLayer},TriangleLayer:function(){return TriangleLayer},UnfoldedGeoJsonLayer:function(){return UnfoldedGeoJsonLayer},WellMarkersLayer:function(){return WellMarkersLayer},WellMarkersLayerProps:function(){return WellMarkersLayer},WellsLayer:function(){return wellsLayer.Ay},abscissaTransform:function(){return abscissaTransform.u}});var bitmap_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js"),shader_modules=__webpack_require__("./packages/subsurface-viewer/src/layers/shader_modules/index.ts");function decodeRGB([r,g,b],decoder,remapToRange){const{rgbScaler:rgbScaler,floatScaler:floatScaler,offset:offset,step:step}=decoder,[rScale,gScale,bScale]=rgbScaler;let decodedValue=((r*=256*rScale*256)+(g*=256*gScale)+(b*=bScale)+offset)*floatScaler;if(step>0&&(decodedValue=Math.floor(decodedValue/step+.5)*step),remapToRange){const[min,max]=remapToRange;decodedValue=decodedValue*(max-min)+min}return decodedValue}var layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");var dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js");function getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined=void 0!==colorMapFunction,data=new Uint8Array(768);for(let i=0;i<256;i++){const value=i/255,rgb=isColorMapFunctionDefined?colorMapFunction(i/255):(0,dist.KP)(value,colorMapName,colorTables);let color=[];null!=rgb&&(color=Array.isArray(rgb)?rgb:[rgb.r,rgb.g,rgb.b]),data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2]}return data}const defaultProps={"@@type":"ColormapLayer",name:"Property map",id:"colormap-layer",pickable:!0,visible:!0,valueRange:{type:"array",value:[0,1]},colorMapRange:{type:"array"},valueDecoder:{rgbScaler:[1,1,1],floatScaler:1/16777215,offset:0,step:0},rotDeg:0,colorMapName:"Rainbow"};class ColormapLayer extends bitmap_layer.A{initializeState(){super.initializeState()}draw({moduleParameters:moduleParameters,uniforms:uniforms}){if(!this.isLoaded&&void 0!==this.props.reportBoundingBox){const xMin=this.props.bounds[0],yMin=this.props.bounds[1],zMin=1,xMax=this.props.bounds[2],yMax=this.props.bounds[3],zMax=-1;this.props.reportBoundingBox({layerBoundingBox:[xMin,yMin,zMin,xMax,yMax,zMax]})}const mergedModuleParams={...moduleParameters,valueDecoder:{...defaultProps.valueDecoder,...moduleParameters.valueDecoder},modelMatrix:(0,layerTools.pK)(this.props.rotDeg,this.props.bounds[0],this.props.bounds[3])};super.setModuleParameters(mergedModuleParams);const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,colormap=this.context.device.createTexture({width:256,height:1,format:"rgb8unorm-webgl",data:getImageData(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction)});this.state.model?.setBindings({colormap:colormap}),super.draw({uniforms:{...uniforms,valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax},moduleParameters:mergedModuleParams})}getShaders(){const parentShaders=super.getShaders();return parentShaders.fs="#version 300 es\n#define SHADER_NAME colormap-shader\n\nprecision highp float;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nuniform sampler2D bitmapTexture; // Property map\nuniform sampler2D colormap;\n\nuniform float opacity;\n\nvoid main(void) {\n  vec4 bitmapColor = texture(bitmapTexture, vTexCoord);\n\n  // If it's a picking pass, we just return the raw property map value.\n  if (picking.isActive > 0.5) {\n    fragColor = bitmapColor;\n    return;\n  }\n\n  // Decode the RGB value into a float. See decoder.fs.glsl for more details.\n  float val = decode_rgb2float(bitmapColor.rgb);\n  // The resulting val will be in [0, 1] interval, so we can use it directly as a texture coord\n  // to sample from the colormap.\n  // 0 => Leftmost color in the colormap, 1 => rightmost color, linearly interpolated in between.\n  vec4 color = texture(colormap, vec2(val, 0.5));\n\n  // The final pixel opacity is the combination of the user provided image-wide opacity,\n  // the colormap opacity at the sampled pixel and the property map opacity of the sampled pixel.\n  fragColor = vec4(color.rgb, color.a * bitmapColor.a * opacity);\n\n  // Support for existing functionality that comes from the BitmapLayer, such as desaturate, tintColor etc.\n  // See https://deck.gl/docs/api-reference/layers/bitmap-layer#render-options for more details.\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n\n}\n",parentShaders.modules.push(shader_modules.D0),parentShaders}getPickingInfo({info:info}){if(!info.color)return info;const mergedDecoder={...defaultProps.valueDecoder,...this.props.valueDecoder},val=decodeRGB(info.color,mergedDecoder,this.props.valueRange);return{...info,index:0,propertyValue:val}}getLegendData(){const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1;return{discrete:!1,valueRange:[this.props.colorMapRange?.[0]??valueRangeMin,this.props.colorMapRange?.[1]??valueRangeMax],colorName:this.props.colorMapName,title:"PropertyMapLayer",colorMapFunction:this.props.colorMapFunction}}}ColormapLayer.layerName="ColormapLayer",ColormapLayer.defaultProps=defaultProps;var mapLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/map/mapLayer.ts"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),workerpool=__webpack_require__("./node_modules/workerpool/dist/workerpool.js"),workerpool_default=__webpack_require__.n(workerpool),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js"),webgl_constants=__webpack_require__("./node_modules/@luma.gl/constants/dist/webgl-constants.js"),model_model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js");const privateTriangleLayer_defaultProps={data:["dummy"],contours:[-1,-1],isContoursDepth:!0,gridLines:!1,color:[100,100,255],coordinateSystem:constants.rf.CARTESIAN,depthTest:!0,ZIncreasingDownwards:!0};class PrivateTriangleLayer extends lib_layer.A{get isLoaded(){return this.state.isLoaded??!1}initializeState(context){const gl=context.device,[triangleModel,lineModel]=this._getModels(gl);this.setState({models:[triangleModel,lineModel],isLoaded:!1})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(device){return[new model_model.K(device,{id:`${this.props.id}-mesh`,vs:"#version 300 es\n#define SHADER_NAME vertex-shader\n\nprecision highp float;\n\n// Primitive attributes\nin vec3 positions;\nin float properties;\nin vec3 normals;\n\n// Outputs to fragment shader\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec3 worldPos;\nout float property;\n\nuniform bool ZIncreasingDownwards;\n\nconst vec3 pickingColor = vec3(1.0, 1.0, 0.0);\n\nvoid main(void) {\n   geometry.pickingColor = pickingColor;\n\n   cameraPosition = project_uCameraPosition;\n\n   vec3 position = positions;\n   position[2] *= ZIncreasingDownwards ? -1.0 : 1.0;\n\n   worldPos = position;\n\n   normals_commonspace = normals;\n\n   property = properties;\n\n   position_commonspace = vec4(project_position(position), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n   DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n   vec4 color = vec4(0.0);\n   DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:'#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec3 worldPos;\nin float property;\n\nuniform vec4 uColor;\nuniform bool smoothShading;\n\nout vec4 fragColor;\n\nvoid main(void) {\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n\n   vec4 color = uColor;\n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val = (abs(worldPos.z) - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use two sided phong lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = getPhongLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',geometry:new geometry.V(this.props.geometryTriangles),modules:[project32.A,picking.A,shader_modules.oS],isInstanced:!1}),new model_model.K(device,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nuniform bool ZIncreasingDownwards;\n\nvoid main(void) {\n   vec3 position = positions;\n   position[2] *= ZIncreasingDownwards ? -1.0 : 1.0;\n\n   vec3 position_commonspace = project_position(position);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n\n  // Picking pass.\n  if (picking.isActive > 0.5) {\n    discard;\n    return;\n  }\n\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.V(this.props.geometryLines),modules:[project32.A,picking.A],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{uniforms:uniforms,context:context}=args,{gl:gl}=context,contourReferencePoint=this.props.contours[0]??-1,contourInterval=this.props.contours[1]??-1,[triangleModel,lineModel]=this.state.models,smoothShading=this.props.smoothShading,uColor=this.props.color.map((x=>(x??0)/255));uColor.push(1),this.props.depthTest||gl.disable(webgl_constants.GL.DEPTH_TEST),gl.enable(webgl_constants.GL.POLYGON_OFFSET_FILL),gl.polygonOffset(1,1),triangleModel.setUniforms({uniforms:uniforms,contourReferencePoint:contourReferencePoint,contourInterval:contourInterval,smoothShading:smoothShading,uColor:uColor,ZIncreasingDownwards:this.props.ZIncreasingDownwards}),triangleModel.draw(context.renderPass),gl.disable(webgl_constants.GL.POLYGON_OFFSET_FILL),this.props.gridLines&&(lineModel.setUniforms({uniforms:uniforms,ZIncreasingDownwards:this.props.ZIncreasingDownwards}),lineModel.draw(context.renderPass)),this.props.depthTest||gl.enable(webgl_constants.GL.DEPTH_TEST),this.state.isLoaded||this.setState({...this.state,isLoaded:!0})}decodePickingColor(){return 0}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1;if(void 0!==info.coordinate?.[2]){const depth=(this.props.ZIncreasingDownwards?-info.coordinate[2]:info.coordinate[2])/Math.max(.001,zScale);layer_properties.push((0,layerTools.e2)("Depth",depth))}return{...info,properties:layer_properties}}}function makeFullMesh(e){const params=e.data,t0=performance.now();function normalize(a){const L=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);a[0]/=L,a[1]/=L,a[2]/=L}const line_positions=[],vertexArray=params.vertexArray,indexArray=params.indexArray,ntriangles=indexArray.length/3,nvertices=vertexArray.length/3,trianglesNormals=Array(3*ntriangles).fill(0),vertexsNormals=Array(vertexArray.length).fill(0);for(let t_no=0;t_no<ntriangles;t_no++){let indx=indexArray[3*t_no+0];const x0=vertexArray[3*indx+0],y0=vertexArray[3*indx+1],z0=vertexArray[3*indx+2];indx=indexArray[3*t_no+1];const x1=vertexArray[3*indx+0],y1=vertexArray[3*indx+1],z1=vertexArray[3*indx+2];indx=indexArray[3*t_no+2];const x2=vertexArray[3*indx+0],y2=vertexArray[3*indx+1],z2=vertexArray[3*indx+2];line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1),line_positions.push(x0,y0,z0),line_positions.push(x2,y2,z2),line_positions.push(x1,y1,z1),line_positions.push(x2,y2,z2);const normal=[(a=[x2-x1,y2-y1,z2-z1])[1]*(b=[x2-x0,y2-y0,z2-z0])[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];trianglesNormals[3*t_no+0]=normal[0],trianglesNormals[3*t_no+1]=normal[1],trianglesNormals[3*t_no+2]=normal[2]}var a,b;const vertexTrianglesArray=Array(vertexArray.length/3);for(let i=0;i<vertexTrianglesArray.length;i++)vertexTrianglesArray[i]=new Array(0);for(let t_no=0;t_no<ntriangles;t_no++){vertexTrianglesArray[indexArray[3*t_no+0]].push(t_no);vertexTrianglesArray[indexArray[3*t_no+1]].push(t_no);vertexTrianglesArray[indexArray[3*t_no+2]].push(t_no)}for(let vertex_no=0;vertex_no<nvertices;vertex_no++){const n_triangles=vertexTrianglesArray[vertex_no].length,t0=vertexTrianglesArray[vertex_no][0],normal_mean=[trianglesNormals[3*t0+0],trianglesNormals[3*t0+1],trianglesNormals[3*t0+2]];for(let t_no=1;t_no<n_triangles;t_no++){const t=vertexTrianglesArray[vertex_no][t_no],normal=[trianglesNormals[3*t+0],trianglesNormals[3*t+1],trianglesNormals[3*t+2]];normal_mean[0]+=normal[0],normal_mean[1]+=normal[1],normal_mean[2]+=normal[2]}normalize(normal_mean),vertexsNormals[3*vertex_no+0]=normal_mean[0],vertexsNormals[3*vertex_no+1]=normal_mean[1],vertexsNormals[3*vertex_no+2]=normal_mean[2];if(params.displayNormals){const x0=vertexArray[3*vertex_no+0],y0=vertexArray[3*vertex_no+1],z0=vertexArray[3*vertex_no+2],scale=50,x1=x0+normal_mean[0]*scale,y1=y0+normal_mean[1]*scale,z1=z0+normal_mean[2]*scale;line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1)}}const geometryTriangles={topology:"triangle-list",attributes:{positions:{value:new Float32Array(vertexArray),size:3},normals:{value:new Float32Array(vertexsNormals),size:3},vertex_indexs:{value:new Int32Array(indexArray),size:1}},vertexCount:indexArray.length,indices:{value:new Uint32Array(indexArray),size:1}},geometryLines={topology:"line-list",attributes:{positions:{value:new Float32Array(line_positions),size:3}},vertexCount:line_positions.length/3},t1=performance.now();return console.debug(`Task makeMesh took ${.001*(t1-t0)} seconds.`),[geometryTriangles,geometryLines]}PrivateTriangleLayer.layerName="privateTriangleLayer",PrivateTriangleLayer.defaultProps=privateTriangleLayer_defaultProps;var SubsurfaceConfig=__webpack_require__("./packages/subsurface-viewer/src/SubsurfaceConfig.json");const workerPoolConfig=(0,__webpack_require__("./packages/subsurface-viewer/src/utils/configTools.ts").u)(SubsurfaceConfig,"config/workerpool","config/layer/TriangleLayer/workerpool"),pool=workerpool_default().pool({maxWorkers:10,workerType:"web",...workerPoolConfig});class TriangleLayer extends composite_layer.A{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinishedLoading=this.state?.isFinishedLoading;return isLoaded&&(isFinishedLoading??!1)}rebuildData(reportBoundingBox){const p=async function loadData(pointsData,triangleData){let indexArray,vertexArray=new Float32Array;if(Array.isArray(pointsData))vertexArray=new Float32Array(pointsData);else if(pointsData instanceof Float32Array)vertexArray=pointsData;else{const response_mesh=await fetch(pointsData);response_mesh.ok||console.error("Could not load vertex data");const blob_mesh=await response_mesh.blob(),buffer=await blob_mesh.arrayBuffer();vertexArray=new Float32Array(buffer)}if(Array.isArray(triangleData))indexArray=new Uint32Array(triangleData);else if(triangleData instanceof Uint32Array)indexArray=triangleData;else{const response_mesh=await fetch(triangleData);response_mesh.ok||console.error("Could not load triangle index data");const blob_mesh=await response_mesh.blob(),buffer=await blob_mesh.arrayBuffer();indexArray=new Uint32Array(buffer)}return Promise.all([vertexArray,indexArray])}(this.props.pointsData,this.props.triangleData);p.then((([vertexArray,indexArray])=>{const webworkerParams={vertexArray:vertexArray,indexArray:indexArray,smoothShading:this.props.smoothShading,displayNormals:this.props.debug};pool.exec(makeFullMesh,[{data:webworkerParams}]).then((e=>{const[geometryTriangles,geometryLines]=e;if(this.setState({geometryTriangles:geometryTriangles,geometryLines:geometryLines}),void 0!==this.props.reportBoundingBox&&reportBoundingBox){let xmax=-99999999,xmin=99999999,ymax=-99999999,ymin=99999999,zmax=-99999999,zmin=99999999;for(let i=0;i<vertexArray.length/3;i++)xmax=vertexArray[3*i+0]>xmax?vertexArray[3*i+0]:xmax,xmin=vertexArray[3*i+0]<xmin?vertexArray[3*i+0]:xmin,ymax=vertexArray[3*i+1]>ymax?vertexArray[3*i+1]:ymax,ymin=vertexArray[3*i+1]<ymin?vertexArray[3*i+1]:ymin,zmax=vertexArray[3*i+2]>zmax?vertexArray[3*i+2]:zmax,zmin=vertexArray[3*i+2]<zmin?vertexArray[3*i+2]:zmin;if(this.props.ZIncreasingDownwards){const tmp=zmin;zmin=zmax,zmax=tmp}this.props.reportBoundingBox({layerBoundingBox:[xmin,ymin,zmin,xmax,ymax,zmax]})}this.setState({...this.state,isFinishedLoading:!0}),function onTerminateWorker(){const stats=pool.stats();0===stats.busyWorkers&&0===stats.pendingTasks&&pool.terminate()}()}))}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.debug,oldProps.debug)&&(0,lodash.isEqual)(props.pointsData,oldProps.pointsData)&&(0,lodash.isEqual)(props.triangleData,oldProps.triangleData)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];return[new PrivateTriangleLayer(this.getSubLayerProps({geometryTriangles:this.state.geometryTriangles,geometryLines:this.state.geometryLines,pickable:this.props.pickable,contours:this.props.contours,gridLines:this.props.gridLines,color:this.props.color,material:this.props.material,smoothShading:this.props.smoothShading,depthTest:this.props.depthTest,ZIncreasingDownwards:this.props.ZIncreasingDownwards}))]}}TriangleLayer.layerName="TriangleLayer",TriangleLayer.defaultProps={"@@type":"TriangleLayer",name:"TriangleLayer",id:"triangle-layer",pickable:!0,visible:!0,contours:[-1,-1],color:[100,100,255],gridLines:!1,smoothShading:!0,material:!0,depthTest:!0,ZIncreasingDownwards:!0,debug:!1};var scatterplot_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js");class PrivatePointsLayer extends scatterplot_layer.A{constructor(props){super(props)}getShaders(){return{...super.getShaders(),vs:"#version 300 es\n#define SHADER_NAME points-layer-vertex-shader\n\nin vec3 positions;\n\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\nuniform bool ZIncreasingDownwards;\n\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\n\n\nvoid main(void) {\n  vec3 position = instancePositions;\n  vec3 position64low = instancePositions64Low;\n\n  if(ZIncreasingDownwards) {\n    position.z *= -1.0;\n    position64low.z *= -1.0;\n  }\n  geometry.worldPosition = position;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(position, position64low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(position, position64low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n"}}draw(args){args.uniforms.ZIncreasingDownwards=this.props.ZIncreasingDownwards;let restoreDepthTest=!1;"boolean"!=typeof this.props.depthTest||this.props.depthTest||(restoreDepthTest=!0,this.context.gl.disable(webgl_constants.GL.DEPTH_TEST)),super.draw({uniforms:args.uniforms}),restoreDepthTest&&this.context.gl.enable(webgl_constants.GL.DEPTH_TEST)}}PrivatePointsLayer.layerName="PrivatePointsLayer";class PointsLayer extends composite_layer.A{constructor(props){super(props)}renderLayers(){return[new PrivatePointsLayer(this.getSubLayerProps({pickable:this.props.pickable,billboard:!0,data:this.state.dataAttributes,_pathType:"open",getFillColor:()=>this.props.color,getRadius:()=>this.props.pointRadius,radiusUnits:this.props.radiusUnits,updateTriggers:{getFillColor:[this.props.color],getRadius:[this.props.pointRadius]},depthTest:this.props.depthTest,ZIncreasingDownwards:this.props.ZIncreasingDownwards}))]}initializeState(){const dataAttributes=this.rebuildDataAttributes(!0);this.setState({dataAttributes:dataAttributes})}updateState({props:props,oldProps:oldProps}){if(!(0,lodash.isEqual)(props.pointsData,oldProps.pointsData)){const dataAttributes=this.rebuildDataAttributes(!1);this.setState({dataAttributes:dataAttributes})}props.ZIncreasingDownwards!=oldProps.ZIncreasingDownwards&&this.updateBoundingBox(!0)}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1;if(void 0!==info.coordinate?.[2]){const depth=(this.props.ZIncreasingDownwards?-info.coordinate[2]:info.coordinate[2])/Math.max(.001,zScale);layer_properties.push((0,layerTools.e2)("Depth",depth))}return{...info,properties:layer_properties}}rebuildDataAttributes(reportBoundingBox){const dataArray=this.loadData();return dataArray?(this.updateBoundingBox(reportBoundingBox),{length:dataArray.length/3,attributes:{getPosition:{value:dataArray,size:3}}}):null}loadData(){return Array.isArray(this.props.pointsData)?new Float32Array(this.props.pointsData):this.props.pointsData instanceof Float32Array?this.props.pointsData:(console.warn("pointsData is not array"),new Float32Array)}updateBoundingBox(reportBoundingBox){if(this.state.dataAttributes&&"function"==typeof this.props.reportBoundingBox&&reportBoundingBox){const boundingBox=(0,layerTools.dL)(this.state.dataAttributes,this.props.ZIncreasingDownwards);this.props.reportBoundingBox({layerBoundingBox:boundingBox})}}}PointsLayer.layerName="PointsLayer",PointsLayer.defaultProps={"@@type":"PointsLayer",name:"PointsLayer",id:"points-layer",color:[125,0,0,255],radiusUnits:"pixels",pointRadius:5,pickable:!0,visible:!0,ZIncreasingDownwards:!0,depthTest:!0};var polylinesLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/polylines/polylinesLayer.ts"),editable_layers_dist=__webpack_require__("./node_modules/@deck.gl-community/editable-layers/dist/index.js"),main_es=__webpack_require__("./node_modules/@turf/meta/main.es.js");function measurement_length(geojson){return(0,main_es.OQ)(geojson,(function(previousValue,segment){if(void 0===segment||void 0===previousValue)return 0;const coords=segment.geometry.coordinates;return previousValue+function distance(from,to){const[x1,y1,z1]=from,[x2,y2,z2]=to;let a=Math.pow(x1-x2,2)+Math.pow(y1-y2,2);z1&&z2&&(a+=Math.pow(z2-z1,2));return Math.sqrt(a)}(coords[0],coords[1])}),0)}function measurement_area(geojson){return(0,main_es.jE)(geojson,(function(value,geom){return value+function calculateArea(geom){const coords=geom.coordinates[0];let total=0;for(let i=0,l=coords.length;i<l;i++){total+=coords[i][0]*coords[i==coords.length-1?0:i+1][1]*.5,total-=coords[i==coords.length-1?0:i+1][0]*coords[i][1]*.5}return Math.abs(total)}(geom)}),0)}class CustomModifyMode extends editable_layers_dist.uq{handleKeyUp(event,props){if(super.handleKeyUp(event,props),"Delete"===event.key){const updatedData=new editable_layers_dist.vA(props.data).deleteFeatures(props.selectedIndexes).getObject();updatedData&&props.onEdit({updatedData:updatedData,editType:"removeFeature",editContext:{featureIndexes:props.selectedIndexes}})}}}function deleteEscapeKeyHandler(drawMode,event,props){if("Escape"===event.key)drawMode.getClickSequence().pop();else{if("Delete"!==event.key)return;drawMode.resetClickSequence()}const updatedData=new editable_layers_dist.vA(props.data).getObject();updatedData&&props.onEdit({updatedData:updatedData,editType:"undoDrawing",editContext:{featureIndexes:props.selectedIndexes}})}class CustomDrawLineStringMode extends editable_layers_dist.DS{handleKeyUp(event,props){super.handleKeyUp(event,props),deleteEscapeKeyHandler(this,event,props)}}class CustomDrawPolygonMode extends editable_layers_dist.cR{handleKeyUp(event,props){super.handleKeyUp(event,props),deleteEscapeKeyHandler(this,event,props)}}const MODE_MAP={view:editable_layers_dist.nE,modify:CustomModifyMode,transform:editable_layers_dist._C,drawPoint:editable_layers_dist.i_,drawLineString:CustomDrawLineStringMode,drawPolygon:CustomDrawPolygonMode},UNSELECTED_LINE_COLOR=[80,80,80,204],SELECTED_LINE_COLOR=[0,0,0,255];class DrawingLayer extends composite_layer.A{initializeState(context){super.initializeState(context),this.setState({data:this.props.data,selectedFeatureIndexes:this.props.selectedFeatureIndexes})}onClick(info){return("view"===this.props.mode||"modify"===this.props.mode)&&(this.setState({selectedFeatureIndexes:[info.index]}),this.context.userData.setEditedData({selectedFeatureIndexes:[info.index]}),!0)}getPickingInfo({info:info}){if(!info.object)return info;const feature=info.object;let measurement;if("LineString"===feature.geometry?.type)measurement=measurement_length(feature);else{if("Polygon"!==feature.geometry?.type)return info;measurement=measurement_area(feature)}return{...info,propertyValue:measurement}}_onEdit(editAction){switch(editAction.editType){case"addFeature":this.setState({data:editAction.updatedData,selectedFeatureIndexes:editAction.editContext.featureIndexes}),this.context.userData.setEditedData({data:editAction.updatedData,selectedFeatureIndexes:editAction.editContext.featureIndexes});break;case"removeFeature":this.setState({data:editAction.updatedData,selectedFeatureIndexes:[]}),this.context.userData.setEditedData({data:editAction.updatedData,selectedFeatureIndexes:[]});break;case"removePosition":case"finishMovePosition":this.setState({data:editAction.updatedData}),this.context.userData.setEditedData({data:editAction.updatedData});break;case"movePosition":case"undoDrawing":this.setState({data:editAction.updatedData})}}_getLineColor(feature){const selectedFeatureIndexes=this.state.selectedFeatureIndexes,data=this.state.data;return selectedFeatureIndexes.some((i=>data.features[i]===feature))?SELECTED_LINE_COLOR:UNSELECTED_LINE_COLOR}renderLayers(){if(0==this.props.visible)return[];const sub_layer_props=this.getSubLayerProps({data:this.state.data,mode:MODE_MAP[this.props.mode],modeConfig:{viewport:this.context.viewport},selectedFeatureIndexes:this.state.selectedFeatureIndexes,coordinateSystem:constants.rf.CARTESIAN,onEdit:editAction=>this._onEdit(editAction),_subLayerProps:{geojson:{autoHighlight:!0,getLineColor:feature=>this._getLineColor(feature)}}});return[new editable_layers_dist.Tp(sub_layer_props)]}}DrawingLayer.layerName="DrawingLayer",DrawingLayer.defaultProps={"@@type":"DrawingLayer",name:"Drawing",id:"drawing-layer",pickable:!0,visible:!0,mode:"drawLineString",selectedFeatureIndexes:[],data:{type:"FeatureCollection",features:[]}};const hillshading2dLayer_defaultProps={"@@type":"Hillshading2DLayer",name:"Hill shading",id:"hillshading-layer",opacity:1,pickable:!0,visible:!0,rotDeg:0,valueRange:{type:"array",value:[0,1]},lightDirection:[1,1,1],ambientLightIntensity:.5,diffuseLightIntensity:.5,valueDecoder:{rgbScaler:[1,1,1],floatScaler:1/16777215,offset:0,step:0}};class Hillshading2DLayer extends bitmap_layer.A{initializeState(){super.initializeState()}draw({moduleParameters:moduleParameters,uniforms:uniforms}){if(!this.isLoaded&&void 0!==this.props.reportBoundingBox){const xMin=this.props.bounds[0],yMin=this.props.bounds[1],zMin=1,xMax=this.props.bounds[2],yMax=this.props.bounds[3],zMax=-1;this.props.reportBoundingBox({layerBoundingBox:[xMin,yMin,zMin,xMax,yMax,zMax]})}if(this.props.image){const mergedModuleParams={...moduleParameters,valueDecoder:{...hillshading2dLayer_defaultProps.valueDecoder,...moduleParameters.valueDecoder},modelMatrix:(0,layerTools.pK)(this.props.rotDeg,this.props.bounds[0],this.props.bounds[3])};super.setModuleParameters(mergedModuleParams);const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,[minVal,maxVal]=this.props.valueRange;super.draw({uniforms:{...uniforms,bitmapResolution:[this.props.image.width,this.props.image.height],valueRangeSize:maxVal-minVal,lightDirection:this.props.lightDirection,ambientLightIntensity:this.props.ambientLightIntensity,diffuseLightIntensity:this.props.diffuseLightIntensity,valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax},moduleParameters:mergedModuleParams})}}getShaders(){const parentShaders=super.getShaders();return parentShaders.fs="#version 300 es\n#define SHADER_NAME hillshading2d-shader\n\nprecision highp float;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nuniform sampler2D bitmapTexture; // Property map\nuniform vec2 bitmapResolution;\n\nuniform float valueRangeSize;\n\nuniform vec3 lightDirection;\nuniform float ambientLightIntensity;\nuniform float diffuseLightIntensity;\nuniform float opacity;\n\n// Compute the normal value for every pixel, based on the current value and two values aroud it.\nvec3 normal(float val) {\n  vec2 dr = 1.0 / bitmapResolution;\n  float p0 = valueRangeSize * val;\n\n  float px = valueRangeSize * decode_rgb2float(texture(bitmapTexture, vTexCoord + vec2(1.0, 0.0) / bitmapResolution).rgb);\n  float py = valueRangeSize * decode_rgb2float(texture(bitmapTexture, vTexCoord + vec2(0.0, 1.0) / bitmapResolution).rgb);\n  vec3 dx = vec3(1.0, 0.0, px - p0);\n  vec3 dy = vec3(0.0, 1.0, py - p0);\n\n  return normalize(cross(dx, dy));\n}\n\n// Compute how much a pixel is in the shadow based on its normal and where the light comes from.\nfloat shadow(vec3 normal) {\n  float diffuse = diffuseLightIntensity * dot(normal, normalize(lightDirection));\n  return clamp(ambientLightIntensity + diffuse, 0.0, 1.0);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture(bitmapTexture, vTexCoord);\n\n  // If it's a picking pass, we just return the raw property map value.\n  if (picking.isActive > 0.5) {\n    fragColor = bitmapColor;\n    return;\n  }\n\n  // Decode the RGB value into a float. See decoder.fs.glsl for more details.\n  float val = decode_rgb2float(bitmapColor.rgb);\n  // Compute the shadow value, how dark a pixel will be, 1 is in complete shadow, 0 is in complete light.\n  float shadow = shadow(normal(val));\n\n  // The final pixel is black, with the opacity based on the shadow value,\n  // opacity 0 if pixel is completely in the light, opacity 1 if pixel is completely in the shadow.\n  // The property map opacity (some portions of the property map can be transparent) and\n  // the user provided image-wide opacity value are also taken into account.\n  fragColor = vec4(vec3(0.0), (1.0-shadow) * bitmapColor.a * opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",parentShaders.modules.push(shader_modules.D0),parentShaders}getPickingInfo({info:info}){if(!info.color)return info;const mergedDecoder={...hillshading2dLayer_defaultProps.valueDecoder,...this.props.valueDecoder},val=decodeRGB(info.color,mergedDecoder,this.props.valueRange);return{...info,index:0,propertyValue:val}}}Hillshading2DLayer.layerName="Hillshading2DLayer",Hillshading2DLayer.defaultProps=hillshading2dLayer_defaultProps;var wellsLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project/project.js");const vertex_glsl_vsShader="#version 300 es\n#define SHADER_NAME well-markers-vertex-shader\nprecision highp float;\n\nin vec3 positions;\nin vec3 instancePositions;\nin float instanceSizes;\nin float instanceAzimuths;\nin float instanceInclinations;\nin vec4 instanceColors;\nin vec4 instanceOutlineColors;\nin vec3 instancePickingColors;\n\nuniform int sizeUnits;\nuniform bool ZIncreasingDownwards;\nuniform bool useOutlineColor;\n\nout vec4 color;\n\nvoid main(void) {\n   vec3 position = instancePositions;\n   position.z *= (ZIncreasingDownwards? -1.0 : 1.0);\n\n   geometry.worldPosition = position;\n   geometry.pickingColor  = instancePickingColors;\n\n   color = useOutlineColor ? instanceOutlineColors : instanceColors;\n\n   float sizeInPixels = project_size_to_pixel(instanceSizes, sizeUnits);\n   float projectedSize = project_pixel_size(sizeInPixels);\n\n   float sinA = sin (PI / 180.0 * instanceAzimuths);\n   float cosA = cos (PI / 180.0 * instanceAzimuths);\n\n   float sinI = sin (PI / 180.0 * instanceInclinations);\n   float cosI = cos (PI / 180.0 * instanceInclinations);\n\n   mat3 azimuthMatrix = mat3(vec3(cosA, sinA, 0.0), vec3(-sinA, cosA, 0.0), vec3(0.0, 0.0, 1.0));\n   mat3 inclMatrix    = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cosI, sinI), vec3(0.0, -sinI, cosI));\n   mat3 sizeMatrix    = mat3(vec3(projectedSize, 0.0, 0.0), vec3(0.0, projectedSize, 0.0), vec3(0.0, 0.0, 1.0));\n   vec3 rotatedPos    = azimuthMatrix * inclMatrix * sizeMatrix *positions;\n\n   vec4 position_commonspace = vec4(project_position(rotatedPos + position), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n   vec4 dummyColor = vec4(0.0);\n\n   DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n   DECKGL_FILTER_COLOR(dummyColor, geometry);\n}\n",fragment_glsl_fsShader="#version 300 es\n#define SHADER_NAME well-markers-fragment-shader\n\nprecision highp float;\n\nin vec4 color;\n\nout vec4 fragColor;\n\nvoid main(void) {\n   fragColor = vec4(color.rgba * (1.0 / 255.0));\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",normalizeColor=color=>{if(!color)return new Uint8Array([0,0,0,255]);if(color.length>4)return new Uint8Array(color.slice(0,4));switch(color.length){case 0:return new Uint8Array([0,0,0,255]);case 1:return new Uint8Array([...color,0,0,255]);case 2:return new Uint8Array([...color,0,255]);case 3:return new Uint8Array([...color,255]);default:return color}},wellMarkersLayer_defaultProps={"@@type":"WellMarkersLayer",name:"Well Markers",id:"well-markers",shape:"circle",sizeUnits:"meters",visible:!0,ZIncreasingDownwards:!0,getPosition:{type:"accessor",value:x=>x.position},getSize:{type:"accessor",value:x=>x.size},getAzimuth:{type:"accessor",value:x=>x.azimuth},getInclination:{type:"accessor",value:x=>x.inclination},getColor:{type:"accessor",value:x=>normalizeColor(x.color)},getOutlineColor:{type:"accessor",value:x=>normalizeColor(x.outlineColor)}};class WellMarkersLayer extends lib_layer.A{shapes=new Map;constructor(props){super(props),this.initShapes()}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",transition:!0,accessor:"getPosition"},instanceSizes:{size:1,type:"float64",transition:!0,accessor:"getSize",defaultValue:1},instanceAzimuths:{size:1,type:"float64",transition:!0,accessor:"getAzimuth",defaultValue:0},instanceInclinations:{size:1,type:"float64",transition:!0,accessor:"getInclination",defaultValue:0},instanceColors:{size:4,type:"uint8",transition:!0,accessor:"getColor",defaultValue:[255,0,0,255]},instanceOutlineColors:{size:4,type:"uint8",transition:!0,accessor:"getOutlineColor",defaultValue:[255,0,255,255]}});const models=this._createModels();this.setState({shapeModel:models[0],outlineModel:models[1]})}updateState(params){if(super.updateState(params),params.changeFlags.extensionsChanged||params.changeFlags.propsChanged){const oldShapeModel=this.state?.shapeModel;oldShapeModel.destroy();const oldOutlineModel=this.state?.outlineModel;oldOutlineModel.destroy();const models=this._createModels();this.setState({...this.state,shapeModel:models[0],outlineModel:models[1]}),this.getAttributeManager().invalidateAll()}}getModels(){return this.state.shapeModel&&this.state.outlineModel?[this.state.shapeModel,this.state.outlineModel]:[]}draw(args){if(!this.state.shapeModel)return;const{uniforms:uniforms}=args,models=this.getModels();models.length&&models.length<2||(models[0].setUniforms({...uniforms,sizeUnits:constants.p5[this.props.sizeUnits],ZIncreasingDownwards:this.props.ZIncreasingDownwards}),models[0].draw(args.context.renderPass),models[1].setUniforms({...uniforms,ZIncreasingDownwards:this.props.ZIncreasingDownwards,sizeUnits:constants.p5[this.props.sizeUnits]}),models[1].draw(args.context.renderPass))}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],markerIndex=this.decodePickingColor(info.color),markerData=this.props.data;if(markerIndex>=0&&markerIndex<markerData.length&&(layer_properties.push((0,layerTools.e2)("Azimuth",markerData[markerIndex].azimuth)),layer_properties.push((0,layerTools.e2)("Inclination",markerData[markerIndex].inclination))),void 0!==info.coordinate?.[2]){let depth=info.coordinate[2];depth=this.props.ZIncreasingDownwards?-depth:depth,layer_properties.push((0,layerTools.e2)("Depth",depth))}return{...info,properties:layer_properties}}getShaders(){return super.getShaders({vs:vertex_glsl_vsShader,fs:fragment_glsl_fsShader,modules:[project.A,picking.A,shader_modules.BF]})}initShapes(){const triangle_positions=[-1,-1,0,1,-1,0,0,1,0],circle_positions=[0,0,0];for(let i=0;i<=32;++i){const angle=2*Math.PI/32*i;circle_positions.push(1*Math.cos(angle)),circle_positions.push(1*Math.sin(angle)),circle_positions.push(0)}this.shapes.set("triangle",{drawMode:"triangle-list",positions:new Float32Array(triangle_positions),outline:new Float32Array(triangle_positions)}),this.shapes.set("circle",{drawMode:"triangle-fan-webgl",positions:new Float32Array(circle_positions),outline:new Float32Array(circle_positions.slice(3))}),this.shapes.set("square",{drawMode:"triangle-strip",positions:new Float32Array([-1,1,0,1,1,0,-1,-1,0,1,-1,0]),outline:new Float32Array([-1,1,0,1,1,0,1,-1,0,-1,-1,0])})}_createModels(){const device=this.context.device,shape=this.shapes.get(this.props.shape);if(!shape)return this._createEmptyModels();const shaders=this.getShaders();return[new model_model.K(device,{id:`${this.props.id}-mesh`,...shaders,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new geometry.V({topology:shape.drawMode,attributes:{positions:{size:3,value:shape.positions}}}),uniforms:{useOutlineColor:!1},isInstanced:!0,instanceCount:this.getNumInstances()}),new model_model.K(device,{id:`${this.props.id}-outline`,...shaders,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new geometry.V({topology:"line-loop-webgl",attributes:{positions:{size:3,value:shape.outline}}}),uniforms:{useOutlineColor:!0},isInstanced:!0,instanceCount:this.getNumInstances()})]}_createEmptyModels(){return[new model_model.K(this.context.device,{id:`${this.props.id}-empty-mesh`,vs:vertex_glsl_vsShader,fs:fragment_glsl_fsShader,isInstanced:!0,instanceCount:0}),new model_model.K(this.context.device,{id:`${this.props.id}-empty-outline`,vs:vertex_glsl_vsShader,fs:fragment_glsl_fsShader,isInstanced:!0,instanceCount:0})]}}WellMarkersLayer.layerName="WellMarkersLayer",WellMarkersLayer.defaultProps=wellMarkersLayer_defaultProps;var vector2=__webpack_require__("./node_modules/@math.gl/core/dist/classes/vector2.js");class PieChartLayer extends lib_layer.A{initializeState(){}shouldUpdateState(){return!0}updateState({context:context}){if(!this.state?.model){const pieData=this.props.data;pieData?.pies&&this.setState(this.getModel(context.device,pieData))}}getModel(device,pieData){const vertexs=[],colors=[],mx=[],my=[],doScale=[],pieInfo=[],pieInfoIndex=[];let infoIndex=0;for(const pie of pieData.pies){const x=pie.x,y=pie.y,R=pie.R;let sum=0;for(const frac of pie.fractions)sum+=frac.value;if(0===sum)continue;let start_a=-90;for(let i=0;i<pie.fractions.length;i++){const frac=pie.fractions[i].value/sum,end_a=start_a+360*frac,prop=pieData.properties[pie.fractions[i].idx];let col=prop?.color??[255,0,255,255];col=col.map((x=>(x??0)/255));const name=prop?.label??"no label",frac_string=(100*frac).toFixed(1)+"%";pieInfo.push([name,frac_string]);for(let a=start_a;a<end_a;a+=5){const a1=a,rad1=a1*(2*Math.PI)/360,xx1=R*Math.cos(rad1)+x,yy1=R*Math.sin(rad1)+y,rad2=Math.min(a1+5,end_a)*(2*Math.PI)/360,xx2=R*Math.cos(rad2)+x,yy2=R*Math.sin(rad2)+y;vertexs.push(x,y,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(0),vertexs.push(xx1,yy1,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(1),vertexs.push(xx2,yy2,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(1)}infoIndex++,start_a=end_a}}return{model:new model_model.K(device,{id:`${this.props.id}-pie`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin vec3 positions;\nin vec3 colors;\nin float do_scale;\nin float mx;\nin float my;\nin int pie_index;\n\nflat out int pie_index_;\n\nuniform float scale;\n\nout vec4 vColor;\n\nvoid main(void) {\n\n   vec3 v = positions;\n\n   if (do_scale == 1.0) {\n      // Triangle vertex' are (mx,my) and two more. The\n      // latter two will be scaled so that the triangle (or the pie piece its part of) will\n      // have constant size depending on zoom.\n      float x = scale * (positions.x - mx);\n      float y = scale * (positions.y - my);\n\n      v = vec3(x + mx, y + my, 0.0);\n   }\n\n   vec3 position_commonspace = project_position(v);\n\n   vColor = vec4(colors.rgb, 1.0);\n\n   pie_index_ = pie_index;\n\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nflat in int pie_index_;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n\nvoid main(void) {\n\n  //Picking pass.\n  if (picking.isActive > 0.5) {\n     // Express triangle index in 255 system.\n     float r = 0.0;\n     float g = 0.0;\n     float b = 0.0;\n \n     int idx = pie_index_;\n \n     if (idx >= (256 * 256) - 1) {\n        r = floor(float(idx) / (256.0 * 256.0));\n        idx -= int(r * (256.0 * 256.0));\n     }\n \n     if (idx >= 256 - 1) {\n        g = floor(float(idx) / 256.0);\n        idx -= int(g * 256.0);\n     }\n \n     b = float(idx);\n \n     fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n     return;\n  }\n\n  fragColor = vColor;\n}\n",geometry:new geometry.V({topology:"triangle-list",attributes:{positions:{value:new Float32Array(vertexs),size:3},colors:{value:new Float32Array(colors),size:3},pie_index:{value:new Int32Array(pieInfoIndex),size:1},mx:{value:new Float32Array(mx),size:1},my:{value:new Float32Array(my),size:1},do_scale:{value:new Float32Array(doScale),size:1}},vertexCount:vertexs.length/3}),modules:[project32.A,picking.A],isInstanced:!1}),pieInfo:pieInfo}}draw(args){if(!this.state?.model)return;const{context:context}=args,{gl:gl}=context,p2=[100,0],p1_unproj=this.context.viewport.unproject([0,0]),p2_unproj=this.context.viewport.unproject(p2),v1=new vector2.I(p1_unproj[0],p1_unproj[1]),v2=new vector2.I(p2_unproj[0],p2_unproj[1]),scale=v1.distance(v2)/100,model=this.state.model;this.props.depthTest||gl.disable(webgl_constants.GL.DEPTH_TEST),model.setUniforms({scale:scale}),model.draw(context.renderPass),this.props.depthTest||gl.enable(webgl_constants.GL.DEPTH_TEST)}decodePickingColor(){return this.nullPickingColor()}getPickingInfo({info:info}){if(!info.color)return info;const pieIndex=65536*info.color[0]+256*info.color[1]+info.color[2],pieInfo=this.state.pieInfo,[pie_label,pie_frac]=pieInfo[pieIndex],layer_properties=[];return layer_properties.push((0,layerTools.e2)(pie_label,pie_frac)),{...info,properties:layer_properties}}}PieChartLayer.layerName="PieChartLayer",PieChartLayer.defaultProps={"@@type":"PieChartLayer",name:"Pie chart",id:"pie-layer",pickable:!0,visible:!0,selectedPie:"@@editedData.selectedPie",depthTest:!0};var geojson_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js");const getColor=d=>{const c=d?.properties?.color;return[c[0]??0,c[1]??0,c[2]??0,30]};class FaultPolygonsLayer extends composite_layer.A{renderLayers(){return[new geojson_layer.A(this.getSubLayerProps({id:this.props.id,data:this.props.data,pickable:this.props.pickable,visible:this.props.visible,filled:this.props.filled,lineWidthMinPixels:this.props.lineWidthMinPixels,coordinateSystem:constants.rf.CARTESIAN,getLineColor:d=>d?.properties?.color??[0,0,0,255],getFillColor:getColor,parameters:{depthTest:this.props.depthTest}}))]}}FaultPolygonsLayer.layerName="FaultPolygonsLayer",FaultPolygonsLayer.defaultProps={"@@type":"FaultPolygonsLayer",name:"Fault polygons",id:"fault-polygons-layer",pickable:!0,visible:!0,filled:!0,lineWidthMinPixels:2,depthTest:!0};var axesLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/axes/axesLayer.ts"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js"),load=__webpack_require__("./node_modules/@loaders.gl/core/dist/lib/api/load.js"),image_loader=__webpack_require__("./node_modules/@loaders.gl/images/dist/image-loader.js"),vec4=__webpack_require__("./node_modules/gl-matrix/esm/vec4.js"),font_atlas_namespaceObject=__webpack_require__.p+"static/media/font-atlas.72792226.png",line_fragment_glsl="#version 300 es\n#define SHADER_NAME axes2dlayer-line-fragment-shader\n\nprecision highp float;\n\nuniform vec4 uColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",line_vertex_glsl="#version 300 es\n#define SHADER_NAME axes2dlayer-line-vertex-shader\n\nprecision highp float;\n\nuniform float uClipZ;\n\nin vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   vec4 position_clipspace = project_common_position_to_clipspace(vec4(position_commonspace, 1.0));\n   gl_Position = vec4(position_clipspace.x, position_clipspace.y, uClipZ, position_clipspace.w);\n}\n",TEXT_ANCHOR=function(TEXT_ANCHOR){return TEXT_ANCHOR[TEXT_ANCHOR.start=0]="start",TEXT_ANCHOR[TEXT_ANCHOR.middle=1]="middle",TEXT_ANCHOR[TEXT_ANCHOR.end=2]="end",TEXT_ANCHOR}(TEXT_ANCHOR||{}),ALIGNMENT_BASELINE=function(ALIGNMENT_BASELINE){return ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.top=1]="top",ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.center=0]="center",ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.bottom=-1]="bottom",ALIGNMENT_BASELINE}(ALIGNMENT_BASELINE||{}),ViewSide=function(ViewSide){return ViewSide[ViewSide.Left=0]="Left",ViewSide[ViewSide.Right=1]="Right",ViewSide[ViewSide.Bottom=2]="Bottom",ViewSide[ViewSide.Top=3]="Top",ViewSide}(ViewSide||{});const axes2DLayer_defaultProps={"@@type":"Axes2DLayer",name:"Axes2D",id:"axes2d-layer",visible:!0,coordinateSystem:constants.rf.CARTESIAN,marginH:80,marginV:30,isLeftRuler:!0,isRightRuler:!1,isBottomRuler:!0,isTopRuler:!1,labelFontSizePt:9},fontInfo={letterHeight:92,spaceWidth:0,spacing:-1,textureWidth:1714,textureHeight:200,glyphInfos:{A:{x:0,y:0,width:86},B:{x:86,y:0,width:86},C:{x:172,y:0,width:86},D:{x:258,y:0,width:86},E:{x:344,y:0,width:86},F:{x:430,y:0,width:86},G:{x:516,y:0,width:86},H:{x:602,y:0,width:86},I:{x:688,y:0,width:86},J:{x:774,y:0,width:86},K:{x:860,y:0,width:86},L:{x:946,y:0,width:86},M:{x:1032,y:0,width:86},N:{x:1118,y:0,width:86},O:{x:1204,y:0,width:86},P:{x:1290,y:0,width:86},Q:{x:1376,y:0,width:86},R:{x:1462,y:0,width:86},S:{x:1548,y:0,width:86},T:{x:1634,y:0,width:86},U:{x:0,y:97,width:86},V:{x:86,y:97,width:86},W:{x:172,y:97,width:86},X:{x:258,y:97,width:86},Y:{x:344,y:97,width:86},Z:{x:430,y:97,width:86},0:{x:516,y:97,width:86},1:{x:602,y:97,width:86},2:{x:688,y:97,width:86},3:{x:774,y:97,width:86},4:{x:860,y:97,width:86},5:{x:946,y:97,width:86},6:{x:1032,y:97,width:86},7:{x:1118,y:97,width:86},8:{x:1204,y:97,width:86},9:{x:1290,y:97,width:86},"+":{x:1376,y:97,width:86},"-":{x:1462,y:97,width:86},".":{x:1548,y:97,width:86},",":{x:1634,y:97,width:86}}};class Axes2DLayer extends lib_layer.A{shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.viewportChanged}updateState(){const fontTexture=this.state.fontTexture,{label_models:label_models,line_model:line_model,background_model:background_model}=this._getModels(fontTexture);this.setState({...this.state,models:[...label_models,line_model,background_model]})}initializeState(){(0,load.H)(font_atlas_namespaceObject,image_loader.$,{image:{type:"data"}}).then((data=>{const fontTexture=this.context.device.createTexture({width:data.width,height:data.height,format:"rgb8unorm-webgl",data:data,sampler:{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",minFilter:"linear",magFilter:"linear"}}),{label_models:label_models,line_model:line_model,background_model:background_model}=this._getModels(fontTexture);this.setState({fontTexture:fontTexture,models:[...label_models,line_model,background_model]})}))}GetTickLinesAndLabels(min,max,viewSide,pixel2worldHor,pixel2worldVer){const lines=[],tick_labels=[],mv=this.props.marginV*pixel2worldVer,mh=this.props.marginH*pixel2worldHor,vpBounds=this.context.viewport.getBounds();let start,y_tick=0,x_tick=0;viewSide===ViewSide.Top?(start=vpBounds[3]-mv,y_tick=start):viewSide===ViewSide.Bottom?(start=vpBounds[1]+mv,y_tick=start):viewSide===ViewSide.Left?(start=vpBounds[0]+mh,x_tick=start):viewSide===ViewSide.Right&&(start=vpBounds[2]-mh,x_tick=start);const isTopOrBottomRuler=viewSide===ViewSide.Top||viewSide===ViewSide.Bottom,delta=isTopOrBottomRuler?10*pixel2worldVer:10*pixel2worldHor,ticks=function GetTicks(min,max,axis_pixel_length){let step=Math.min(Math.round(axis_pixel_length/100)+1,20);const range=max-min,delta=Math.abs(range)/step;let decade=1;if(delta>=10){const logde=Math.log10(delta),pot=Math.floor(logde);decade=Math.pow(10,pot)}let scaled_delta=Math.round(delta/decade);3==scaled_delta?scaled_delta=2:4==scaled_delta||6==scaled_delta||7==scaled_delta?scaled_delta=5:scaled_delta>7?scaled_delta=10:scaled_delta<1&&(scaled_delta=1);const incr=scaled_delta*decade,start=Math.ceil(min/incr)*incr,stop=Math.floor(max/incr)*incr,calc_step=Math.floor(Math.abs(stop-start)/incr);step=calc_step>0?calc_step:0;const ticks=[];for(let i=0;i<=step;i++){const x=start+i*incr;ticks.push(x)}return ticks}(min,max,isTopOrBottomRuler?LineLengthInPixels([min,0,0],[max,0,0],this.context.viewport):LineLengthInPixels([0,min,0],[0,max,0],this.context.viewport)),tick_length=viewSide===ViewSide.Left||viewSide===ViewSide.Bottom?-delta:delta;for(let i=0;i<ticks.length;i++){const tick=ticks[i];let label=tick.toFixed(0);this.props.formatLabelFunc&&(label=this.props.formatLabelFunc(tick),label=label.replace("e","E"),label=label.replace("−","-")),tick_labels.push(label),isTopOrBottomRuler?(lines.push(tick,y_tick,0),lines.push(tick,y_tick+tick_length,0)):(lines.push(x_tick,tick,0),lines.push(x_tick+tick_length,tick,0))}if(ticks.length>1){const tick1=ticks[0],d=(ticks[1]-tick1)/4,tick_start=tick1;let i=0;for(;tick_start+(i+1)*d<max;){const tick=tick_start+(i+1)*d;tick_labels.push(""),i++,isTopOrBottomRuler?(lines.push(tick,y_tick,0),lines.push(tick,y_tick+.5*tick_length,0)):(lines.push(x_tick,tick,0),lines.push(x_tick+.5*tick_length,tick,0))}for(i=0;tick_start-(i+1)*d>min;){const tick=tick_start-(i+1)*d;tick_labels.push(""),i++,isTopOrBottomRuler?(lines.push(tick,y_tick,0),lines.push(tick,y_tick+.5*tick_length,0)):(lines.push(x_tick,tick,0),lines.push(x_tick+.5*tick_length,tick,0))}}return[lines,this.makeLabelsData(lines,tick_labels)]}GetBackgroundTriangleLinesHorizontal(x_min_w,x_max_w,isTop,pixel2world){const mv=this.props.marginV*pixel2world,vp_bounds=this.context.viewport.getBounds(),y_max=isTop?vp_bounds[3]:vp_bounds[1]+mv,y_min=isTop?vp_bounds[3]-mv:vp_bounds[1],p2=[x_max_w,y_max,0],p3=[x_max_w,y_min,0],p4=[x_min_w,y_min,0];return[...[x_min_w,y_max,0],...p2,...p4,...p2,...p4,...p3]}GetBackgroundTriangleLinesVertical(y_min_w,y_max_w,isLeft,pixel2world){const mh=this.props.marginH*pixel2world,vp_bounds=this.context.viewport.getBounds(),x_max=isLeft?vp_bounds[0]+mh:vp_bounds[2],x_min=isLeft?vp_bounds[0]:vp_bounds[2]-mh,p2=[x_max,y_max_w,0],p3=[x_min,y_max_w,0],p4=[x_min,y_min_w,0];return[...[x_max,y_min_w,0],...p2,...p4,...p2,...p4,...p3]}makeLabelsData(tick_lines,tick_labels){const labels=[];for(let i=0;i<tick_lines.length/6;i++){const from=[tick_lines[6*i+0],tick_lines[6*i+1],tick_lines[6*i+2]],to=[tick_lines[6*i+3],tick_lines[6*i+4],tick_lines[6*i+5]],label=tick_labels[i],tick_vec=[to[0]-from[0],to[1]-from[1],to[2]-from[2]],s=.5,pos=[to[0]+s*tick_vec[0],to[1]+s*tick_vec[1],to[2]+s*tick_vec[2]];let anchor=TEXT_ANCHOR.end,alignment=ALIGNMENT_BASELINE.center;if(from[1]!==to[1])anchor=TEXT_ANCHOR.middle,alignment=ALIGNMENT_BASELINE.top;else{const screen_from=this.context.viewport.project(from),screen_to=this.context.viewport.project(to);screen_from[0]<screen_to[0]&&(anchor=TEXT_ANCHOR.start)}labels.push({label:label,pos:pos,anchor:anchor,alignment:alignment})}return labels}draw({context:context}){const is_orthographic=this.context.viewport.constructor===orthographic_viewport.A;if(void 0===this.state.fontTexture||!is_orthographic)return;const models=this.getModels(),n=models.length;if(!(n<2)){models[n-1].draw(context.renderPass),models[n-2].draw(context.renderPass);for(let i=0;i<n-2;i++)models[i].draw(context.renderPass)}}_getModels(fontTexture){const device=this.context.device,m=100;let world_from=this.context.viewport.unproject([0,0,0]),world_to=this.context.viewport.unproject([m,0,0]),v=[world_from[0]-world_to[0],world_from[1]-world_to[1],world_from[2]-world_to[2]];const pixel2worldHor=Math.sqrt(v[0]*v[0]+v[1]*v[1])/m;world_from=this.context.viewport.unproject([0,0,0]),world_to=this.context.viewport.unproject([0,m,0]),v=[world_from[0]-world_to[0],world_from[1]-world_to[1],world_from[2]-world_to[2]];const pixel2worldVer=Math.sqrt(v[0]*v[0]+v[1]*v[1])/m,mh=this.props.marginH*pixel2worldHor,mv=this.props.marginV*pixel2worldVer,viewport_bounds_w=this.context.viewport.getBounds(),xBoundsMin=viewport_bounds_w[0],xBoundsMax=viewport_bounds_w[2],yBoundsMin=viewport_bounds_w[1],yBoundsMax=viewport_bounds_w[3];let tick_and_axes_lines=[],background_lines=[],labelData=[];const isB=this.props.isBottomRuler,isT=this.props.isTopRuler,isL=this.props.isLeftRuler,isR=this.props.isRightRuler,xmin=xBoundsMin+(isL?mh:0),xmax=xBoundsMax-(isR?mh:0),ymin=isB?yBoundsMin+mv:yBoundsMin,ymax=isT?yBoundsMax-mv:yBoundsMax;if(isB){const axes=[xmin,ymin,0,xmax,ymin,0],[ticks,labels]=this.GetTickLinesAndLabels(xmin,xmax,ViewSide.Bottom,pixel2worldHor,pixel2worldVer),back_lines=this.GetBackgroundTriangleLinesHorizontal(xBoundsMin,xBoundsMax,!1,pixel2worldVer);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isT){const axes=[xmin,ymax,0,xmax,ymax,0],[ticks,labels]=this.GetTickLinesAndLabels(xmin,xmax,ViewSide.Top,pixel2worldHor,pixel2worldVer),back_lines=this.GetBackgroundTriangleLinesHorizontal(xBoundsMin,xBoundsMax,!0,pixel2worldVer);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isL){const axes=[xmin,ymin,0,xmin,ymax,0],[ticks,labels]=this.GetTickLinesAndLabels(ymin,ymax,ViewSide.Left,pixel2worldHor,pixel2worldVer),back_lines=this.GetBackgroundTriangleLinesVertical(ymin,ymax,!0,pixel2worldHor);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isR){const axes=[xmax,ymin,0,xmax,ymax,0],[ticks,labels]=this.GetTickLinesAndLabels(ymin,ymax,ViewSide.Right,pixel2worldHor,pixel2worldVer),back_lines=this.GetBackgroundTriangleLinesVertical(ymin,ymax,!1,pixel2worldHor);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}let lineColor=[0,0,0,1];void 0!==this.props.axisColor&&(lineColor=this.props.axisColor,3===lineColor.length&&lineColor.push(255),lineColor=lineColor.map((x=>(x??0)/255)));const line_model=new model_model.K(device,{id:`${this.props.id}-lines`,vs:line_vertex_glsl,fs:line_fragment_glsl,uniforms:{uColor:lineColor,uClipZ:-1},geometry:new geometry.V({topology:"line-list",attributes:{positions:new Float32Array(tick_and_axes_lines)},vertexCount:tick_and_axes_lines.length/3}),modules:[project32.A],isInstanced:!1});let bColor=[.5,.5,.5,1];void 0!==this.props.backgroundColor&&(bColor=this.props.backgroundColor,3===bColor.length&&bColor.push(255),bColor=bColor.map((x=>(x??0)/255)));const background_model=new model_model.K(device,{id:`${this.props.id}-background`,vs:line_vertex_glsl,fs:line_fragment_glsl,uniforms:{uColor:bColor,uClipZ:-.9},geometry:new geometry.V({topology:"triangle-list",attributes:{positions:new Float32Array(background_lines)},vertexCount:background_lines.length/3}),modules:[project32.A],isInstanced:!1}),label_models=[],pixelScale=function GetPixelsScale(labelFontSizePt){return Math.max(0,8/9*labelFontSizePt)}(this.props.labelFontSizePt??axes2DLayer_defaultProps.labelFontSizePt);for(const item of labelData){const x=item.pos[0],y=item.pos[1],z=item.pos[2],label=item.label,anchor=item.anchor??TEXT_ANCHOR.start,alignment_baseline=item.alignment??ALIGNMENT_BASELINE.center;if(""===label)continue;const pos_w=vec4.fA(x,y,z,1),len=label.length,numVertices=6*len,positions=new Float32Array(3*numVertices),texcoords=new Float32Array(2*numVertices),maxX=fontInfo.textureWidth,maxY=fontInfo.textureHeight;let offset=0,offsetTexture=0,x1=0;anchor===TEXT_ANCHOR.end?x1=-len:anchor===TEXT_ANCHOR.middle&&(x1=-len/2);let y_alignment_offset=0;alignment_baseline===ALIGNMENT_BASELINE.center?y_alignment_offset=.5*pixelScale:alignment_baseline===ALIGNMENT_BASELINE.top&&(y_alignment_offset=1*pixelScale);for(let ii=0;ii<len;++ii){const letter=label[ii],glyphInfo=fontInfo.glyphInfos[letter];if(glyphInfo){const x2=x1+1,u1=glyphInfo.x/maxX,v1=(glyphInfo.y+fontInfo.letterHeight-1)/maxY,u2=(glyphInfo.x+glyphInfo.width-1)/maxX,v2=glyphInfo.y/maxY,h=1;positions[offset+0]=pos_w[0]+x1*pixelScale*pixel2worldHor,positions[offset+1]=pos_w[1]+(0*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+2]=pos_w[2],texcoords[offsetTexture+0]=u1,texcoords[offsetTexture+1]=v1,positions[offset+3]=pos_w[0]+x2*pixelScale*pixel2worldHor,positions[offset+4]=pos_w[1]+(0*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+5]=pos_w[2],texcoords[offsetTexture+2]=u2,texcoords[offsetTexture+3]=v1,positions[offset+6]=pos_w[0]+x1*pixelScale*pixel2worldHor,positions[offset+7]=pos_w[1]+(h*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+8]=pos_w[2],texcoords[offsetTexture+4]=u1,texcoords[offsetTexture+5]=v2,positions[offset+9]=pos_w[0]+x1*pixelScale*pixel2worldHor,positions[offset+10]=pos_w[1]+(h*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+11]=pos_w[2],texcoords[offsetTexture+6]=u1,texcoords[offsetTexture+7]=v2,positions[offset+12]=pos_w[0]+x2*pixelScale*pixel2worldHor,positions[offset+13]=pos_w[1]+(0*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+14]=pos_w[2],texcoords[offsetTexture+8]=u2,texcoords[offsetTexture+9]=v1,positions[offset+15]=pos_w[0]+x2*pixelScale*pixel2worldHor,positions[offset+16]=pos_w[1]+(h*pixelScale-y_alignment_offset)*pixel2worldVer,positions[offset+17]=pos_w[2],texcoords[offsetTexture+10]=u2,texcoords[offsetTexture+11]=v2,x1+=1,offset+=18,offsetTexture+=12}else x1+=1}const model=new model_model.K(device,{id:`${this.props.id}-${label}`,vs:"#version 300 es\n#define SHADER_NAME axes2d-layer-vertex-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nin vec2 vTexCoord;\nout vec2 _vTexCoord;\n\nvoid main(void) {\n   _vTexCoord = vTexCoord;\n\n   vec3 position_commonspace = project_position(positions);\n   vec4 position_clipspace = project_common_position_to_clipspace(vec4(position_commonspace, 1.0));\n   gl_Position = vec4(position_clipspace.x, position_clipspace.y, -1.0, position_clipspace.w);\n}\n",fs:"#version 300 es\n#define SHADER_NAME axes2d-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform sampler2D fontTexture;\n\nuniform vec4 uAxisColor;\nuniform vec4 uBackGroundColor;\n\nin vec2 _vTexCoord;\n\nvoid main(void) {\n  vec4 color = texture(fontTexture, _vTexCoord);\n  \n  float x = 1.0 - (color.r + color.g + color.b) / 3.0;  // intensity of text color\n  x = smoothstep(0.0, 0.2, x);  \n\n  float text_r = uAxisColor.r;\n  float text_g = uAxisColor.g;\n  float text_b = uAxisColor.b;\n\n  float bg_r = uBackGroundColor.r;\n  float bg_g = uBackGroundColor.g;\n  float bg_b = uBackGroundColor.b;\n  \n  float r = x * text_r + (1.0 - x) * bg_r;\n  float g = x * text_g + (1.0 - x) * bg_g;\n  float b = x * text_b + (1.0 - x) * bg_b;\n\n  fragColor = vec4(r, g, b, 1.0);\n}\n",uniforms:{uAxisColor:lineColor,uBackGroundColor:bColor},bindings:{fontTexture:fontTexture},geometry:new geometry.V({topology:"triangle-list",attributes:{positions:positions,vTexCoord:{value:texcoords,size:2}},vertexCount:positions.length/3}),bufferLayout:this.getAttributeManager().getBufferLayouts(),modules:[project32.A],isInstanced:!1});label_models.push(model)}return{label_models:label_models,line_model:line_model,background_model:background_model}}}function LineLengthInPixels(p0,p1,viewport){const screen_from=viewport.project(p0),screen_to=viewport.project(p1),v=[screen_from[0]-screen_to[0],screen_from[1]-screen_to[1],screen_from[2]-screen_to[2]];return Math.sqrt(v[0]*v[0]+v[1]*v[1])}Axes2DLayer.layerName="Axes2DLayer",Axes2DLayer.defaultProps=axes2DLayer_defaultProps;class SelectableGeoJsonLayer extends geojson_layer.A{onClick(info){return!(0,layerTools.gU)(this.context.layerManager)&&(this.context.userData.setEditedData({selectedGeoJsonFeature:info.object}),!0)}}SelectableGeoJsonLayer.layerName="SelectableGeoJsonLayer",SelectableGeoJsonLayer.defaultProps={visible:!0,pickable:!0};var northArrow3DLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/northarrow/northArrow3DLayer.ts"),pureFunctionsAny_generated=__webpack_require__("./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"),intersectionViewport=__webpack_require__("./packages/subsurface-viewer/src/viewports/intersectionViewport.ts");const planeY=2e3;function computeUnfoldedPath(worldCoordinates){const z=worldCoordinates.map((v=>v[2])),delta=worldCoordinates.map(((v,i,coordinates)=>{const prev=coordinates[i-1]||v;return(0,pureFunctionsAny_generated.IoC)([prev[0],prev[1]],[v[0],v[1]])})),a=[];delta.forEach((d=>{const prev=a.at(-1)||0;a.push(d+prev)}));return(0,lodash.zip)(a,[...a].fill(planeY),z)}function getUnfoldedPath(object){const worldCoordinates=object.geometry.coordinates;return(0,lodash.isEqual)(worldCoordinates[0],worldCoordinates.at(-1))?function computeUnfoldedPolygon(coordinates){const half=Math.floor(coordinates.length/2),upper_line=coordinates.splice(0,half),lower_line=coordinates.splice(0,half),uul=computeUnfoldedPath(upper_line),ull=computeUnfoldedPath(lower_line.reverse()),unfolded_coordinates=uul.concat(ull.reverse());return unfolded_coordinates.push(uul[0]),unfolded_coordinates}(worldCoordinates):computeUnfoldedPath(worldCoordinates)}class UnfoldedGeoJsonLayer extends geojson_layer.A{renderLayers(){const layers=super.renderLayers();return layers.flat().filter((layer=>"PathLayer"===layer?.constructor.name)).forEach((layer=>{const unfolded_layer=layer.clone(this.getSubLayerProps({...layer,id:layer.id+"-for-intersection-view",getPath:object=>getUnfoldedPath(object)}));unfolded_layer&&layers.push(unfolded_layer)})),layers}filterSubLayer({layer:layer,viewport:viewport}){return viewport.constructor===intersectionViewport.A?-1!=layer.id.search("-for-intersection-view"):-1==layer.id.search("-for-intersection-view")}}UnfoldedGeoJsonLayer.layerName="UnfoldedGeoJsonLayer";var grid3dLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/grid3d/grid3dLayer.ts"),boxSelectionLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/BoxSelectionLayer/boxSelectionLayer.ts"),abscissaTransform=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/utils/abscissaTransform.ts")},"./packages/subsurface-viewer/src/layers/map/mapLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return MapLayer}});var lodash=__webpack_require__("./node_modules/lodash/lodash.js"),composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),lib=__webpack_require__("./node_modules/@vivaxy/png/lib/index.js"),workerpool=__webpack_require__("./node_modules/workerpool/dist/workerpool.js"),workerpool_default=__webpack_require__.n(workerpool),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js"),shader_modules=__webpack_require__("./packages/subsurface-viewer/src/layers/shader_modules/index.ts"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");const defaultProps={data:["dummy"],contours:[-1,-1],isContoursDepth:!0,gridLines:!1,colorMapName:"",coordinateSystem:constants.rf.CARTESIAN,propertyValueRange:[0,1],meshValueRange:[0,1],depthTest:!0,ZIncreasingDownwards:!0};class PrivateMapLayer extends lib_layer.A{get isLoaded(){return this.state.isLoaded??!1}initializeState(context){const gl=context.device,[mesh_model,mesh_lines_model]=this._getModels(gl);this.setState({models:[mesh_model,mesh_lines_model],isLoaded:!1})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(device){const colormap=device.createTexture({sampler:{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",minFilter:"linear",magFilter:"linear"},width:256,height:1,format:"rgb8unorm-webgl",data:(0,layerTools.M5)(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction)}),contourReferencePoint=this.props.contours[0]??-1,contourInterval=this.props.contours[1]??-1,isContoursDepth=this.props.isContoursDepth,valueRangeMin=this.props.propertyValueRange[0]??0,valueRangeMax=this.props.propertyValueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,isClampColor=void 0!==this.props.colorMapClampColor&&!0!==this.props.colorMapClampColor&&!1!==this.props.colorMapClampColor;let colorMapClampColor=isClampColor?this.props.colorMapClampColor:[0,0,0];colorMapClampColor=colorMapClampColor.map((x=>(x??0)/255));const isColorMapClampColorTransparent=!1===this.props.colorMapClampColor,smoothShading=0!=this.props.normals.length&&this.props.smoothShading;return[new model.K(device,{id:`${this.props.id}-mesh`,...this.getShaders(),geometry:new geometry.V({topology:"triangle-list",attributes:{positions:{value:this.props.positions,size:3},...this.props.normals.length>0&&{normals:{value:this.props.normals,size:3}},properties:{value:this.props.vertexProperties,size:1}},indices:{value:this.props.triangleIndices,size:1}}),bufferLayout:this.getAttributeManager().getBufferLayouts(),uniforms:{contourReferencePoint:contourReferencePoint,contourInterval:contourInterval,isContoursDepth:isContoursDepth,valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax,colorMapClampColor:colorMapClampColor,isColorMapClampColorTransparent:isColorMapClampColorTransparent,isClampColor:isClampColor,smoothShading:smoothShading,ZIncreasingDownwards:this.props.ZIncreasingDownwards},bindings:{colormap:colormap},isInstanced:!1}),new model.K(device,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nuniform bool ZIncreasingDownwards;\n\nvoid main(void) {\n   vec3 position = positions;\n   position[2] *= ZIncreasingDownwards ? -1.0 : 1.0;\n\n   vec3 position_commonspace = project_position(position);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.V({topology:"line-list",attributes:{positions:{value:this.props.positions,size:3}},indices:{value:this.props.lineIndices,size:1}}),bufferLayout:this.getAttributeManager().getBufferLayouts(),modules:[project32.A],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{uniforms:uniforms,context:context}=args,{gl:gl}=context,[mesh_model,mesh_lines_model]=this.state.models;gl.enable(gl.POLYGON_OFFSET_FILL),this.props.depthTest||gl.disable(gl.DEPTH_TEST),gl.polygonOffset(1,1),mesh_model.draw(context.renderPass),gl.disable(gl.POLYGON_OFFSET_FILL),this.props.depthTest||gl.enable(gl.DEPTH_TEST),this.props.gridLines&&(mesh_lines_model.setUniforms({uniforms:uniforms,ZIncreasingDownwards:this.props.ZIncreasingDownwards}),mesh_lines_model.draw(context.renderPass)),this.state.isLoaded||this.setState({...this.state,isLoaded:!0})}decodePickingColor(){return 0}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],vertexIndex=65536*info.color[0]+256*info.color[1]+info.color[2];if(void 0!==info.coordinate?.[2]){const zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1,depth=(this.props.ZIncreasingDownwards?-info.coordinate[2]:info.coordinate[2])/Math.max(.001,zScale);layer_properties.push((0,layerTools.e2)("Depth",depth))}const property=this.props.vertexProperties[vertexIndex];return layer_properties.push((0,layerTools.e2)("Property",property)),{...info,properties:layer_properties}}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME vertex-shader\n\nprecision highp float;\n\n// Primitive attributes\nin vec3 positions;\nin float properties;\nin vec3 normals;\nin vec3 colors;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nout vec3 worldPos;\nout float property;\nflat out int vertexIndex;\n\nuniform bool ZIncreasingDownwards;\n\nvoid main(void) {\n   geometry.pickingColor = vec3(1.0, 1.0, 0.0);\n   vertexIndex = gl_VertexID;\n\n   vec3 position = positions;\n   position[2] *= ZIncreasingDownwards ? -1.0 : 1.0;\n\n   cameraPosition = project_uCameraPosition;\n\n   worldPos = position;\n   geometry.worldPosition = position;\n\n   normals_commonspace = normals;\n\n   vColor = vec4(colors.rgb, 1.0);\n\n   property = properties;\n\n   position_commonspace = vec4(project_position(position), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n\n   DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n   vec4 color = vec4(0.0);\n   DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:'#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nflat in int vertexIndex;\n\nin vec3 worldPos;\nin float property;\n\nout vec4 fragColor;\n\nuniform sampler2D colormap;\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform vec3 colorMapClampColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\nuniform bool smoothShading;\n\nvoid main(void) { \n   geometry.uv = vTexCoord;\n\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading || (normal[0] == 0.0 && normal[1] == 0.0 && normal[2] == 0.0)) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   }\n\n   //Picking pass.\n   if (picking.isActive > 0.5 && !(picking.isAttribute > 0.5)) {\n      fragColor = encodeVertexIndexToRGB(vertexIndex);\n      return;\n   }\n\n   vec4 color = vec4(1.0, 1.0, 1.0,  1.0);\n   float propertyValue = property;\n\n   // This may happen due to GPU interpolation precision causing color artifacts.\n   propertyValue = clamp(propertyValue, valueRangeMin, valueRangeMax);\n\n   float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n   if (x < 0.0 || x > 1.0) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n         return;\n      }\n      else {\n         // Use min/max color to clamp.\n         x = max(0.0, x);\n         x = min(1.0, x);\n\n         color = texture(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      color = texture(colormap, vec2(x, 0.5));\n   }\n\n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      float val = isContoursDepth ? (abs(worldPos.z) - contourReferencePoint) / contourInterval\n                                  : (propertyValue - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use two sided phong lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = getPhongLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',modules:[project32.A,picking.A,shader_modules.oS,shader_modules.BF]})}}function rotate(x,y,x0,y0,rad){return[Math.cos(rad)*(x-x0)-Math.sin(rad)*(y-y0)+x0,Math.sin(rad)*(x-x0)+Math.cos(rad)*(y-y0)+y0]}function makeFullMesh(e){const[inputMeshData,inputPropertiesData,isMesh,frame,smoothShading,gridLines]=e.data;function getFloat32ArrayMinMax(data){let max=-99999999,min=99999999;for(let i=0;i<data.length;i++)max=data[i]>max?data[i]:max,min=data[i]<min?data[i]:min;return[min,max]}function crossProduct(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function isDefined(x){return"number"==typeof x&&!isNaN(x)}function calcNormal(w,h,nx,ny,isMesh,smoothShading,meshData,ox,oy,dx,dy){if(!smoothShading)return[1,1,1];if(!isMesh)return[0,0,1];const i0=h*nx+w,i1=h*nx+(w-1),i2=(h+1)*nx+w,i3=h*nx+(w+1),i4=(h-1)*nx+w,i0_act=isDefined(meshData[i0]),i1_act=w-1>=0&&isDefined(meshData[i1]),i2_act=h+1<ny&&isDefined(meshData[i2]),i3_act=w+1<nx&&isDefined(meshData[i3]),i4_act=h-1>=0&&isDefined(meshData[i4]),noNormal=[0,0,0];if(!i0_act)return noNormal;const hh=ny-1-h,p0=[ox+w*dx,oy+hh*dy,i0_act?meshData[i0]:0],p1=[ox+(w-1)*dx,oy+hh*dy,i1_act?meshData[i1]:0],p2=[ox+w*dx,oy+(hh+1)*dy,i2_act?meshData[i2]:0],p3=[ox+(w+1)*dx,oy+hh*dy,i3_act?meshData[i3]:0],p4=[ox+w*dx,oy+(hh-1)*dy,i4_act?meshData[i4]:0],v1=[p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]],v2=[p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]],v3=[p3[0]-p0[0],p3[1]-p0[1],p3[2]-p0[2]],v4=[p4[0]-p0[0],p4[1]-p0[1],p4[2]-p0[2]],normals=[];if(i1_act&&i2_act){const normal=crossProduct(v2,v1);normals.push(normal)}if(i2_act&&i3_act){const normal=crossProduct(v3,v2);normals.push(normal)}if(i3_act&&i4_act){const normal=crossProduct(v4,v3);normals.push(normal)}if(i4_act&&i1_act){const normal=crossProduct(v1,v4);normals.push(normal)}if(0===normals.length)return noNormal;const mean=normals[0];for(let i=1;i<normals.length;i++)mean[0]+=normals[i][0],mean[1]+=normals[i][1],mean[2]+=normals[i][2];return function normalize(a){const L=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);a[0]/=L,a[1]/=L,a[2]/=L}(mean),mean}const meshData=inputMeshData,propertiesData=inputPropertiesData??meshData,meshZValueRange=isMesh?getFloat32ArrayMinMax(meshData):[0,0],propertyValueRange=getFloat32ArrayMinMax(propertiesData),ox=frame.origin[0],oy=frame.origin[1],dx=frame.increment[0],dy=frame.increment[1],nx=frame.count[0],ny=frame.count[1],propLength=propertiesData.length,isCellCenteredProperties=propLength===(nx-1)*(ny-1);propLength!==(nx-1)*(ny-1)&&propLength!==nx*ny&&console.error("There should be as many property values as nodes (nx*ny) OR as many as cells (nx - 1) * (ny - 1).");const nNodes=nx*ny,nCells=(nx-1)*(ny-1),nTriangles=2*nCells,positions=new Float32Array(isCellCenteredProperties?6*nCells*3:3*nNodes),normals=new Float32Array(isCellCenteredProperties||!smoothShading?0:3*nNodes),triangleIndices=new Uint32Array(3*nTriangles),vertexProperties=new Float32Array(isCellCenteredProperties?6*nCells:nNodes);let nLineIndices=0;gridLines&&(nLineIndices=isCellCenteredProperties?2*nTriangles*2:4*nCells+2*(nx-1)+2*(ny-1));const lineIndices=new Uint32Array(nLineIndices);if(isCellCenteredProperties){let i=0,j=0,k=0,l=0;for(let h=0;h<ny-1;h++)for(let w=0;w<nx-1;w++){const hh=ny-1-h,i0=h*nx+w,i1=h*nx+(w+1),i2=(h+1)*nx+(w+1),i3=(h+1)*nx+w,i0_act=!isMesh||isDefined(meshData[i0]),i1_act=!isMesh||isDefined(meshData[i1]),i2_act=!isMesh||isDefined(meshData[i2]),i3_act=!isMesh||isDefined(meshData[i3]),x0=ox+w*dx,y0=oy+hh*dy,z0=isMesh?meshData[i0]:0,x1=ox+(w+1)*dx,y1=oy+hh*dy,z1=isMesh?meshData[i1]:0,x2=ox+(w+1)*dx,y2=oy+(hh-1)*dy,z2=isMesh?meshData[i2]:0,x3=ox+w*dx,y3=oy+(hh-1)*dy,z3=isMesh?meshData[i3]:0,propertyValue=propertiesData[h*(nx-1)+w];if(isDefined(propertyValue))if(i1_act&&i3_act){if(i0_act){triangleIndices[i]=i;const L1=i;i++,positions[j++]=x1,positions[j++]=y1,positions[j++]=z1,triangleIndices[i]=i;const L2=i;i++,positions[j++]=x3,positions[j++]=y3,positions[j++]=z3,triangleIndices[i]=i;const L3=i;i++,positions[j++]=x0,positions[j++]=y0,positions[j++]=z0,gridLines&&(lineIndices[l++]=L3,lineIndices[l++]=L1,lineIndices[l++]=L3,lineIndices[l++]=L2),vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue}if(i2_act){triangleIndices[i]=i;const L1=i;i++,positions[j++]=x1,positions[j++]=y1,positions[j++]=z1,triangleIndices[i]=i;const L2=i;i++,positions[j++]=x3,positions[j++]=y3,positions[j++]=z3,triangleIndices[i]=i;const L3=i;i++,positions[j++]=x2,positions[j++]=y2,positions[j++]=z2,gridLines&&(lineIndices[l++]=L1,lineIndices[l++]=L3,lineIndices[l++]=L2,lineIndices[l++]=L3),vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue}}else if(i0_act&&i2_act){if(i1_act){triangleIndices[i]=i;const L1=i;i++,positions[j++]=x1,positions[j++]=y1,positions[j++]=z1,triangleIndices[i]=i;const L2=i;i++,positions[j++]=x2,positions[j++]=y2,positions[j++]=z2,triangleIndices[i]=i;const L3=i;i++,positions[j++]=x0,positions[j++]=y0,positions[j++]=z0,gridLines&&(lineIndices[l++]=L1,lineIndices[l++]=L3,lineIndices[l++]=L1,lineIndices[l++]=L2),vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue}if(i3_act){triangleIndices[i]=i;const L1=i;i++,positions[j++]=x3,positions[j++]=y3,positions[j++]=z3,triangleIndices[i]=i;const L2=i;i++,positions[j++]=x0,positions[j++]=y0,positions[j++]=z0,triangleIndices[i]=i;const L3=i;i++,positions[j++]=x2,positions[j++]=y2,positions[j++]=z2,gridLines&&(lineIndices[l++]=L1,lineIndices[l++]=L2,lineIndices[l++]=L1,lineIndices[l++]=L3),vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue,vertexProperties[k++]=propertyValue}}}}else{let i=0;for(let h=0;h<ny;h++)for(let w=0;w<nx;w++){const i0=h*nx+w,x0=ox+w*dx,y0=oy+(ny-1-h)*dy,z=isMesh?meshData[i0]:0,propertyValue=propertiesData[i0];if(positions[3*i+0]=x0,positions[3*i+1]=y0,positions[3*i+2]=z,smoothShading){const normal=calcNormal(w,h,nx,ny,isMesh,smoothShading,meshData,ox,oy,dx,dy);normals[3*i+0]=normal[0],normals[3*i+1]=normal[1],normals[3*i+2]=normal[2]}vertexProperties[i]=propertyValue,i++}i=0;let j=0;for(let h=0;h<ny-1;h++)for(let w=0;w<nx-1;w++){const i0=h*nx+w,i1=h*nx+(w+1),i2=(h+1)*nx+(w+1),i3=(h+1)*nx+w,i0_act=!isMesh||isDefined(meshData[i0])&&isDefined(propertiesData[i0]),i1_act=!isMesh||isDefined(meshData[i1])&&isDefined(propertiesData[i1]),i2_act=!isMesh||isDefined(meshData[i2])&&isDefined(propertiesData[i2]),i3_act=!isMesh||isDefined(meshData[i3])&&isDefined(propertiesData[i3]);i1_act&&i3_act?(i0_act&&(triangleIndices[i++]=i1,triangleIndices[i++]=i3,triangleIndices[i++]=i0),i2_act&&(triangleIndices[i++]=i1,triangleIndices[i++]=i3,triangleIndices[i++]=i2)):i0_act&&i2_act&&(i1_act&&(triangleIndices[i++]=i1,triangleIndices[i++]=i2,triangleIndices[i++]=i0),i3_act&&(triangleIndices[i++]=i3,triangleIndices[i++]=i0,triangleIndices[i++]=i2)),gridLines&&(i0_act&&i1_act&&(lineIndices[j++]=i0,lineIndices[j++]=i1),i0_act&&i3_act&&(lineIndices[j++]=i0,lineIndices[j++]=i3),h==ny-2&&i2_act&&i3_act&&(lineIndices[j++]=i3,lineIndices[j++]=i2),w==nx-2&&i1_act&&i2_act&&(lineIndices[j++]=i1,lineIndices[j++]=i2),(i0_act&&!i2_act||!i0_act&&i2_act)&&(lineIndices[j++]=i1,lineIndices[j++]=i3),(i3_act&&!i1_act||!i3_act&&i1_act)&&(lineIndices[j++]=i0,lineIndices[j++]=i2))}}return[positions,normals,triangleIndices,vertexProperties,lineIndices,meshZValueRange,propertyValueRange]}PrivateMapLayer.layerName="privateMapLayer",PrivateMapLayer.defaultProps=defaultProps;var SubsurfaceConfig=__webpack_require__("./packages/subsurface-viewer/src/SubsurfaceConfig.json");const workerPoolConfig=(0,__webpack_require__("./packages/subsurface-viewer/src/utils/configTools.ts").u)(SubsurfaceConfig,"config/workerpool","config/layer/MapLayer/workerpool"),pool=workerpool_default().pool({maxWorkers:10,workerType:"web",...workerPoolConfig});async function loadFloat32Data(data){return data?ArrayBuffer.isView(data)?data:Array.isArray(data)?new Float32Array(data):await async function loadURLData(url){let res=null;const response=await fetch(url);response.ok||console.error("Could not load ",url);const blob=await response.blob();if("image/png"===response.headers.get("content-type"))res=await new Promise((resolve=>{const fileReader=new FileReader;fileReader.readAsArrayBuffer(blob),fileReader.onload=()=>{const arrayBuffer=fileReader.result,data=lib.D4(arrayBuffer).data,n=data.length,buffer=new ArrayBuffer(n),view=new DataView(buffer);for(let i=0;i<n;i++)view.setUint8(i,data[i]);const floatArray=new Float32Array(buffer);resolve(floatArray)}}));else{const buffer=await blob.arrayBuffer();res=new Float32Array(buffer)}return res}(data):null}class MapLayer extends composite_layer.A{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinished=this.state?.isFinishedLoading??!1;return isLoaded&&isFinished}rebuildData(reportBoundingBox){void 0!==this.props.meshUrl&&console.warn('"meshUrl" is deprecated. Use "meshData"'),void 0!==this.props.propertiesUrl&&console.warn('"propertiesUrl" is deprecated. Use "propertiesData"');const p=async function loadMeshAndProperties(meshData,propertiesData){const mesh=await loadFloat32Data(meshData),properties=await loadFloat32Data(propertiesData);return Promise.all([mesh,properties])}(this.props.meshData??this.props.meshUrl,this.props.propertiesData??this.props.propertiesUrl);p.then((([meshData,propertiesData])=>{const webworkerParams=this.getWebworkerParams(meshData,propertiesData);pool.exec(makeFullMesh,[{data:webworkerParams.params}]).then((e=>{const[positions,normals,triangleIndices,vertexProperties,lineIndices,meshZValueRange,propertyValueRange]=e;if(this.setState({...this.state,positions:positions,normals:normals,triangleIndices:triangleIndices,vertexProperties:vertexProperties,lineIndices:lineIndices,propertyValueRange:propertyValueRange,isFinishedLoading:!0}),void 0!==this.props.reportBoundingBox&&reportBoundingBox){const xinc=this.props.frame?.increment?.[0]??0,yinc=this.props.frame?.increment?.[1]??0,nnodes_x=this.props.frame?.count?.[0]??2,nnodes_y=this.props.frame?.count?.[1]??2,xMin=this.props.frame?.origin?.[0]??0,yMin=this.props.frame?.origin?.[1]??0,zMin=-meshZValueRange[0],xMax=xMin+xinc*(nnodes_x-1),yMax=yMin+yinc*(nnodes_y-1),zMax=-meshZValueRange[1],center=this.props.frame.rotPoint??this.props.frame.origin,rotRad=(this.props.frame.rotDeg??0)*(2*Math.PI)/360,[x0,y0]=rotate(xMin,yMin,center[0],center[1],rotRad),[x1,y1]=rotate(xMax,yMin,center[0],center[1],rotRad),[x2,y2]=rotate(xMax,yMax,center[0],center[1],rotRad),[x3,y3]=rotate(xMin,yMax,center[0],center[1],rotRad),x_min=Math.min(x0,x1,x2,x3),x_max=Math.max(x0,x1,x2,x3),y_min=Math.min(y0,y1,y2,y3),y_max=Math.max(y0,y1,y2,y3);this.props.reportBoundingBox({layerBoundingBox:[x_min,y_min,zMin,x_max,y_max,zMax]})}!function onTerminateWorker(){const stats=pool.stats();0===stats.busyWorkers&&0===stats.pendingTasks&&pool.terminate()}()}))}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.meshUrl,oldProps.meshUrl)&&(0,lodash.isEqual)(props.propertiesUrl,oldProps.propertiesUrl)&&(0,lodash.isEqual)(props.meshData,oldProps.meshData)&&(0,lodash.isEqual)(props.propertiesData,oldProps.propertiesData)&&(0,lodash.isEqual)(props.frame,oldProps.frame)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards)&&(0,lodash.isEqual)(props.gridLines,oldProps.gridLines))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];const[minX,minY]=this.props.frame.origin,center=this.props.frame.rotPoint??[minX,minY],rotatingModelMatrix=(0,layerTools.pK)(this.props.frame.rotDeg??0,center[0],center[1]),isMesh=void 0!==this.props.meshUrl&&""!==this.props.meshUrl||void 0!==this.props.meshData&&""!==this.props.meshData;void 0!==this.props.modelMatrix&&null!==this.props.modelMatrix&&rotatingModelMatrix.multiplyRight(this.props.modelMatrix);return[new PrivateMapLayer(this.getSubLayerProps({positions:this.state.positions,normals:this.state.normals,triangleIndices:this.state.triangleIndices,vertexProperties:this.state.vertexProperties,lineIndices:this.state.lineIndices,pickable:this.props.pickable,modelMatrix:rotatingModelMatrix,contours:this.props.contours,gridLines:this.props.gridLines,isContoursDepth:!!isMesh&&this.props.isContoursDepth,colorMapName:this.props.colorMapName,colorMapRange:this.props.colorMapRange,colorMapClampColor:this.props.colorMapClampColor,colorMapFunction:this.props.colorMapFunction,propertyValueRange:this.state.propertyValueRange,material:this.props.material,smoothShading:this.props.smoothShading,depthTest:this.props.depthTest,ZIncreasingDownwards:this.props.ZIncreasingDownwards}))]}getWebworkerParams(meshData,propertiesData){if(!meshData&&!propertiesData)throw new Error("Either mesh or properties or the both must be defined");const params=[meshData,propertiesData,!!meshData,this.props.frame,this.props.smoothShading,this.props.gridLines],transferrables=[meshData?.buffer,propertiesData?.buffer].filter((item=>!!item));return transferrables.length>0?{params:params,transferrables:transferrables}:{params:params}}}MapLayer.layerName="MapLayer",MapLayer.defaultProps={"@@type":"MapLayer",name:"Map",id:"map3d-layer-float32",pickable:!0,visible:!0,bounds:{type:"object",value:null,false:!0,compare:!0},colorMapRange:{type:"array"},contours:[-1,-1],isContoursDepth:!0,gridLines:!1,smoothShading:!0,material:!0,depthTest:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/northarrow/northArrow3DLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return NorthArrow3DLayer}});var lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js"),vector3=__webpack_require__("./node_modules/@math.gl/core/dist/classes/vector3.js");class NorthArrow3DLayer extends lib_layer.A{initializeState(context){this.setState(this._getModels(context.device))}shouldUpdateState(){return!0}updateState({context:context}){context.device&&this.setState(this._getModels(context.device))}draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}){const{gl:gl}=context;gl.disable(gl.DEPTH_TEST),super.draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}),gl.enable(gl.DEPTH_TEST)}_getModels(device){const model_lines=function GetArrowLines(){const lines=[];let z=.5;return lines.push([-1,-2,z]),lines.push([-1,2,z]),lines.push([-1,2,z]),lines.push([-1.5,2,z]),lines.push([-1.5,2,z]),lines.push([0,4,z]),lines.push([0,4,z]),lines.push([1.5,2,z]),lines.push([1.5,2,z]),lines.push([1,2,z]),lines.push([1,2,z]),lines.push([1,-2,z]),lines.push([1,-2,z]),lines.push([-1,-2,z]),z=-.5,lines.push([-1,-2,z]),lines.push([-1,2,z]),lines.push([-1,2,z]),lines.push([-1.5,2,z]),lines.push([-1.5,2,z]),lines.push([0,4,z]),lines.push([0,4,z]),lines.push([1.5,2,z]),lines.push([1.5,2,z]),lines.push([1,2,z]),lines.push([1,2,z]),lines.push([1,-2,z]),lines.push([1,-2,z]),lines.push([-1,-2,z]),lines.push([-1,-2,-.5]),lines.push([-1,-2,.5]),lines.push([-1,2,-.5]),lines.push([-1,2,.5]),lines.push([-1.5,2,-.5]),lines.push([-1.5,2,.5]),lines.push([0,4,-.5]),lines.push([0,4,.5]),lines.push([1.5,2,-.5]),lines.push([1.5,2,.5]),lines.push([1,2,-.5]),lines.push([1,2,.5]),lines.push([1,-2,-.5]),lines.push([1,-2,.5]),lines.flat()}(),is_orthographic=this.context.viewport.constructor===orthographic_viewport.A,view_at=new vector3.P(this.unproject([100,100,0]));let view_from=new vector3.P(this.context.viewport.cameraPosition);if(is_orthographic){const cam_pos_z=new vector3.P(this.context.viewport.cameraPosition)[2];view_from=new vector3.P([view_at[0],view_at[1],cam_pos_z])}const dir=new vector3.P([view_at[0]-view_from[0],view_at[1]-view_from[1],view_at[2]-view_from[2]]);dir.normalize(),dir.scale(9999);const pos=new vector3.P([view_from[0]+dir[0],view_from[1]+dir[1],view_from[2]+dir[2]]),lines=[],zoom=this.context.viewport.zoom,zoom_scale=Math.pow(2,zoom),scale=is_orthographic?15/zoom_scale:99;for(let i=0;i<model_lines.length/3;i+=1){const x=model_lines[3*i+0]*scale+pos[0],y=model_lines[3*i+1]*scale+pos[1],z=model_lines[3*i+2]*scale+pos[2];lines.push(x,y,z)}const color=this.props.color.map((x=>(x??0)/255));color[3]=1;const grids=new model.K(device,{id:`${this.props.id}-grids`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",uniforms:{uColor:Array.from(color)},geometry:new geometry.V({topology:"line-list",attributes:{positions:new Float32Array(lines)},vertexCount:lines.length/3}),modules:[project32.A],isInstanced:!1});return{model:grids,models:[grids].filter(Boolean),modelsByName:{grids:grids}}}}NorthArrow3DLayer.layerName="NorthArrow3DLayer",NorthArrow3DLayer.defaultProps={"@@type":"NorthArrow3DLayer",name:"NorthArrow3D",id:"north-arrow-layer",visible:!0,color:[0,0,0,1]}},"./packages/subsurface-viewer/src/layers/polylines/polylinesLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return PolylinesLayer}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts"),path_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/path-layer/path-layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js");class PrivatePolylinesLayer extends path_layer.A{constructor(props){super(props)}getShaders(){return{vs:"#version 300 es\n#define SHADER_NAME path-layer-vertex-shader\n\nin vec2 positions;\n\nin float instanceTypes;\nin vec3 instanceStartPositions;\nin vec3 instanceEndPositions;\nin vec3 instanceLeftPositions;\nin vec3 instanceRightPositions;\nin vec3 instanceLeftPositions64Low;\nin vec3 instanceStartPositions64Low;\nin vec3 instanceEndPositions64Low;\nin vec3 instanceRightPositions64Low;\nin float instanceStrokeWidths;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\nuniform bool ZIncreasingDownwards;\n\nout vec4 vColor;\nout vec2 vCornerOffset;\nout float vMiterLength;\nout vec2 vPathPosition;\nout float vPathLength;\nout float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  vec3 leftPosition  = instanceLeftPositions;\n  vec3 startPosition = instanceStartPositions;\n  vec3 leftPos64Low  = instanceLeftPositions64Low;\n  vec3 startPos64Low = instanceStartPositions64Low;\n\n  vec3 rightposition = instanceRightPositions;\n  vec3 endPosition   = instanceEndPositions;\n  vec3 rightPos64Low = instanceRightPositions64Low;\n  vec3 endPos64Low   = instanceEndPositions64Low;\n\n  if(ZIncreasingDownwards) {\n    leftPosition.z *= -1.0;\n    startPosition.z *= -1.0;\n    leftPos64Low.z  *= -1.0;\n    startPos64Low.z *= -1.0;\n    rightposition.z *= -1.0;\n    endPosition.z   *= -1.0;\n    rightPos64Low.z *= -1.0;\n    endPos64Low.z   *= -1.0; \n  }\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(leftPosition, startPosition, isEnd);\n  vec3 prevPosition64Low = mix(leftPos64Low, startPos64Low, isEnd);\n\n  vec3 currPosition = mix(startPosition, endPosition, isEnd);\n  vec3 currPosition64Low = mix(startPos64Low, endPos64Low, isEnd);\n\n  vec3 nextPosition = mix(endPosition, rightposition, isEnd);\n  vec3 nextPosition64Low = mix(endPos64Low, rightPos64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nin vec4 vColor;\nin vec2 vCornerOffset;\nin float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nin vec2 vPathPosition;\nin float vPathLength;\nin float vJointType;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  fragColor = vColor;\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[project32.A,picking.A]}}draw(args){args.uniforms.ZIncreasingDownwards=this.props.ZIncreasingDownwards;const{gl:gl}=this.context;let restoreDepthTest=!1;"boolean"!=typeof this.props.depthTest||this.props.depthTest||(restoreDepthTest=!0,gl.disable(gl.DEPTH_TEST)),super.draw({uniforms:args.uniforms}),restoreDepthTest&&gl.enable(gl.DEPTH_TEST)}}PrivatePolylinesLayer.layerName="PrivatePolylinesLayer";class PolylinesLayer extends composite_layer.A{renderLayers(){const data=this.state.dataAttributes,_pathType=data.pathType;return[new PrivatePolylinesLayer(this.getSubLayerProps({id:"polylines-layer",widthUnits:this.props.widthUnits,pickable:this.props.pickable,billboard:!0,jointRounded:!0,capRounded:!0,data:data,_pathType:_pathType,getColor:()=>this.props.color,getWidth:()=>this.props.linesWidth,updateTriggers:{getColor:[this.props.color],getWidth:[this.props.linesWidth]},depthTest:this.props.depthTest,ZIncreasingDownwards:this.props.ZIncreasingDownwards}))]}initializeState(){const dataAttributes=this.rebuildDataAttributes(!0);this.setState({dataAttributes:dataAttributes})}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.polylinePoints,oldProps.polylinePoints)&&(0,lodash.isEqual)(props.startIndices,oldProps.startIndices)&&(0,lodash.isEqual)(props.polylinesClosed,oldProps.polylinesClosed)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){const dataAttributes=this.rebuildDataAttributes(!1);this.setState({dataAttributes:dataAttributes})}}rebuildDataAttributes(reportBoundingBox){const dataArrays=this.loadData();if("function"==typeof this.props.reportBoundingBox&&reportBoundingBox){const boundingBox=(0,layerTools.dL)(dataArrays.positions);this.props.reportBoundingBox({layerBoundingBox:boundingBox})}return{length:dataArrays.linesCount,startIndices:dataArrays.startIndices,attributes:{getPath:{value:dataArrays.positions,size:3}},pathType:dataArrays.pathType}}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1;if(void 0!==info.coordinate?.[2]){const depth=(this.props.ZIncreasingDownwards?-info.coordinate[2]:info.coordinate[2])/Math.max(.001,zScale);layer_properties.push((0,layerTools.e2)("Depth",depth))}return{...info,properties:layer_properties}}loadData(){if(this.props.polylinePoints instanceof Float32Array&&this.props.startIndices instanceof Uint32Array&&!this.props.polylinesClosed)return{linesCount:this.props.startIndices.length-1,positions:this.props.polylinePoints,startIndices:this.props.startIndices,pathType:"open"};const data=this.closePolylines();return{linesCount:data.startIndices.length,positions:new Float32Array(data.polylinePoints),startIndices:new Uint32Array(data.startIndices),pathType:data.pathType}}toArray(data){return Array.isArray(data)?data:Array.from(data)}closePolylines(){const points=this.toArray(this.props.polylinePoints),startIndices=this.toArray(this.props.startIndices);this.normalizeStartIndices(startIndices,points.length/3);const isClosedFunc=this.createIsClosedFunc();if(!isClosedFunc.func)return{polylinePoints:points,startIndices:startIndices,pathType:isClosedFunc.pathType};let startIndexShift=0;const closedPoints=[],closedStartIndices=[],linesCount=this.props.startIndices.length-1;for(let i=0;i<linesCount;++i){const isClosed=isClosedFunc.func(i);closedStartIndices.push(this.props.startIndices[i]+startIndexShift),isClosed?(this.closePolyline(points,startIndices,i,closedPoints),++startIndexShift):this.copyPolyline(points,startIndices,i,closedPoints)}return{polylinePoints:closedPoints,startIndices:closedStartIndices,pathType:isClosedFunc.pathType}}normalizeStartIndices(startIndices,pointsCount){startIndices.slice(-1)[0]<pointsCount&&startIndices.push(pointsCount)}copyPolyline(points,startIndices,lineIndex,outPoints){const startPoint=startIndices[lineIndex],endPoint=startIndices[lineIndex+1];for(let idx=startPoint;idx<endPoint;++idx)outPoints.push(...this.getPolylinePoint(points,idx))}closePolyline(points,startIndices,lineIndex,outPoints){this.copyPolyline(points,startIndices,lineIndex,outPoints);const startPoint=startIndices[lineIndex];outPoints.push(...this.getPolylinePoint(points,startPoint))}getPolylinePoint(points,index){return points.slice(3*index,3*(index+1))}createIsClosedFunc(){return!0===this.props.polylinesClosed?{func:()=>!0,pathType:"loop"}:Array.isArray(this.props.polylinesClosed)?{func:lineIndex=>this.props.polylinesClosed[lineIndex],pathType:null}:{func:null,pathType:"open"}}}PolylinesLayer.layerName="PolylinesLayer",PolylinesLayer.defaultProps={"@@type":"PolylinesLayer",name:"PolylinesLayer",id:"polylines-layer",widthUnits:"pixels",linesWidth:5,color:[0,0,200,255],pickable:!0,visible:!0,depthTest:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/shader_modules/index.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{D0:function(){return decoder},oS:function(){return localPhongLighting},BF:function(){return utilities}});const DEFAULT_DECODER={rgbScaler:[1,1,1],floatScaler:1,offset:0,step:0};const decoder={name:"decoder",fs:"struct Decoder\n{\n  vec3 rgbScaler; // r, g and b multipliers\n  float floatScaler; // value multiplier\n  float offset; // translation of the r, g, b sum\n  float step; // discretize the value in a number of steps\n};\n\nuniform Decoder decoder;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\n// Decode the RGB value using the decoder parameter.\nfloat decode_rgb2float(vec3 rgb, Decoder dec) {\n  rgb *= dec.rgbScaler * vec3(16711680.0, 65280.0, 255.0); //255*256*256, 255*256, 255\n  float value = (rgb.r + rgb.g + rgb.b + dec.offset) * dec.floatScaler;\n\n  // Value must be in [0, 1] and step in (0, 1]\n  value = floor(value / dec.step + 0.5) * dec.step;\n\n  // If colorMapRangeMin/Max specified, color map will span this interval.\n  float x  = value * (valueRangeMax - valueRangeMin) + valueRangeMin;\n  x = (x - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n  x = max(0.0, x);\n  x = min(1.0, x);\n\n  return x;\n}\n\n// Decode the RGB value using the decoder uniform.\nfloat decode_rgb2float(vec3 rgb) {\n  return decode_rgb2float(rgb, decoder);\n}\n",getUniforms:function getUniforms(opts){if(opts&&opts.valueDecoder){const{rgbScaler:rgbScaler=DEFAULT_DECODER.rgbScaler,floatScaler:floatScaler=DEFAULT_DECODER.floatScaler,offset:offset=DEFAULT_DECODER.offset,step:step=DEFAULT_DECODER.step}=opts.valueDecoder;return{"decoder.rgbScaler":rgbScaler,"decoder.floatScaler":floatScaler,"decoder.offset":offset,"decoder.step":Math.max(step,1e-7)}}return{}}};const localPhongLighting={name:"localPhongLighting",fs:"\n// Note: modification of luma.gl's functions to get two sided phong lighting.\n// Ref original file modules/shadertools/src/modules/phong-lighting/phong-lighting.glsl.ts in luma source.\n\nvec3 getPhongLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    \n  vec3 halfway_direction = normalize(light_direction + view_direction);   \n  float lambertian = abs(dot(light_direction, normal_worldspace));\n\n  float specular_angle = abs(dot(normal_worldspace, halfway_direction));\n\n  float specular = pow(specular_angle, lighting_uShininess);       \n  return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;    \n}\n\nvec3 getPhongLightColor(vec3 surfaceColor,vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n\n vec3 lightColor = surfaceColor;\n\n if (lighting_uEnabled) {\n   vec3 view_direction = normalize(cameraPosition - position_worldspace);\n   lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n   for (int i = 0; i < MAX_LIGHTS; i++) {\n     if (i >= lighting_uPointLightCount) {\n       break;\n     }\n     PointLight pointLight = lighting_uPointLight[i];\n     vec3 light_position_worldspace = pointLight.position;\n     vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n     lightColor += getPhongLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n   }\n\n   for (int i = 0; i < MAX_LIGHTS; i++) {\n     if (i >= lighting_uDirectionalLightCount) {\n       break;\n     }\n     DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n     lightColor += getPhongLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n   }\n }\n return lightColor;\n}\n",dependencies:[__webpack_require__("./node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/phong-lighting/phong-lighting.js").p]},utilities={name:"utilities",fs:"vec4 encodeVertexIndexToRGB (int vertexIndex) {\n\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n \n    if (vertexIndex >= (256 * 256) - 1) {\n       r = floor(float(vertexIndex) / (256.0 * 256.0));\n       vertexIndex -= int(r * (256.0 * 256.0));\n    }\n \n    if (vertexIndex >= 256 - 1) {\n       g = floor(float(vertexIndex) / 256.0);\n       vertexIndex -= int(g * 256.0);\n    }\n \n    b = float(vertexIndex);\n \n    return vec4(r / 255.0, g / 255.0, b / 255.0, 1.0);   \n }\n "}},"./packages/subsurface-viewer/src/layers/utils/layerTools.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{M1:function(){return getWellLayerByTypeAndSelectedWells},M5:function(){return getImageData},T3:function(){return getLayersById},d8:function(){return getModelMatrixScale},dL:function(){return defineBoundingBox},e2:function(){return createPropertyData},eo:function(){return getLayersByType},gU:function(){return isDrawingEnabled},pK:function(){return getModelMatrix}});var _emerson_eps_color_tables___WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),_emerson_eps_color_tables_dist_component_Utils_legendCommonFunction__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/component/Utils/legendCommonFunction.js"),math_gl__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@math.gl/core/dist/classes/matrix4.js");function createPropertyData(name,value,color){return{name:name,value:value,color:color}}function getModelMatrix(deg,x,y){const rad=.017453*deg,IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],m1=new math_gl__WEBPACK_IMPORTED_MODULE_2__.k(IDENTITY).translate([-x,-y,0,1]),mRot=new math_gl__WEBPACK_IMPORTED_MODULE_2__.k(IDENTITY).rotateZ(rad),m2=new math_gl__WEBPACK_IMPORTED_MODULE_2__.k(IDENTITY).translate([x,y,0,1]);mRot.multiplyRight(m1);return m2.multiplyRight(mRot)}function getModelMatrixScale(scaleZ){return new math_gl__WEBPACK_IMPORTED_MODULE_2__.k([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]).scale([1,1,scaleZ])}function getLayersByType(layers,type){return layers?layers.filter((l=>l?.constructor.name===type)):[]}function getWellLayerByTypeAndSelectedWells(layers,type,selectedWell){return layers&&selectedWell?layers.filter((l=>l?.constructor.name===type&&l.props.data?.features?.find((item=>item.properties.name===selectedWell)))):[]}function getLayersById(layers,id){return layers?layers.filter((l=>l.id===id)):[]}function isDrawingEnabled(layer_manager){const drawing_layer=layer_manager.getLayers({layerIds:["drawing-layer"]})?.[0];return drawing_layer&&drawing_layer.props.visible&&"view"!=drawing_layer.props.mode}function defineBoundingBox(dataArray,zIncreasingDownwards=!1){const length=dataArray.length;let minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY,minZ=Number.POSITIVE_INFINITY,maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY,maxZ=Number.NEGATIVE_INFINITY;for(let i=0;i<length;i+=3){const x=dataArray[i],y=dataArray[i+1],z=dataArray[i+2];minX=x<minX?x:minX,minY=y<minY?y:minY,minZ=z<minZ?z:minZ,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,maxZ=z>maxZ?z:maxZ}return zIncreasingDownwards&&([maxZ,minZ]=[-minZ,-maxZ]),[minX,minY,minZ,maxX,maxY,maxZ]}function getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined=void 0!==colorMapFunction,isColorMapNameDefined=!!colorMapName;let colorMap=(0,_emerson_eps_color_tables_dist_component_Utils_legendCommonFunction__WEBPACK_IMPORTED_MODULE_1__.qN)();isColorMapFunctionDefined?colorMap="function"==typeof colorMapFunction?colorMapFunction:()=>colorMapFunction:isColorMapNameDefined&&(colorMap=value=>(0,_emerson_eps_color_tables___WEBPACK_IMPORTED_MODULE_0__.y1)(value,colorMapName,colorTables));const data=new Uint8Array(768);for(let i=0;i<256;i++){const color=colorMap?colorMap(i/255):[0,0,0];color&&(data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2])}return data||[0,0,0]}},"./packages/subsurface-viewer/src/layers/wells/utils/abscissaTransform.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{u:function(){return abscissaTransform}});var lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js"),mathjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js");function computeUnfoldedPath(worldCoordinates){const z=worldCoordinates.map((v=>v[2])),delta=worldCoordinates.map(((v,i,coordinates)=>{const prev=coordinates[i-1]||v;return(0,mathjs__WEBPACK_IMPORTED_MODULE_1__.IoC)([prev[0],prev[1]],[v[0],v[1]])})),a=[];delta.forEach((d=>{const prev=a.at(-1)||0;a.push(d+prev)}));return(0,lodash__WEBPACK_IMPORTED_MODULE_0__.zip)(a,z,[...a].fill(0))}function abscissaTransform(featureCollection){const featureCollectionCopy=(0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(featureCollection);for(const feature of featureCollectionCopy.features){const geometryCollection=feature.geometry;for(const geometry of geometryCollection.geometries)if("LineString"===geometry.type){const transformedCoordinates=computeUnfoldedPath(geometry.coordinates);geometry.coordinates=transformedCoordinates}else if("Point"===geometry.type){const coordinates=geometry.coordinates;geometry.coordinates=[0,coordinates[2],0]}}return featureCollectionCopy}},"./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Ay:function(){return WellsLayer},YC:function(){return getSize}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),orbit_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orbit-viewport.js"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts"),path_style_extension=__webpack_require__("./node_modules/@deck.gl/extensions/dist/path-style/path-style-extension.js"),geojson_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js"),path_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/path-layer/path-layer.js"),text_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/text-layer/text-layer.js"),dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),pureFunctionsAny_generated=__webpack_require__("./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"),webgl_constants=__webpack_require__("./node_modules/@luma.gl/constants/dist/webgl-constants.js"),src=__webpack_require__("./node_modules/d3/src/index.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),abscissaTransform=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/utils/abscissaTransform.ts"),esm=__webpack_require__("./node_modules/@turf/simplify/dist/esm/index.js");function removeConsecutiveDuplicates(coords,mds){const keep=coords.map(((e,index,arr)=>!(index<arr.length-1)||(e[0]!==arr[index+1][0]||e[1]!==arr[index+1][1]||e[2]!==arr[index+1][2])));return[coords=coords.filter(((_e,index)=>keep[index])),mds=mds.filter(((_e,index)=>keep[index]))]}function CatmullRom1D(P0,P1,P2,P3,t){const tt=t*t,ttt=t*t*t,dist_p0_p1=Math.sqrt((P1-P0)*(P1-P0)+(P1-P0)*(P1-P0)+(P1-P0)*(P1-P0)),dist_p1_p2=Math.sqrt((P1-P2)*(P1-P2)+(P1-P2)*(P1-P2)+(P1-P2)*(P1-P2)),dist_p2_p3=Math.sqrt((P3-P2)*(P3-P2)+(P3-P2)*(P3-P2)+(P3-P2)*(P3-P2)),t01=Math.pow(dist_p0_p1,.5),t12=Math.pow(dist_p1_p2,.5),t23=Math.pow(dist_p2_p3,.5),m1=P2-P1+t12*((P1-P0)/t01-(P2-P0)/(t01+t12)),m2=P2-P1+t12*((P3-P2)/t23-(P3-P1)/(t12+t23));return(2*(P1-P2)+m1+m2)*ttt+(-3*(P1-P2)-m1-m1-m2)*tt+m1*t+P1}function CatmullRom(P0,P1,P2,P3,t){const tt=t*t,ttt=t*t*t,dist_p0_p1=Math.sqrt((P1[0]-P0[0])*(P1[0]-P0[0])+(P1[1]-P0[1])*(P1[1]-P0[1])+(P1[2]-P0[2])*(P1[2]-P0[2])),dist_p1_p2=Math.sqrt((P1[0]-P2[0])*(P1[0]-P2[0])+(P1[1]-P2[1])*(P1[1]-P2[1])+(P1[2]-P2[2])*(P1[2]-P2[2])),dist_p2_p3=Math.sqrt((P3[0]-P2[0])*(P3[0]-P2[0])+(P3[1]-P2[1])*(P3[1]-P2[1])+(P3[2]-P2[2])*(P3[2]-P2[2])),t01=Math.pow(dist_p0_p1,.5),t12=Math.pow(dist_p1_p2,.5),t23=Math.pow(dist_p2_p3,.5),m1_x=P2[0]-P1[0]+t12*((P1[0]-P0[0])/t01-(P2[0]-P0[0])/(t01+t12)),m1_y=P2[1]-P1[1]+t12*((P1[1]-P0[1])/t01-(P2[1]-P0[1])/(t01+t12)),m1_z=P2[2]-P1[2]+t12*((P1[2]-P0[2])/t01-(P2[2]-P0[2])/(t01+t12)),m2_x=P2[0]-P1[0]+t12*((P3[0]-P2[0])/t23-(P3[0]-P1[0])/(t12+t23)),m2_y=P2[1]-P1[1]+t12*((P3[1]-P2[1])/t23-(P3[1]-P1[1])/(t12+t23)),m2_z=P2[2]-P1[2]+t12*((P3[2]-P2[2])/t23-(P3[2]-P1[2])/(t12+t23)),a_x=2*(P1[0]-P2[0])+m1_x+m2_x,a_y=2*(P1[1]-P2[1])+m1_y+m2_y,a_z=2*(P1[2]-P2[2])+m1_z+m2_z,b_x=-3*(P1[0]-P2[0])-m1_x-m1_x-m2_x,b_y=-3*(P1[1]-P2[1])-m1_y-m1_y-m2_y,b_z=-3*(P1[2]-P2[2])-m1_z-m1_z-m2_z,c_y=m1_y,c_z=m1_z;return[a_x*ttt+b_x*tt+m1_x*t+P1[0],a_y*ttt+b_y*tt+c_y*t+P1[1],a_z*ttt+b_z*tt+c_z*t+P1[2]]}function multiply(pair,factor){return[pair[0]*factor,pair[1]*factor]}const LINE="line",POINT="point",DEFAULT_POINT_SIZE=8,DEFAULT_LINE_WIDTH=5,DEFAULT_DASH=[5,5];function getDashFactor(accessor,width_accessor,offset=0){return(object,objectInfo)=>{let width=DEFAULT_LINE_WIDTH;"function"==typeof width_accessor?width=width_accessor(object):width_accessor&&(width=width_accessor);const factor=width/(width+offset);let dash=[0,0];return"function"==typeof accessor?dash=accessor(object,objectInfo):accessor?dash=accessor:accessor&&(dash=DEFAULT_DASH),2==dash.length?multiply(dash,factor):multiply(DEFAULT_DASH,factor)}}function getColor(accessor){return accessor||((object,objectInfo)=>{if("function"==typeof accessor){const color=accessor(object,objectInfo);if(color)return color}return object.properties?.color})}function getSize(type,accessor,offset=0){return"function"==typeof accessor?object=>accessor(object)+offset:0==accessor?0:accessor>0?accessor+offset:type==LINE?DEFAULT_LINE_WIDTH+offset:type==POINT?DEFAULT_POINT_SIZE+offset:0}class WellsLayer extends composite_layer.A{initializeState(){let data=this.props.data;const refine=this.props.refine;if(!data||(0,lodash.isEmpty)(data))return;this.props.ZIncreasingDownwards&&(data=function invertPath(data_in){const data=(0,lodash.cloneDeep)(data_in),no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1],wellHead=geometryCollection?.geometries[0];if(wellHead.coordinates?.[2]&&(wellHead.coordinates[2]*=-1),void 0===lineString.coordinates?.length)continue;const coords_inverted=lineString.coordinates.map((e=>[e[0],e[1],-e[2]]));data.features[well_no].geometry.geometries[1].coordinates=coords_inverted}return data}(data)),this.props.section&&(data=(0,abscissaTransform.u)(data)),function checkWells(data){const no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;let coords=lineString.coordinates;const wellHead=geometryCollection?.geometries[0];wellHead.coordinates&&2===wellHead.coordinates.length&&wellHead.coordinates.push(coords[0][2]);const mds=data.features[well_no].properties?.md;if(void 0===mds)continue;const nOrig=coords.length;[coords,mds[0]]=removeConsecutiveDuplicates(coords,mds[0]);const n=coords.length;n!=nOrig&&console.warn("Well number ",well_no," contains duplicates."),n<=1||(data.features[well_no].geometry.geometries[1].coordinates=coords,data.features[well_no].properties&&(data.features[well_no].properties.md=mds))}}(data);const coarseData=function coarsenWells(data_in){const data=(0,lodash.cloneDeep)(data_in),no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0!==lineString.coordinates?.length)if(lineString.coordinates.every((e=>e[0]===lineString.coordinates[0][0]&&e[1]===lineString.coordinates[0][1]))){const n=lineString.coordinates.length,coordsSimplified=[lineString.coordinates[0],lineString.coordinates[n-1]];lineString.coordinates=coordsSimplified}else{const options={tolerance:.01,highQuality:!1,mutate:!1},coordsSimplified=(0,esm.A)(lineString,options);lineString.coordinates=coordsSimplified.coordinates}}return data}(data);data=("number"==typeof refine?refine>1:refine)?function splineRefine(data_in,stepCount=5){if(stepCount<1)return data_in;const data=(0,lodash.cloneDeep)(data_in),no_wells=data.features.length,step=1/stepCount,steps=Array(stepCount-1).fill(0).map(((_x,index)=>(index+1)*step));for(let well_no=0;well_no<no_wells;well_no++){const mds=data.features[well_no].properties?.md;if(void 0===mds)continue;const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;const coords=lineString.coordinates,n=coords.length;if(n<=1)continue;const ts=n>3?steps:[],P_first=[coords[0][0]-coords[1][0]+coords[0][0],coords[0][1]-coords[1][1]+coords[0][1],coords[0][2]-coords[1][2]+coords[0][2]],md_first=mds[0][0]-mds[0][1]+mds[0][0],P_n=[coords[n-1][0]-coords[n-2][0]+coords[n-1][0],coords[n-1][1]-coords[n-2][1]+coords[n-1][1],coords[n-1][2]-coords[n-2][2]+coords[n-1][2]],md_n=mds[0][n-1]-mds[0][n-2]+mds[0][n-1],newCoordinates=[],newMds=[];newMds.push([]);for(let i=0;i<n-1;i+=1){let P0,P1,P2,P3,md0,md1,md2,md3;if(0===i?(P0=P_first,P1=coords[i+0],P2=coords[i+1],P3=coords[i+2],md0=md_first,md1=mds[0][i+0],md2=mds[0][i+1],md3=mds[0][i+2]):i===n-2?(P0=coords[n-3],P1=coords[n-2],P2=coords[n-1],P3=P_n,md0=mds[0][n-3],md1=mds[0][n-2],md2=mds[0][n-1],md3=md_n):(P0=coords[i-1],P1=coords[i-0],P2=coords[i+1],P3=coords[i+2],md0=mds[0][i-1],md1=mds[0][i-0],md2=mds[0][i+1],md3=mds[0][i+2]),newCoordinates.push(P1),newMds[0].push(md1),i>1)for(let t_i=0;t_i<ts.length;t_i+=1){const t=ts[t_i],[x,y,z]=CatmullRom(P0,P1,P2,P3,t),md=CatmullRom1D(md0,md1,md2,md3,t);newCoordinates.push([x,y,z]),newMds[0].push(md)}}newCoordinates.push(coords[n-1]),newMds[0].push(mds[0][n-1]),data.features[well_no].geometry.geometries[1].coordinates=newCoordinates,data.features[well_no].properties&&(data.features[well_no].properties.md=newMds)}return data}(data,"number"==typeof refine?refine:5):data,this.setState({...this.state,data:data,coarseData:coarseData})}updateState({props:props,oldProps:oldProps}){(!(0,lodash.isEqual)(props.data,oldProps.data)||!(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards)||!(0,lodash.isEqual)(props.refine,oldProps.refine))&&this.initializeState()}onClick(info){return(0,layerTools.gU)(this.context.layerManager)||this.context.userData.setEditedData({selectedWell:info.object.properties?.name}),!1}setSelection(well,_selection){this.internalState&&this.setState({well:well,selection:_selection})}setMultiSelection(wells){this.internalState&&this.setState({selectedMultiWells:wells})}shouldUpdateState({changeFlags:changeFlags}){return changeFlags.viewportChanged||changeFlags.propsOrDataChanged||"object"==typeof changeFlags.updateTriggersChanged}getLegendData(value){return function getLegendData(logs,wellName,logName,logColor){if(!logs)return null;const log=wellName?logs.find((log=>log.header.well==wellName)):logs[0],logInfo=log?getLogInfo(log,log.header.name,logName):void 0,title="Wells / "+logName;if(log&&"discrete"==logInfo?.description){return{title:title,colorName:logColor,discrete:!0,metadata:log.metadata_discrete[logName].objects}}{const minArray=[],maxArray=[];return logs.forEach((function(log){const logValues=getLogValues(log,log.header.name,logName);minArray.push(Math.min(...logValues)),maxArray.push(Math.max(...logValues))})),{title:title,colorName:logColor,discrete:!1,valueRange:[Math.min(...minArray),Math.max(...maxArray)]}}}(value,"",this.props.logName,this.props.logColor)}setLegend(value){this.setState({legend:this.getLegendData(value)})}getLogLayer(){const sub_layers=this.internalState?.subLayers,log_layer=(0,layerTools.T3)(sub_layers,"wells-layer-log_curve");return log_layer?.[0]}getSelectionLayer(){const sub_layers=this.internalState?.subLayers,log_layer=(0,layerTools.T3)(sub_layers,"wells-layer-selection");return log_layer?.[0]}getLogCurveData(){const log_layer=this.getLogLayer();return log_layer?.props.data}setupLegend(){const data=this.getLogCurveData();data&&this.setLegend(data)}renderLayers(){if(!this.props.data.features)return[];const data=this.state.data,coarseData=this.state.coarseData,is3d=this.context.viewport.constructor===orbit_viewport.A,isDashed=!!this.props.lineStyle?.dash,extensions=[new path_style_extension.A({dash:isDashed,highPrecisionDash:isDashed})],parameters={[webgl_constants.GL.DEPTH_TEST]:this.props.depthTest,[webgl_constants.GL.POLYGON_OFFSET_FILL]:!0},fastDrawing=this.props.simplifiedRendering,defaultLayerProps={data:data,pickable:!1,stroked:!1,positionFormat:"XYZ",pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale,lineWidthScale:this.props.lineWidthScale,getLineWidth:getSize(LINE,this.props.lineStyle?.width,-1),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,-1),lineBillboard:!0,pointBillboard:!0,parameters:parameters,visible:fastDrawing},colorsLayerProps=this.getSubLayerProps({...defaultLayerProps,id:"colors",pickable:!0,extensions:extensions,getDashArray:getDashFactor(this.props.lineStyle?.dash,getSize(LINE,this.props.lineStyle?.width),-1),visible:!fastDrawing,getLineColor:getColor(this.props.lineStyle?.color),getFillColor:getColor(this.props.wellHeadStyle?.color)}),fastLayerProps=this.getSubLayerProps({...defaultLayerProps,id:"simple",data:coarseData,positionFormat:"XYZ",getLineColor:getColor(this.props.lineStyle?.color),getFillColor:getColor(this.props.wellHeadStyle?.color)}),outlineLayerProps=this.getSubLayerProps({...defaultLayerProps,id:"outline",getLineWidth:getSize(LINE,this.props.lineStyle?.width),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size),extensions:extensions,getDashArray:getDashFactor(this.props.lineStyle?.dash),visible:this.props.outline&&!fastDrawing}),highlightLayerProps=this.getSubLayerProps({...defaultLayerProps,id:"highlight",data:getWellObjectByName(data.features,this.props.selectedWell),getLineWidth:getSize(LINE,this.props.lineStyle?.width,2),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,2),getLineColor:getColor(this.props.lineStyle?.color),getFillColor:getColor(this.props.wellHeadStyle?.color),visible:this.props.logCurves&&!fastDrawing}),highlightMultiWellsLayerProps=this.getSubLayerProps({...defaultLayerProps,id:"highlight2",data:getWellObjectsByName(data.features,this.state.selectedMultiWells),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,2),getFillColor:[255,140,0],getLineColor:[255,140,0],visible:this.props.logCurves&&!fastDrawing}),fastLayer=new geojson_layer.A(fastLayerProps),outlineLayer=new geojson_layer.A(outlineLayerProps),colorsLayer=new geojson_layer.A(colorsLayerProps),highlightLayer=new geojson_layer.A(highlightLayerProps),highlightMultiWellsLayer=new geojson_layer.A(highlightMultiWellsLayerProps),layers=[outlineLayer,new path_layer.A(this.getSubLayerProps({id:"log_curve",data:this.props.logData,positionFormat:"XYZ",pickable:!0,widthScale:10,widthMinPixels:1,miterLimit:100,getPath:d=>getLogPath(data.features,d,this.props.logrunName,this.props.lineStyle?.color),getColor:d=>function getLogColor(d,logrun_name,log_name,logColor,colorTables,colorMappingFunction,isLog){const log_data=getLogValues(d,logrun_name,log_name),log_info=getLogInfo(d,logrun_name,log_name);if(0==log_data.length||null==log_info)return[];const log_color=[];if("continuous"==log_info.description){const min=Math.min(...log_data),max_delta=Math.max(...log_data)-min;log_data.forEach((value=>{const rgb=colorMappingFunction?colorMappingFunction((value-min)/max_delta):(0,dist.y1)((value-min)/max_delta,logColor,colorTables);(0,dist.y1)(value-min/max_delta,logColor,colorTables,isLog),rgb?Array.isArray(rgb)?log_color.push([rgb[0],rgb[1],rgb[2]]):log_color.push([rgb?.r,rgb?.g,rgb?.b]):log_color.push([0,0,0,0])}))}else{const log_attributes=getDiscreteLogMetadata(d,log_name)?.objects,logLength=Object.keys(log_attributes).length,attributesObject={},categorial=!0;Object.keys(log_attributes).forEach((key=>{const point=log_attributes[key][1];let rgb;if(colorMappingFunction)rgb=colorMappingFunction(point,categorial,0,logLength-1);else{const arrayOfColors=(0,dist.jM)(logColor,colorTables,point);arrayOfColors.length||console.error("Empty or missed '"+logColor+"' color table"),rgb=arrayOfColors}rgb&&(Array.isArray(rgb)?3===rgb.length?attributesObject[key]=[[rgb[0],rgb[1],rgb[2]],point]:attributesObject[key]=[[rgb[1],rgb[2],rgb[3]],point]:attributesObject[key]=[[rgb.r,rgb.g,rgb.b],point])})),log_data.forEach((log_value=>{const dl_attrs=Object.entries(attributesObject).find((([,value])=>value[1]==log_value))?.[1];dl_attrs?log_color.push(dl_attrs[0]):log_color.push([0,0,0,0])}))}return log_color}(d,this.props.logrunName,this.props.logName,this.props.logColor,this.context.userData.colorTables,this.props.colorMappingFunction,this.props.isLog),getWidth:d=>this.props.logRadius||getLogWidth(d,this.props.logrunName,this.props.logName),updateTriggers:{getColor:[this.props.logrunName,this.props.logName,this.props.logColor,this.context.userData.colorTables,this.props.isLog],getWidth:[this.props.logrunName,this.props.logName,this.props.logRadius],getPath:["XYZ"]},onDataLoad:value=>{this.setLegend(value)},parameters:parameters,visible:this.props.logCurves&&!fastDrawing})),colorsLayer,highlightLayer,highlightMultiWellsLayer,new path_layer.A(this.getSubLayerProps({id:"selection",data:this.props.logData,positionFormat:"XYZ",pickable:!1,widthScale:10,widthMinPixels:1,miterLimit:100,getPath:d=>function getLogPath1(wells_data,d,selectedWell,selection,logrun_name,trajectory_line_color){if(!selection||selectedWell!==d.header.well)return[];const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_xyz=getTrajectory(well_object,trajectory_line_color),well_mds=getWellMds(well_object);if(null==well_xyz||null==well_mds||0==well_xyz.length||0==well_mds.length)return[];const log_mds=getLogMd(d,logrun_name);if(!log_mds)return[];const log_xyz=[];let md0=selection[0];if(void 0!==md0){let md1=selection[1];md1==md0&&(md1=void 0);const mdFirst=well_mds[0],mdLast=well_mds[well_mds.length-1];if(void 0!==md1&&md0>md1){const tmp=md0;md0=md1,md1=tmp}const delta=2;if(md0-delta>mdFirst){let xyz=getPositionByMD(well_xyz,well_mds,md0-delta);log_xyz.push(xyz),xyz=getPositionByMD(well_xyz,well_mds,md0),log_xyz.push(xyz)}if(void 0!==md1){const _md1=md1;let index=0;if(well_mds.forEach((md=>{if(md0<=md&&md<=_md1){const xyz=well_xyz[index];log_xyz.push(xyz)}index++})),_md1+delta<mdLast){let xyz=getPositionByMD(well_xyz,well_mds,_md1);log_xyz.push(xyz),xyz=getPositionByMD(well_xyz,well_mds,_md1+delta),log_xyz.push(xyz)}}}return log_xyz}(data.features,d,this.state.well,this.state.selection,this.props.logrunName,this.props.lineStyle?.color),getColor:d=>function getLogColor1(wells_data,d,selectedWell,selection,logrun_name){if(!selection||selectedWell!==d.header.well)return[];const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_mds=getWellMds(well_object),log_mds=getLogMd(d,logrun_name);if(!log_mds||0===log_mds.length)return[];const log_color=[];let md0=selection[0];if(void 0!==md0){const mdFirst=well_mds[0],mdLast=well_mds[well_mds.length-1];let md1=selection[1];md1==md0&&(md1=void 0);let swap=!1;if(void 0!==md1&&md0>md1){const tmp=md0;md0=md1,md1=tmp,swap=!0}const delta=2;if(md0-delta>mdFirst&&log_color.push(swap?[0,255,0,128]:[255,0,0,128]),void 0!==md1){const _md1=md1;log_color.push([128,128,128,128]),well_mds.forEach((md=>{md0<=md&&md<=_md1&&log_color.push([128,128,128,128])})),_md1+delta<mdLast&&log_color.push(swap?[255,0,0,128]:[0,255,0,128])}}return log_color}(data.features,d,this.state.well,this.state.selection,this.props.logrunName),getWidth:d=>1.5*this.props.logRadius||getLogWidth(d,this.props.logrunName,this.props.logName),updateTriggers:{getColor:[this.props.logrunName,this.state.well,this.state.selection],getWidth:[this.props.logrunName,this.props.logName,this.props.logRadius],getPath:["XYZ",this.props.logrunName,this.state.well,this.state.selection]},onDataLoad:value=>{this.setLegend(value)},parameters:parameters,visible:this.props.logCurves&&!fastDrawing})),new text_layer.A(this.getSubLayerProps({id:"names",data:data.features,getPosition:d=>function getAnnotationPosition(well_data,name_at_top,view_is_3d,color_accessor){if(name_at_top){let top;const well_head=getWellHeadPosition(well_data);if(well_data)top=well_head;else{const trajectory=getTrajectory(well_data,color_accessor);top=trajectory?.at(0)}if(top)return view_is_3d?top:[top[0],top[1],0]}else{let bot;const trajectory=getTrajectory(well_data,color_accessor);if(bot=trajectory?trajectory?.at(-1):getWellHeadPosition(well_data),bot)return view_is_3d?bot:[bot[0],bot[1],0]}return null}(d,this.props.wellNameAtTop,is3d,this.props.lineStyle?.color),getText:d=>d.properties?.name,getColor:this.props.wellNameColor,getAnchor:"start",getAlignmentBaseline:"bottom",getSize:this.props.wellNameSize,updateTriggers:{getPosition:[this.props.wellNameAtTop,is3d,this.props.lineStyle?.color]},parameters:parameters,visible:this.props.wellNameVisible&&!fastDrawing}))];return fastDrawing&&layers.push(fastLayer),layers}getPickingInfo({info:info}){if(!info.object)return{...info,properties:[],logName:""};const coordinate=info.coordinate||[0,0,0],zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1;void 0!==coordinate[2]&&(coordinate[2]/=Math.max(.001,zScale));let md_property=function getMdProperty(coord,feature,accessor,featureType){if("points"===featureType)return null;const md=function getMd(coord,feature,accessor){if(!feature.properties?.md?.[0]||!feature.geometry)return null;const measured_depths=feature.properties.md[0],trajectory3D=getTrajectory(feature,accessor);if(null==trajectory3D)return null;let trajectory;if(2==coord.length){trajectory=trajectory3D.map((v=>v.slice(0,2)))}else trajectory=trajectory3D;return interpolateDataOnTrajectory(coord,measured_depths,trajectory)}(coord,feature,accessor);if(null!=md){const prop_name="MD "+feature.properties?.name;return(0,layerTools.e2)(prop_name,md,feature.properties?.color)}return null}(coordinate,info.object,this.props.lineStyle?.color,info.featureType);md_property||(md_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,"MD"));let tvd_property=function getTvdProperty(coord,feature,accessor,featureType){if("points"===featureType)return null;const tvd=function getTvd(coord,feature,accessor){const trajectory3D=getTrajectory(feature,accessor);if(null==trajectory3D||trajectory3D?.length<=1){const wellhead_xyz=getWellHeadPosition(feature);return wellhead_xyz?.[2]??null}let trajectory;if(2==coord.length){const trajectory2D=trajectory3D?.map((v=>v.slice(0,2)));trajectory=trajectory2D}else trajectory=trajectory3D;const tvds=trajectory3D.map((v=>v[2]));return interpolateDataOnTrajectory(coord,tvds,trajectory)}(coord,feature,accessor);if(null!=tvd){const prop_name="TVD "+feature.properties?.name;return(0,layerTools.e2)(prop_name,tvd,feature.properties?.color)}return null}(coordinate,info.object,this.props.lineStyle?.color,info.featureType);tvd_property||(tvd_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,"TVD"));const log_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,this.props.logName),inverted_tvd_property=tvd_property&&{...tvd_property,value:-1*tvd_property?.value},layer_properties=[];return md_property&&layer_properties.push(md_property),inverted_tvd_property&&layer_properties.push(inverted_tvd_property),log_property&&layer_properties.push(log_property),{...info,properties:layer_properties,logName:log_property?.name||""}}}function getColumn(data,col){const column=[];for(let i=0;i<data.length;i++)column.push(data[i][col]);return column}function getLogMd(d,logrun_name){if(!isSelectedLogRun(d,logrun_name))return[];const log_id=function getLogIndexByNames(d,names){for(const name of names){const index=getLogIndexByName(d,name);if(index>=0)return index}return-1}(d,["DEPTH","DEPT","MD","TDEP","MD_RKB"]);return log_id>=0?getColumn(d.data,log_id):[]}function getLogValues(d,logrun_name,log_name){if(!isSelectedLogRun(d,logrun_name))return[];const log_id=getLogIndexByName(d,log_name);return log_id>=0?getColumn(d.data,log_id):[]}function getLogInfo(d,logrun_name,log_name){if(!isSelectedLogRun(d,logrun_name))return;const log_id=getLogIndexByName(d,log_name);return d.curves[log_id]}function getDiscreteLogMetadata(d,log_name){return d?.metadata_discrete[log_name]}function isSelectedLogRun(d,logrun_name){return d.header.name.toLowerCase()===logrun_name.toLowerCase()}function getWellObjectByName(wells_data,name){return wells_data?.find((item=>item.properties?.name?.toLowerCase()===name?.toLowerCase()))}function getWellObjectsByName(wells_data,name){const res=[];for(let i=0;i<name?.length;i++)wells_data?.find((item=>{item.properties?.name?.toLowerCase()===name[i]?.toLowerCase()&&res.push(item)}));return res}function getWellHeadPosition(well_object){return function getPointGeometry(well_object){return well_object.geometry?.geometries.find((item=>"Point"==item.type))}(well_object)?.coordinates}function getTrajectory(well_object,color_accessor){return function isTrajectoryVisible(well_object,color_accessor){let alpha;const accessor=getColor(color_accessor);return alpha="function"==typeof accessor?accessor(well_object)?.[3]:accessor?.[3],0!==alpha}(well_object,color_accessor)?function getLineStringGeometry(well_object){return well_object.geometry?.geometries.find((item=>"LineString"==item.type))}(well_object)?.coordinates:void 0}function getWellMds(well_object){return well_object.properties?.md[0]}function getPositionByMD(well_xyz,well_mds,md){const[l_idx,h_idx]=function getNeighboringMdIndices(mds,md){const idx=mds.findIndex((x=>x>=md));return 0===idx?[idx,idx+1]:[idx-1,idx]}(well_mds,md),md_low=well_mds[l_idx],md_normalized=(md-md_low)/(well_mds[h_idx]-md_low);return(0,src.KVc)(well_xyz[l_idx],well_xyz[h_idx])(md_normalized)}function getLogPath(wells_data,d,logrun_name,trajectory_line_color){const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_xyz=getTrajectory(well_object,trajectory_line_color),well_mds=getWellMds(well_object);if(null==well_xyz||null==well_mds||0==well_xyz.length||0==well_mds.length)return[];const log_xyz=[];return getLogMd(d,logrun_name).forEach((md=>{const xyz=getPositionByMD(well_xyz,well_mds,md);log_xyz.push(xyz)})),log_xyz}function getLogIndexByName(d,log_name){const name=log_name.toLowerCase();return d.curves.findIndex((item=>item.name.toLowerCase()===name))}function getLogWidth(d,logrun_name,log_name){return getLogValues(d,logrun_name,log_name)}function squared_distance(a,b){const dx=a[0]-b[0],dy=a[1]-b[1];return dx*dx+dy*dy}function distToSegmentSquared(v,w,p){const l2=squared_distance(v,w);if(0==l2)return squared_distance(p,v);let t=((p[0]-v[0])*(w[0]-v[0])+(p[1]-v[1])*(w[1]-v[1]))/l2;return t=Math.max(0,Math.min(1,t)),squared_distance(p,[v[0]+t*(w[0]-v[0]),v[1]+t*(w[1]-v[1])])}function interpolateDataOnTrajectory(coord,data,trajectory){if(data.length<=1||data.length!=trajectory.length)return-1;const index0=getSegmentIndex(coord,trajectory),index1=index0+1,data0=data[index0],data1=data[index1],survey0=trajectory[index0],survey1=trajectory[index1],dv=(0,pureFunctionsAny_generated.IoC)(survey0,survey1);if(0===dv)return-1;const v0=(0,pureFunctionsAny_generated.ReH)(coord,survey0),v1=(0,pureFunctionsAny_generated.ReH)(survey1,survey0),scalar_projection=(0,pureFunctionsAny_generated.Omf)(v0,v1)/(dv*dv);return data0*(1-scalar_projection)+data1*scalar_projection}function getSegmentIndex(coord,path){let min_d=Number.MAX_VALUE,segment_index=0;for(let i=0;i<path?.length-1;i++){const d=distToSegmentSquared(path[i],path[i+1],coord);d>min_d||(segment_index=i,min_d=d)}return segment_index}function getLogProperty(coord,wells_data,log_data,logrun_name,log_name){if(!log_data.data)return null;const segment_index=function getLogSegmentIndex(coord,wells_data,log_data,logrun_name){return getSegmentIndex(coord,getLogPath(wells_data,log_data,logrun_name))}(coord,wells_data,log_data,logrun_name);let dl_attrs,log_value=getLogValues(log_data,logrun_name,log_name)[segment_index];const dl_metadata=getDiscreteLogMetadata(log_data,log_name)?.objects;dl_metadata&&(dl_attrs=Object.entries(dl_metadata).find((([,value])=>value[1]==log_value)));const log=getLogInfo(log_data,logrun_name,log_name)?.name,prop_name=log+" "+log_data.header.well;if(log_value=dl_attrs?dl_attrs[0]+" ("+log_value+")":log_value,log_value){const well_object=getWellObjectByName(wells_data,log_data.header.well);return(0,layerTools.e2)(prop_name,log_value,well_object?.properties?.color)}return null}WellsLayer.layerName="WellsLayer",WellsLayer.defaultProps={"@@type":"WellsLayer",name:"Wells",id:"wells-layer",autoHighlight:!0,opacity:1,lineWidthScale:1,pointRadiusScale:1,lineStyle:{dash:!1},outline:!0,logRadius:10,logCurves:!0,refine:!1,visible:!0,wellNameVisible:!1,wellNameAtTop:!1,wellNameSize:14,wellNameColor:[0,0,0,255],selectedWell:"@@#editedData.selectedWells",depthTest:!0,ZIncreasingDownwards:!0,simplifiedRendering:!1,section:!1,onDataLoad:(data,context)=>function onDataLoad(data,context){const bbox=function GetBoundingBox(data){let xMin=9999999999,yMin=9999999999,zMin=9999999999,xMax=-9999999999,yMax=-9999999999,zMax=-9999999999;const no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;const coords=lineString.coordinates,n=coords.length;for(let i=0;i<n;i++){const xyz=coords[i];xMin=xyz[0]<xMin?xyz[0]:xMin,yMin=xyz[1]<yMin?xyz[1]:yMin,zMin=xyz[2]<zMin?xyz[2]:zMin,xMax=xyz[0]>xMax?xyz[0]:xMax,yMax=xyz[1]>yMax?xyz[1]:yMax,zMax=xyz[2]>zMax?xyz[2]:zMax}}return[xMin,yMin,zMin,xMax,yMax,zMax]}(data);void 0!==context.layer.props.reportBoundingBox&&context.layer.props.reportBoundingBox({layerBoundingBox:bbox})}(data,context)}},"./packages/subsurface-viewer/src/utils/camera.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{IX:function(){return getZoom},KD:function(){return scaleZoom},Qh:function(){return useLateralZoom}});var lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js"),lodash__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/index.js");const proportionalZoom=(zoom,scaleFactor)=>zoom*Math.sqrt(Math.max(scaleFactor||0,0)||1),scaleZoom=(verticalFactor,zoom)=>[zoom,proportionalZoom(zoom,verticalFactor)],getZoom=(viewport,fb_zoom)=>{const zoom=viewport.zoom??fb_zoom;return viewport.show3D?zoom:viewport.verticalScale?scaleZoom(viewport.verticalScale,zoom):zoom},useLateralZoom=viewState=>react__WEBPACK_IMPORTED_MODULE_1__.useMemo((()=>{const zoom=lodash__WEBPACK_IMPORTED_MODULE_0___default().find(viewState)?.zoom;return lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(zoom)?zoom[0]:zoom??-5}),[viewState])},"./packages/subsurface-viewer/src/utils/configTools.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{u:function(){return findConfig}});var lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js");function findConfig(config,path,fallbackPath=void 0){const mainConfig=findConfigImpl(config,path),fallbackConfig=findConfigImpl(config,fallbackPath);return fallbackConfig?(0,lodash__WEBPACK_IMPORTED_MODULE_0__.merge)({},{data:fallbackConfig},{data:mainConfig}).data:mainConfig}function findConfigImpl(config,path){if(!config||!path)return;if("string"==typeof path&&(path=path.split("/")),0===path.length)return config;return findConfigImpl(config[path.shift()],path)}},"./packages/subsurface-viewer/src/utils/event.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{f:function(){return useScaleFactor},h:function(){return useShiftHeld}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");const useScaleFactor=initialValue=>{const[factor,setFactor]=react__WEBPACK_IMPORTED_MODULE_0__.useState(initialValue??1),elementRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);return react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{const keyDownHandler=e=>{const arrowEvent=function convertToArrowEvent(event){if("keydown"===event.type)switch(event.key){case"ArrowUp":case"ArrowDown":case"PageUp":case"PageDown":return{key:event.key,shiftModifier:event.shiftKey};default:return null}return null}(e);arrowEvent&&(setFactor((oldValue=>function updateZScaleReducer(zScale,action){return zScale*function getZScaleModifier(arrowEvent){let scaleFactor=0;switch(arrowEvent.key){case"ArrowUp":scaleFactor=.05;break;case"ArrowDown":scaleFactor=-.05;break;case"PageUp":scaleFactor=.25;break;case"PageDown":scaleFactor=-.25}return arrowEvent.shiftModifier&&(scaleFactor/=5),1+scaleFactor}(action)}(oldValue,arrowEvent))),e.stopPropagation())},element=elementRef.current;return element?.addEventListener("keydown",keyDownHandler,!0),()=>{element?.removeEventListener("keydown",keyDownHandler)}}),[elementRef]),{factor:factor,setFactor:setFactor,elementRef:elementRef}};function useShiftHeld(){const[shiftHeld,setShiftHeld]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),divRef=react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);return react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{const keyDownHandler=e=>{"Shift"===e.key&&setShiftHeld(!0)},keyUpHandler=e=>{"Shift"===e.key&&setShiftHeld(!1)},element=divRef.current;return element?.addEventListener("keydown",keyDownHandler,!0),element?.addEventListener("keyup",keyUpHandler,!0),()=>{element?.removeEventListener("keydown",keyDownHandler),element?.removeEventListener("keyup",keyUpHandler)}}),[setShiftHeld,divRef]),{divRef:divRef,shiftHeld:shiftHeld}}},"./packages/subsurface-viewer/src/viewports/intersectionViewport.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return IntersectionViewport}});var _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/viewport.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@math.gl/core/dist/classes/matrix4.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@math.gl/core/dist/lib/common.js");const viewMatrix=(new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__.k).lookAt({eye:[0,-1,0],up:[0,0,1],center:[0,0,0]});function getProjectionMatrix({width:width,height:height,near:near,far:far,padding:padding}){let left=-width/2,right=width/2,bottom=-height/2,top=height/2;if(padding){const{left:l=0,right:r=0,top:t=0,bottom:b=0}=padding,offsetX=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)((l+width-r)/2,0,width)-width/2,offsetY=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.qE)((t+height-b)/2,0,height)-height/2;left-=offsetX,right-=offsetX,bottom+=offsetY,top+=offsetY}return(new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__.k).ortho({left:left,right:right,bottom:bottom,top:top,near:near,far:far})}class IntersectionViewport extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__.A{constructor(props){const{width:width,height:height,near:near=.1,far:far=1e3,zoom:zoom=0,target:target=[0,0,0],padding:padding=null,flipY:flipY=!0}=props,zoomX=Array.isArray(zoom)?zoom[0]:zoom,zoomY=Array.isArray(zoom)?zoom[1]:zoom,zoom_=Math.min(zoomX,zoomY),scale=Math.pow(2,zoom_);let distanceScales;if(zoomX!==zoomY){const scaleX=Math.pow(2,zoomX),scaleY=Math.pow(2,zoomY);distanceScales={unitsPerMeter:[scaleX/scale,1,scaleY/scale],metersPerUnit:[scale/scaleX,1,scale/scaleY]}}super({...props,longitude:void 0,position:target,viewMatrix:viewMatrix.clone().scale([scale,scale,scale*(flipY?-1:1)]),projectionMatrix:getProjectionMatrix({width:width||1,height:height||1,padding:padding,near:near,far:far}),zoom:zoom_,distanceScales:distanceScales})}}},"./packages/wsc-common/dist/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Vr:function(){return validateColorTables},Dd:function(){return validateLayers},i6:function(){return validateSchema}});var dist_ajv=__webpack_require__("./node_modules/ajv/dist/ajv.js"),ajv_default=__webpack_require__.n(dist_ajv),Wells_namespaceObject=JSON.parse('{"$comment":"Inspired from https://github.com/geojson/schema","$schema":"http://json-schema.org/draft-07/schema#","$id":"inputSchema/Wells.json","title":"GeoJSON FeatureCollection","type":"object","required":["type","features"],"properties":{"type":{"type":"string","enum":["FeatureCollection"]},"features":{"type":"array","items":{"title":"GeoJSON Feature","type":"object","required":["type","properties","geometry"],"properties":{"type":{"type":"string","enum":["Feature"]},"id":{"oneOf":[{"type":"number"},{"type":"string"}]},"properties":{"oneOf":[{"type":"null"},{"type":"object"}]},"geometry":{"title":"GeoJSON GeometryCollection","type":"object","required":["type","geometries"],"properties":{"type":{"type":"string","enum":["GeometryCollection"]},"geometries":{"type":"array","items":{"oneOf":[{"title":"GeoJSON Point","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["Point"]},"coordinates":{"type":"array","minItems":2,"items":{"type":"number"}}}},{"title":"GeoJSON LineString","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["LineString"]},"coordinates":{"type":"array","minItems":2,"items":{"type":"array","minItems":2,"items":{"type":"number"}}}}}]}}}}}}}}}'),WellLog_namespaceObject=JSON.parse('{"$comment":"See https://jsonwelllogformat.org","$id":"inputSchema/WellLog.json","type":"object","properties":{"header":{"$ref":"#/definitions/header"},"curves":{"type":"array","items":{"$ref":"#/definitions/curve"}},"data":{"type":"array","items":{"$ref":"#/definitions/data_row"}},"metadata_discrete":{"type":"object"}},"required":["curves","data","header"],"definitions":{"header":{"type":"object","properties":{"name":{"type":"string","description":"Log name"},"description":{"type":"string","description":"Log description"},"externalIds":{"type":"object","description":"Record<string,string>; IDs within external storage, key being the storage name, and value being the ID."},"well":{"type":"string","description":"Well name"},"wellbore":{"type":"string","description":"wellbore name"},"field":{"type":"string","description":"Field name"},"country":{"type":"string","description":"Country of operation"},"date":{"type":"string","description":"datetime; Logging date"},"operator":{"type":"string","description":"Operator company name"},"serviceCompany":{"type":"string","description":"Service company name"},"source":{"type":"string","description":"Source system or process of this log"},"runNumber":{"type":"string","description":"Run number"},"elevation":{"type":"number","description":"float; Vertical distance between measured depth 0.0 and mean sea level in SI unit (meters)"},"startIndex":{"type":"number","description":"Value of the first index. Unit according to index curve"},"endIndex":{"type":"number","description":"Value of the last index. Unit according to index curve"},"step":{"type":["number","null"],"description":"Distance between indices if regularly sampled. Unit according to index curve. If log is time based, milliseconds assumed. null if irregular step"},"dataUri":{"type":"string","description":"Point to data source in case this is kept separate. Can be absolute or relative according to the URI specification"}}},"curve":{"type":"object","properties":{"name":{"type":"string","description":"Curve name or mnemonic. Mandatory. Non-null"},"description":{"type":["string","null"],"description":"Curve description. Optional"},"quantity":{"type":["string","null"],"description":"Curve quantity such as length, pressure, force etc. Optional"},"unit":{"type":["string","null"],"description":"Unit of measurement such as m, ft, bar, etc. Optional"},"valueType":{"type":["string","null"],"description":"Curve value type: float, integer, string, datetime or boolean. Non-null. Optional. float assumed if not present"},"dimensions":{"type":"number","description":"Number of dimensions. [1,>. Non-null. Optional. 1 assumed if not present"}},"required":["name"]},"data_row":{"type":"array","items":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}]}},"metadata_discrete":{"type":"object"}}}'),WellLogs_namespaceObject=JSON.parse('{"$id":"inputSchema/WellLogs.json","type":"array","items":{"$ref":"./WellLog.json#"}}'),WellLogTemplate_namespaceObject=JSON.parse('{"type":"object","properties":{"name":{"type":"string"},"scale":{"type":"object","properties":{"primary":{"type":"string"},"allowSecondary":{"type":"boolean"}},"required":["primary"]},"tracks":{"type":"array","items":{"$ref":"#/definitions/track"}},"styles":{"type":"array","items":{"$ref":"#/definitions/style"}}},"required":["tracks"],"definitions":{"domain":{"type":"array","minItems":2,"maxItems":2,"items":{"type":"number"}},"css_color":{"type":"string","description":"Any valid CSS color value (named colors, three-digit hex color, six-digit hex color, RGB colors)","examples":["green","#ff8000","rgb(128,33,23)","rgba(128,33,23,0.6)"]},"plot_type":{"enum":["line","linestep","dot","area","differential","gradientfill","stacked"],"default":"line"},"scale_type":{"enum":["log","linear"],"default":"linear"},"plot_prop":{"type":"object","properties":{"scale":{"$ref":"#/definitions/scale_type"},"type":{"$ref":"#/definitions/plot_type"},"color":{"$ref":"#/definitions/css_color"},"inverseColor":{"$ref":"#/definitions/css_color"},"fill":{"$ref":"#/definitions/css_color"},"fillOpacity":{"type":"number","minimum":0,"maximum":1,"default":0.25,"description":"for \'area\' and \'gradientfill\' plots"},"colorTable":{"type":"string","description":"table id (name) for \'gradientfill\' plot"},"inverseColorTable":{"type":"string","description":"table id (name) for \'gradientfill\' plot"},"colorScale":{"$ref":"#/definitions/scale_type","description":"table id (name) for \'gradientfill\' plot"},"inverseColorScale":{"$ref":"#/definitions/scale_type","description":"table id (name) for \'gradientfill\' plot"},"color2":{"$ref":"#/definitions/css_color","description":"for \'differetial\' plot"},"fill2":{"$ref":"#/definitions/css_color","description":"for \'differetial\' plot"},"showLines":{"type":"boolean","description":"for \'stacked\' plot"},"showLabels":{"type":"boolean","description":"for \'stacked\' plot"},"labelRotation":{"type":"number","description":"for \'stacked\' plot"}}},"plot":{"allOf":[{"$ref":"#/definitions/plot_prop"}],"type":"object","properties":{"name":{"type":"string"},"style":{"type":"string"},"scale":{"$ref":"#/definitions/scale_type"},"name2":{"type":"string"}},"required":["name"]},"style":{"allOf":[{"$ref":"#/definitions/plot_prop"}],"type":"object","properties":{"name":{"type":"string"}},"required":["name"]},"track":{"type":"object","properties":{"title":{"type":"string"},"width":{"type":"number","default":3,"description":"relative track width (default as in videx-wellog)"},"required":{"type":"boolean"},"scale":{"$ref":"#/definitions/scale_type"},"domain":{"$ref":"#/definitions/domain"},"plots":{"type":"array","items":{"$ref":"#/definitions/plot"}}},"required":["plots"]}}}'),PieChart_namespaceObject=JSON.parse('{"$comment":"PieChart data schema","$id":"inputSchema/PieChart.json","type":"object","properties":{"pies":{"type":"array","items":{"$ref":"#/definitions/pie"}},"properties":{"type":"array","items":{"$ref":"#/definitions/property"}}},"required":["pies","properties"],"definitions":{"pie":{"type":"object","properties":{"x":{"type":"number","description":"Pie chart y-coordinate"},"y":{"type":"number","description":"Pie chart x-coordinate"},"R":{"type":"number","description":"Pie chart radius."},"fractions":{"type":"array","description":"Number and proportion of slices on pie chart.","items":{"$ref":"#/definitions/fraction"}}},"required":["x","y","R","fractions"]},"property":{"type":"object","properties":{"color":{"type":"array","minItems":3,"maxItems":3,"items":{"type":"number"},"description":"Pie slice color as RGB array."},"label":{"type":"string","description":"Pie slice name."}},"required":["color","label"]},"fraction":{"type":"object","properties":{"value":{"type":"number","description":"Proportion on pie slice."},"idx":{"type":"number","description":"Pie slice color and label indexed from properties array."}},"required":["value","idx"]}}}'),Grid_namespaceObject=JSON.parse('{"$comment":"See https://jsonwelllogformat.org","$id":"inputSchema/Grid.json","type":"array","items":{"$ref":"#/definitions/data_row"},"definitions":{"data_row":{"type":"object","required":["cs","vs"],"properties":{"i":{"type":"number","description":"Cell i-index, increases toward east."},"j":{"type":"number","description":"Cell j-index, increases towards north."},"z":{"type":"number","description":"Cell depth."},"cs":{"type":"array","description":"Cell corners","items":{"$ref":"#/definitions/cell_corner"},"minItems":3},"vs":{"type":"array","description":"Time dependent cell values.","items":{"type":"number"}}}},"cell_corner":{"type":"array","items":{"type":"number"},"minItems":3}}}'),FaultPolygons_namespaceObject=JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$comment":"Inspired from https://geojson.org/schema/FeatureCollection.json","$id":"inputSchema/FaultPolygons.json","title":"GeoJSON FeatureCollection","type":"object","required":["type","features"],"properties":{"type":{"type":"string","enum":["FeatureCollection"]},"features":{"type":"array","items":{"title":"GeoJSON Feature","type":"object","required":["type","properties","geometry"],"properties":{"type":{"type":"string","enum":["Feature"]},"id":{"oneOf":[{"type":"number"},{"type":"string"}]},"properties":{"oneOf":[{"type":"null"},{"type":"object"}]},"geometry":{"title":"GeoJSON Polygon","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["Polygon"]},"coordinates":{"type":"array","items":{"type":"array","minItems":4,"items":{"type":"array","minItems":2,"items":{"type":"number"}}}},"bbox":{"type":"array","minItems":4,"items":{"type":"number"}}}}}}}}}'),ColorTables_namespaceObject=JSON.parse('{"$comment":"ColorTables data schema","$id":"inputSchema/ColorTables.json","type":"array","items":{"$ref":"#/definitions/color-table"},"definitions":{"color-table":{"type":"object","required":["name","discrete","colors"],"properties":{"name":{"type":"string","description":"Color table name"},"discrete":{"type":"boolean","description":"True if color table is for discrete data"},"colors":{"type":"array","description":"Color entries as [anchor, R, G, B] for continuous and [index, R, G, B] for discrete","items":{"$ref":"#/definitions/color-row","minItems":4}},"description":{"type":"string","description":"Description"},"colorNaN":{"$ref":"#/definitions/color-row","description":"Color for NaN/undefined value"},"colorBelow":{"$ref":"#/definitions/color-row","description":"Color for value below minimum color range"},"colorAbove":{"$ref":"#/definitions/color-row","description":"Color for value above minimum color range"}}},"color-row":{"type":"array","items":{"type":"number"},"minItems":3}}}');function validateSchema(data,schema_type){let validator=null;try{validator=function createSchemaValidator(schema_type){const ajv=new(ajv_default())({schemas:[WellLog_namespaceObject]});switch(schema_type){case"Wells":return ajv.compile(Wells_namespaceObject);case"WellLog":return ajv.compile(WellLog_namespaceObject);case"WellLogs":return ajv.compile(WellLogs_namespaceObject);case"WellLogTemplate":return ajv.compile(WellLogTemplate_namespaceObject);case"PieChart":return ajv.compile(PieChart_namespaceObject);case"Grid":return ajv.compile(Grid_namespaceObject);case"FaultPolygons":return ajv.compile(FaultPolygons_namespaceObject);case"ColorTables":return ajv.compile(ColorTables_namespaceObject);default:return null}}(schema_type)}catch(e){throw"Wrong JSON schema for "+schema_type+". "+String(e)}if(!validator)throw"Wrong schema type.";if(validator(data),validator.errors)throw function formatSchemaError(schema_type,errors){let error_text="";error_text=errors[0]?(errors[0].instancePath?errors[0].instancePath+": ":"")+errors[0].message:"JSON schema validation failed";return`${schema_type}: ${error_text}.`}(schema_type,validator.errors)}function validateColorTables(colorTables){validateSchema(colorTables,"ColorTables")}function validateLayers(layers){layers.forEach((layer=>{if(layer.isLoaded){!function validateLayer(layer){switch(layer.id){case"wells-layer":!function validateWellsLayer(wellsLayer){validateSchema(wellsLayer.props.data,"Wells");validateSchema(function getLogData(wellsLayer){var _a;const sub_layers=null===(_a=wellsLayer.internalState)||void 0===_a?void 0:_a.subLayers,log_layer=null==sub_layers?void 0:sub_layers.find((layer=>"wells-layer-log_curve"===layer.id));return null==log_layer?void 0:log_layer.props.data}(wellsLayer),"WellLogs")}(layer);break;case"pie-layer":validateSchema(layer.props.data,"PieChart");break;case"grid-layer":validateSchema(layer.props.data,"Grid");break;case"fault-polygons-layer":validateSchema(layer.props.data,"FaultPolygons");break;default:return}}(layer);try{layer.validateProps()}catch(e){throw`${layer.id}- ${String(e)}`}}}))}},"?d4c0":function(){},"?ccfa":function(){},"?90e7":function(){},"?5693":function(){},"./packages/subsurface-viewer/src/SubsurfaceConfig.json":function(module){"use strict";module.exports=JSON.parse('{"config":{"workerpool":{"maxWorkers":10},"layer":{"TriangleLayer":{"workerpool":{"maxWorkers":10}}}}}')}}]);