"use strict";(self.webpackChunk_webviz_subsurface_components=self.webpackChunk_webviz_subsurface_components||[]).push([[1781],{"./packages/subsurface-viewer/src/storybook/layers/AxesLayer.stories.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{CustomLabel:function(){return CustomLabel},DarkMode:function(){return DarkMode},LightMode:function(){return LightMode},__namedExportsOrder:function(){return __namedExportsOrder}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_deck_gl_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/core/dist/views/orthographic-view.js"),_deck_gl_react__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/react/dist/deckgl.js"),_layers_axes_axesLayer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/subsurface-viewer/src/layers/axes/axesLayer.ts"),_util_color__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./packages/subsurface-viewer/src/storybook/util/color.ts");const stories={component:_deck_gl_react__WEBPACK_IMPORTED_MODULE_2__.A,title:"SubsurfaceViewer / AxesLayer"};__webpack_exports__.default=stories;const layerProps={name:"axes",bounds:[-100,-100,0,100,100,100]},LightMode={render:()=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(_deck_gl_react__WEBPACK_IMPORTED_MODULE_2__.A,{layers:[new _layers_axes_axesLayer__WEBPACK_IMPORTED_MODULE_1__.A({...layerProps})],views:[new _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__.A({})]})},ColoredLabelsComponent=props=>{const layers=[new _layers_axes_axesLayer__WEBPACK_IMPORTED_MODULE_1__.A({...layerProps,labelColor:(0,_util_color__WEBPACK_IMPORTED_MODULE_4__.l)(props.labelColor),axisColor:(0,_util_color__WEBPACK_IMPORTED_MODULE_4__.l)(props.axisColor)})],views=[new _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__.A({})];return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_deck_gl_react__WEBPACK_IMPORTED_MODULE_2__.A,{layers:layers,views:views})},DarkMode={args:{labelColor:"white",axisColor:"white"},parameters:{backgrounds:{default:"dark"}},render:args=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColoredLabelsComponent,args)},CustomLabelsComponent=props=>{const layers=[new _layers_axes_axesLayer__WEBPACK_IMPORTED_MODULE_1__.A({...layerProps,labelColor:(0,_util_color__WEBPACK_IMPORTED_MODULE_4__.l)(props.labelColor),labelFontSize:props.labelFontSize,fontFamily:props.fontFamily})],views=[new _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__.A({})];return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_deck_gl_react__WEBPACK_IMPORTED_MODULE_2__.A,{layers:layers,views:views})},CustomLabel={args:{labelColor:"blue",labelFontSize:10,fontFamily:"math"},render:args=>react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomLabelsComponent,args)},__namedExportsOrder=["LightMode","DarkMode","CustomLabel"];LightMode.parameters={...LightMode.parameters,docs:{...LightMode.parameters?.docs,source:{originalSource:"{\n  render: () => <DeckGL layers={[new AxesLayer({\n    ...layerProps\n  })]} views={[new OrthographicView({})]} />\n}",...LightMode.parameters?.docs?.source}}},DarkMode.parameters={...DarkMode.parameters,docs:{...DarkMode.parameters?.docs,source:{originalSource:'{\n  args: {\n    labelColor: "white",\n    axisColor: "white"\n  },\n  parameters: {\n    backgrounds: {\n      default: "dark"\n    }\n  },\n  render: args => <ColoredLabelsComponent {...args} />\n}',...DarkMode.parameters?.docs?.source}}},CustomLabel.parameters={...CustomLabel.parameters,docs:{...CustomLabel.parameters?.docs,source:{originalSource:'{\n  args: {\n    labelColor: "blue",\n    labelFontSize: 10,\n    fontFamily: "math"\n  },\n  render: args => <CustomLabelsComponent {...args} />\n}',...CustomLabel.parameters?.docs?.source}}}},"./packages/subsurface-viewer/src/extensions/fixed-size-extension.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{$:function(){return FixedSizeExtension}});var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer-extension.js");class FixedSizeExtension extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__.A{getShaders(){return{inject:{"vs:DECKGL_FILTER_SIZE":"size *= gl_Position.w;"}}}}},"./packages/subsurface-viewer/src/layers/axes/axesLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{A:function(){return AxesLayer}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/composite-layer.js"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/viewports/orthographic-viewport.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/constants.js"),text_layer_text_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/text-layer/text-layer.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/lib/layer.js"),project32=__webpack_require__("./node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/model/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/geometry/geometry.js");const defaultProps={name:"Box",id:"box-layer",coordinateSystem:constants.rf.CARTESIAN,lines:[],color:[0,0,0,1]};class BoxLayer extends lib_layer.A{initializeState(context){this.setState(this._getModels(context.device))}shouldUpdateState(){return!0}updateState({context:context}){this.setState(this._getModels(context.device))}_getModels(device){const color=this.props.color.map((x=>(x??0)/255)),grids=new model.K(device,{id:`${this.props.id}-grids`,vs:"#version 300 es\n#define SHADER_NAME axes-grid-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME axes-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",uniforms:{uColor:Array.from(color)},geometry:new geometry.V({topology:"line-list",attributes:{positions:new Float32Array(this.props.lines)},vertexCount:this.props.lines.length/3}),modules:[project32.A],isInstanced:!1});return{model:grids,models:[grids].filter(Boolean),modelsByName:{grids:grids}}}}BoxLayer.layerName="BoxLayer",BoxLayer.defaultProps=defaultProps;var ticks=__webpack_require__("./node_modules/d3-array/src/ticks.js"),fixed_size_extension=__webpack_require__("./packages/subsurface-viewer/src/extensions/fixed-size-extension.ts");class AxesLayer extends composite_layer.A{rebuildData(reportBoundingBox){const bounds=(0,lodash.cloneDeep)(this.props.bounds);this.props.ZIncreasingDownwards&&(bounds[2]*=-1,bounds[5]*=-1),bounds[2]>bounds[5]&&([bounds[2],bounds[5]]=[bounds[5],bounds[2]]),bounds[0]>bounds[3]&&([bounds[0],bounds[3]]=[bounds[3],bounds[0]]),bounds[1]>bounds[4]&&([bounds[1],bounds[4]]=[bounds[4],bounds[1]]);const box_lines=function GetBoxLines(bounds){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5];return[x_min,y_min,z_min,x_max,y_min,z_min,x_min,y_min,z_min,x_min,y_max,z_min,x_min,y_max,z_min,x_max,y_max,z_min,x_max,y_max,z_min,x_max,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_max,x_min,y_min,z_max,x_min,y_max,z_max,x_min,y_max,z_max,x_max,y_max,z_max,x_max,y_max,z_max,x_max,y_min,z_max,x_min,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_min,x_max,y_min,z_max,x_max,y_max,z_min,x_max,y_max,z_max,x_min,y_max,z_min,x_min,y_max,z_max]}(bounds),is_orthographic=this.context.viewport.constructor===orthographic_viewport.A,zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1,[tick_lines,tick_labels]=function GetTickLines(isZIncreasingDownwards,is_orthographic,bounds,viewport,zScale){const ndecimals=0,n_minor_ticks=3,x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],lines=[],tick_labels=[];let x_tick=0,y_tick=0,z_tick=0;const delta=(x_max-x_min+(y_max-y_min)+(z_max-z_min))/3*.025,Lz=LineLengthInPixels([x_min,y_min,z_min*zScale],[x_min,y_min,z_max*zScale],viewport);if(!is_orthographic){const z_ticks=GetTicks(z_min,z_max,Lz);x_tick=x_min,y_tick=y_min;for(let i=0;i<z_ticks.length;i++){const tick=z_ticks[i],label=((isZIncreasingDownwards?-1:1)*tick).toFixed(ndecimals);tick_labels.push(label),lines.push(x_tick,y_tick,tick);const x=-delta*Math.cos(.7853925),y=-delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}if(z_ticks.length>1){const tick1=z_ticks[0],d=(z_ticks[1]-tick1)/(n_minor_ticks+1),z_start=tick1;let i=0;for(;z_start+(i+1)*d<z_max;){const tick=z_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}for(i=0;z_start-(i+1)*d>z_min;){const tick=z_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}}}const Lx=LineLengthInPixels([x_min,y_min,z_min*zScale],[x_max,y_min,z_min*zScale],viewport),x_ticks=GetTicks(x_min,x_max,Lx);y_tick=y_min,z_tick=z_min;for(let i=0;i<x_ticks.length;i++){const tick=x_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label),lines.push(tick,y_tick,z_tick);const z=0,y=-delta;lines.push(tick,y_tick+y,z_tick+z)}if(x_ticks.length>1){const tick1=x_ticks[0],d=(x_ticks[1]-tick1)/(n_minor_ticks+1),x_start=tick1;let i=0;for(;x_start+(i+1)*d<x_max;){const tick=x_start+(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}for(i=0;x_start-(i+1)*d>x_min;){const tick=x_start-(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}}const Ly=LineLengthInPixels([x_min,y_min,z_min*zScale],[x_min,y_max,z_min*zScale],viewport),y_ticks=GetTicks(y_min,y_max,Ly);for(let i=0;i<y_ticks.length;i++){const tick=y_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label);const x_tick=x_min,z_tick=z_min;lines.push(x_tick,tick,z_tick);const z=0,x=-delta;if(lines.push(x_tick+x,tick,z_tick+z),y_ticks.length>1){const tick1=y_ticks[0],d=(y_ticks[1]-tick1)/(n_minor_ticks+1),y_start=tick1;let i=0;for(;y_start+(i+1)*d<y_max;){const tick=y_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}for(i=0;y_start-(i+1)*d>y_min;){const tick=y_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}}}return[lines,tick_labels]}(this.props.ZIncreasingDownwards,is_orthographic,bounds,this.context.viewport,zScale),textlayerData=function maketextLayerData(is_orthographic,tick_lines,tick_labels,bounds,labelFontSize){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],dx=Math.abs(x_max-x_min),dy=Math.abs(y_max-y_min),dz=Math.abs(z_max-z_min),offset=(dx+dy+dz)/3*.1,axisAnnotationData={label:"X",from:[0,0,0],to:[x_max+offset,y_min,z_min],size:labelFontSize+7},data=[axisAnnotationData,{...axisAnnotationData,label:"Y",to:[x_min,y_max+offset,z_min]}];is_orthographic||data.push({...axisAnnotationData,label:"Z",to:[x_min,y_min,z_max+offset]});for(let i=0;i<tick_lines.length/6;i++){const from=[tick_lines[6*i+0],tick_lines[6*i+1],tick_lines[6*i+2]],to=[tick_lines[6*i+3],tick_lines[6*i+4],tick_lines[6*i+5]],label=tick_labels[i];data.push({label:label,from:from,to:to,size:labelFontSize})}return data}(is_orthographic,tick_lines,tick_labels,bounds,this.props.labelFontSize);this.setState({box_lines:box_lines,tick_lines:tick_lines,textlayerData:textlayerData}),void 0!==this.props.reportBoundingBox&&reportBoundingBox&&this.props.reportBoundingBox({layerBoundingBox:bounds})}initializeState(){this.rebuildData(!0)}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.viewportChanged}updateState(){this.rebuildData(!1)}getAnchor(d,is_orthographic){const is_xaxis=d.from[1]!==d.to[1];if(is_orthographic&&is_xaxis)return"middle";const zScale=this.props.modelMatrix?this.props.modelMatrix[10]:1,p0=[d.from[0],d.from[1],d.from[2]*zScale],p1=[d.to[0],d.to[1],d.to[2]*zScale],screen_from=this.context.viewport.project(p0),screen_to=this.context.viewport.project(p1);return"X"!==d.label&&"Y"!==d.label&&"Z"!==d.label&&screen_from[0]<screen_to[0]?"start":"end"}getLabelPosition(d){if("X"!==d.label&&"Y"!==d.label&&"Z"!==d.label){const tick_vec=[d.to[0]-d.from[0],d.to[1]-d.from[1]];d.to[2]&&d.from[2]&&tick_vec.push(d.to[2]-d.from[2]);const s=.5;return[d.to[0]+s*tick_vec[0],d.to[1]+s*tick_vec[1],d.to[2]+s*tick_vec[2]]}return d.to}getBaseLine(d,is_orthographic){if("X"===d.label)return"center";const is_xaxis_label=d.from[1]!==d.to[1];return is_orthographic&&is_xaxis_label?"top":"center"}renderLayers(){const is_orthographic=this.context.viewport.constructor===orthographic_viewport.A,lines=[...this.state.box_lines,...this.state.tick_lines];return[new BoxLayer(this.getSubLayerProps({lines:lines,coordinateSystem:constants.rf.CARTESIAN,color:this.props.axisColor||[0,0,0,255]})),new text_layer_text_layer.A(this.getSubLayerProps({fontFamily:this.props.fontFamily??"Monaco, monospace",data:this.state.textlayerData,id:"text-layer",pickable:!0,getPosition:d=>this.getLabelPosition(d),getText:d=>d.label,sizeUnits:"pixels",getSize:d=>d.size,getAngle:0,getTextAnchor:d=>this.getAnchor(d,is_orthographic),getAlignmentBaseline:d=>this.getBaseLine(d,is_orthographic),coordinateSystem:constants.rf.CARTESIAN,getColor:this.props.labelColor||[0,0,0,255],extensions:[new fixed_size_extension.$]}))]}}function LineLengthInPixels(p0,p1,viewport){const screen_from=viewport.project(p0),screen_to=viewport.project(p1),v=[screen_from[0]-screen_to[0],screen_from[1]-screen_to[1],screen_from[2]-screen_to[2]];return Math.sqrt(v[0]*v[0]+v[1]*v[1])}function GetTicks(min,max,axis_pixel_length){const nTicks=Math.min(Math.round(axis_pixel_length/100)+1,20);return(0,ticks.Ay)(min,max,nTicks)}AxesLayer.layerName="AxesLayer",AxesLayer.defaultProps={"@@type":"AxesLayer",name:"Axes",id:"axes-layer",visible:!0,ZIncreasingDownwards:!0,labelFontSize:12}},"./packages/subsurface-viewer/src/storybook/util/color.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{l:function(){return getRgba}});var d3_color__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/d3-color/src/color.js");function getRgba(color){const c=(0,d3_color__WEBPACK_IMPORTED_MODULE_0__.Qh)(color);return[c.r,c.g,c.b,255*c.opacity]}},"./node_modules/d3-array/src/ticks.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Ay:function(){return ticks},lq:function(){return tickIncrement},sG:function(){return tickStep}});const e10=Math.sqrt(50),e5=Math.sqrt(10),e2=Math.sqrt(2);function tickSpec(start,stop,count){const step=(stop-start)/Math.max(0,count),power=Math.floor(Math.log10(step)),error=step/Math.pow(10,power),factor=error>=e10?10:error>=e5?5:error>=e2?2:1;let i1,i2,inc;return power<0?(inc=Math.pow(10,-power)/factor,i1=Math.round(start*inc),i2=Math.round(stop*inc),i1/inc<start&&++i1,i2/inc>stop&&--i2,inc=-inc):(inc=Math.pow(10,power)*factor,i1=Math.round(start/inc),i2=Math.round(stop/inc),i1*inc<start&&++i1,i2*inc>stop&&--i2),i2<i1&&.5<=count&&count<2?tickSpec(start,stop,2*count):[i1,i2,inc]}function ticks(start,stop,count){if(!((count=+count)>0))return[];if((start=+start)===(stop=+stop))return[start];const reverse=stop<start,[i1,i2,inc]=reverse?tickSpec(stop,start,count):tickSpec(start,stop,count);if(!(i2>=i1))return[];const n=i2-i1+1,ticks=new Array(n);if(reverse)if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i2-i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i2-i)*inc;else if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i1+i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i1+i)*inc;return ticks}function tickIncrement(start,stop,count){return tickSpec(start=+start,stop=+stop,count=+count)[2]}function tickStep(start,stop,count){count=+count;const reverse=(stop=+stop)<(start=+start),inc=reverse?tickIncrement(stop,start,count):tickIncrement(start,stop,count);return(reverse?-1:1)*(inc<0?1/-inc:inc)}}}]);