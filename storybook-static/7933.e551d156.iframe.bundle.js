(self.webpackChunk_webviz_subsurface_components=self.webpackChunk_webviz_subsurface_components||[]).push([[7933],{"./packages/subsurface-viewer/src/SubsurfaceViewer.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/layer.js"),_components_Map__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./packages/subsurface-viewer/src/components/Map.tsx"),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/index.js"),prop_types__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/prop-types/index.js"),prop_types__WEBPACK_IMPORTED_MODULE_4___default=__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__),convert_units__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/convert-units/lib/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_2___default=__webpack_require__.n(convert_units__WEBPACK_IMPORTED_MODULE_2__);const SubsurfaceViewer=({id:id,resources:resources,layers:layers,bounds:bounds,views:views,coords:coords,scale:scale,coordinateUnit:coordinateUnit,legend:legend,toolbar:toolbar,colorTables:colorTables,editedData:editedData,setProps:setProps,checkDatafileSchema:checkDatafileSchema,onMouseEvent:onMouseEvent,selection:selection,getTooltip:getTooltip,cameraPosition:cameraPosition,getCameraPosition:getCameraPosition,isLoadedCallback:isLoadedCallback,triggerHome:triggerHome,triggerResetMultipleWells:triggerResetMultipleWells,lights:lights,children:children})=>{const[layerEditedData,setLayerEditedData]=react__WEBPACK_IMPORTED_MODULE_1__.useState(editedData),[layerInstances,setLayerInstances]=react__WEBPACK_IMPORTED_MODULE_1__.useState([]);react__WEBPACK_IMPORTED_MODULE_1__.useEffect((()=>{if(!layers)return void setLayerInstances([]);if(layers?.[0]instanceof _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_3__.Z)return void setLayerInstances(layers);const enumerations=[];resources&&enumerations.push({resources:resources}),editedData?enumerations.push({editedData:editedData}):enumerations.push({editedData:{}});const layersList=(0,_components_Map__WEBPACK_IMPORTED_MODULE_0__.tX)(layers,enumerations);setLayerInstances(layersList)}),[layers]),react__WEBPACK_IMPORTED_MODULE_1__.useEffect((()=>{editedData&&setLayerEditedData({...layerEditedData,...editedData})}),[editedData]);const setEditedData=react__WEBPACK_IMPORTED_MODULE_1__.useCallback((data=>{null!=setProps&&setProps({editedData:{...layerEditedData,...data}})}),[setProps,layerEditedData]);return coordinateUnit&&!convert_units__WEBPACK_IMPORTED_MODULE_2___default()().possibilities().includes(coordinateUnit)&&(console.error(`Invalid coordinate unit: '${coordinateUnit}'. Valid units are: ${convert_units__WEBPACK_IMPORTED_MODULE_2___default()().possibilities()}`),coordinateUnit=void 0),react__WEBPACK_IMPORTED_MODULE_1__.createElement(_components_Map__WEBPACK_IMPORTED_MODULE_0__.ZP,{id:id,layers:layerInstances,bounds:bounds,views:views,coords:coords,scale:scale,coordinateUnit:coordinateUnit,colorTables:colorTables,setEditedData:setEditedData,checkDatafileSchema:checkDatafileSchema,onMouseEvent:onMouseEvent,selection:selection,getTooltip:getTooltip,cameraPosition:cameraPosition,getCameraPosition:getCameraPosition,isLoadedCallback:isLoadedCallback,triggerHome:triggerHome,triggerResetMultipleWells:triggerResetMultipleWells,lights:lights},children)};SubsurfaceViewer.defaultProps={views:{layout:[1,1],marginPixels:0,showLabel:!1,viewports:[{id:"main-view",show3D:!1,layerIds:[]}]},checkDatafileSchema:!1},SubsurfaceViewer.propTypes={id:prop_types__WEBPACK_IMPORTED_MODULE_4___default().string.isRequired,resources:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),layers:prop_types__WEBPACK_IMPORTED_MODULE_4___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any).isRequired),bounds:prop_types__WEBPACK_IMPORTED_MODULE_4___default().any,views:prop_types__WEBPACK_IMPORTED_MODULE_4___default().any,coords:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,multiPicking:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,pickDepth:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number}),scale:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,incrementValue:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number,widthPerUnit:prop_types__WEBPACK_IMPORTED_MODULE_4___default().number,cssStyle:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any)}),coordinateUnit:prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOf(convert_units__WEBPACK_IMPORTED_MODULE_2___default()().possibilities()),toolbar:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool}),legend:prop_types__WEBPACK_IMPORTED_MODULE_4___default().shape({visible:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool,cssStyle:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),horizontal:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool}),colorTables:prop_types__WEBPACK_IMPORTED_MODULE_4___default().array,editedData:prop_types__WEBPACK_IMPORTED_MODULE_4___default().objectOf(prop_types__WEBPACK_IMPORTED_MODULE_4___default().any),setProps:prop_types__WEBPACK_IMPORTED_MODULE_4___default().func,checkDatafileSchema:prop_types__WEBPACK_IMPORTED_MODULE_4___default().bool},__webpack_exports__.Z=SubsurfaceViewer;try{SubsurfaceViewer.displayName="SubsurfaceViewer",SubsurfaceViewer.__docgenInfo={description:"",displayName:"SubsurfaceViewer",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"string"}},resources:{defaultValue:null,description:"",name:"resources",required:!1,type:{name:"Record<string, unknown>"}},layers:{defaultValue:null,description:"",name:"layers",required:!1,type:{name:"Record<string, unknown>[] | LayersList"}},bounds:{defaultValue:null,description:"",name:"bounds",required:!1,type:{name:"[number, number, number, number] | BoundsAccessor"}},views:{defaultValue:{value:'{\n        layout: [1, 1],\n        marginPixels: 0,\n        showLabel: false,\n        viewports: [{ id: "main-view", show3D: false, layerIds: [] }],\n    }'},description:"",name:"views",required:!1,type:{name:"ViewsType"}},coords:{defaultValue:null,description:"",name:"coords",required:!1,type:{name:"{ visible?: boolean | null; multiPicking?: boolean | null; pickDepth?: number | null | undefined; } | undefined"}},scale:{defaultValue:null,description:"",name:"scale",required:!1,type:{name:"{ visible?: boolean | null; incrementValue?: number | null; widthPerUnit?: number | null | undefined; cssStyle?: Record<string, unknown> | null | undefined; } | undefined"}},coordinateUnit:{defaultValue:null,description:"",name:"coordinateUnit",required:!1,type:{name:"enum",value:[{value:'"m"'},{value:'"mm"'},{value:'"cm"'},{value:'"km"'},{value:'"in"'},{value:'"ft-us"'},{value:'"ft"'},{value:'"mi"'},{value:'"mm2"'},{value:'"cm2"'},{value:'"m2"'},{value:'"ha"'},{value:'"km2"'},{value:'"in2"'},{value:'"ft2"'},{value:'"ac"'},{value:'"mi2"'},{value:'"mcg"'},{value:'"mg"'},{value:'"g"'},{value:'"kg"'},{value:'"oz"'},{value:'"lb"'},{value:'"mt"'},{value:'"t"'},{value:'"mm3"'},{value:'"cm3"'},{value:'"ml"'},{value:'"l"'},{value:'"kl"'},{value:'"m3"'},{value:'"km3"'},{value:'"tsp"'},{value:'"Tbs"'},{value:'"in3"'},{value:'"fl-oz"'},{value:'"cup"'},{value:'"pnt"'},{value:'"qt"'},{value:'"gal"'},{value:'"ft3"'},{value:'"yd3"'},{value:'"mm3/s"'},{value:'"cm3/s"'},{value:'"ml/s"'},{value:'"cl/s"'},{value:'"dl/s"'},{value:'"l/s"'},{value:'"l/min"'},{value:'"l/h"'},{value:'"kl/s"'},{value:'"kl/min"'},{value:'"kl/h"'},{value:'"m3/s"'},{value:'"m3/min"'},{value:'"m3/h"'},{value:'"km3/s"'},{value:'"tsp/s"'},{value:'"Tbs/s"'},{value:'"in3/s"'},{value:'"in3/min"'},{value:'"in3/h"'},{value:'"fl-oz/s"'},{value:'"fl-oz/min"'},{value:'"fl-oz/h"'},{value:'"cup/s"'},{value:'"pnt/s"'},{value:'"pnt/min"'},{value:'"pnt/h"'},{value:'"qt/s"'},{value:'"gal/s"'},{value:'"gal/min"'},{value:'"gal/h"'},{value:'"ft3/s"'},{value:'"ft3/min"'},{value:'"ft3/h"'},{value:'"yd3/s"'},{value:'"yd3/min"'},{value:'"yd3/h"'},{value:'"C"'},{value:'"F"'},{value:'"K"'},{value:'"R"'},{value:'"ns"'},{value:'"mu"'},{value:'"ms"'},{value:'"s"'},{value:'"min"'},{value:'"h"'},{value:'"d"'},{value:'"week"'},{value:'"month"'},{value:'"year"'},{value:'"Hz"'},{value:'"mHz"'},{value:'"kHz"'},{value:'"MHz"'},{value:'"GHz"'},{value:'"THz"'},{value:'"rpm"'},{value:'"deg/s"'},{value:'"rad/s"'},{value:'"m/s"'},{value:'"km/h"'},{value:'"m/h"'},{value:'"knot"'},{value:'"ft/s"'},{value:'"s/m"'},{value:'"min/km"'},{value:'"s/ft"'},{value:'"Pa"'},{value:'"hPa"'},{value:'"kPa"'},{value:'"MPa"'},{value:'"bar"'},{value:'"torr"'},{value:'"psi"'},{value:'"ksi"'},{value:'"b"'},{value:'"Kb"'},{value:'"Mb"'},{value:'"Gb"'},{value:'"Tb"'},{value:'"B"'},{value:'"KB"'},{value:'"MB"'},{value:'"GB"'},{value:'"TB"'},{value:'"lx"'},{value:'"ft-cd"'},{value:'"ppm"'},{value:'"ppb"'},{value:'"ppt"'},{value:'"ppq"'},{value:'"V"'},{value:'"mV"'},{value:'"kV"'},{value:'"A"'},{value:'"mA"'},{value:'"kA"'},{value:'"W"'},{value:'"mW"'},{value:'"kW"'},{value:'"MW"'},{value:'"GW"'},{value:'"VA"'},{value:'"mVA"'},{value:'"kVA"'},{value:'"MVA"'},{value:'"GVA"'},{value:'"VAR"'},{value:'"mVAR"'},{value:'"kVAR"'},{value:'"MVAR"'},{value:'"GVAR"'},{value:'"Wh"'},{value:'"mWh"'},{value:'"kWh"'},{value:'"MWh"'},{value:'"GWh"'},{value:'"J"'},{value:'"kJ"'},{value:'"VARh"'},{value:'"mVARh"'},{value:'"kVARh"'},{value:'"MVARh"'},{value:'"GVARH"'},{value:'"deg"'},{value:'"rad"'},{value:'"grad"'},{value:'"arcmin"'},{value:'"arcsec"'}]}},toolbar:{defaultValue:null,description:"",name:"toolbar",required:!1,type:{name:"{ visible?: boolean | null; }"}},legend:{defaultValue:null,description:"",name:"legend",required:!1,type:{name:"{ visible?: boolean | null; cssStyle?: Record<string, unknown> | null; horizontal?: boolean | null | undefined; } | undefined"}},colorTables:{defaultValue:null,description:"",name:"colorTables",required:!1,type:{name:"colorTablesArray"}},editedData:{defaultValue:null,description:"",name:"editedData",required:!1,type:{name:"Record<string, unknown>"}},setProps:{defaultValue:null,description:"",name:"setProps",required:!1,type:{name:"((data: Record<string, unknown>) => void)"}},checkDatafileSchema:{defaultValue:{value:"false"},description:"Validate JSON datafile against schema",name:"checkDatafileSchema",required:!1,type:{name:"boolean"}},onMouseEvent:{defaultValue:null,description:"For get mouse events",name:"onMouseEvent",required:!1,type:{name:"((event: MapMouseEvent) => void)"}},getCameraPosition:{defaultValue:null,description:"",name:"getCameraPosition",required:!1,type:{name:"((input: ViewStateType) => void)"}},isLoadedCallback:{defaultValue:null,description:"Will be called after all layers have finished loading data.",name:"isLoadedCallback",required:!1,type:{name:"((arg: boolean) => void)"}},triggerHome:{defaultValue:null,description:"If changed will reset camera to default position.",name:"triggerHome",required:!1,type:{name:"number"}},triggerResetMultipleWells:{defaultValue:null,description:"",name:"triggerResetMultipleWells",required:!1,type:{name:"number"}},selection:{defaultValue:null,description:"Range selection of the current well",name:"selection",required:!1,type:{name:"{ well: string; selection: [number, number | undefined] | undefined; } | undefined"}},getTooltip:{defaultValue:null,description:"Override default tooltip with a callback.",name:"getTooltip",required:!1,type:{name:"TooltipCallback"}},cameraPosition:{defaultValue:null,description:"",name:"cameraPosition",required:!1,type:{name:"ViewStateType"}},lights:{defaultValue:null,description:"",name:"lights",required:!1,type:{name:"LightsType"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/SubsurfaceViewer.tsx#SubsurfaceViewer"]={docgenInfo:SubsurfaceViewer.__docgenInfo,name:"SubsurfaceViewer",path:"packages/subsurface-viewer/src/SubsurfaceViewer.tsx#SubsurfaceViewer"})}catch(__react_docgen_typescript_loader_error){}},"./packages/subsurface-viewer/src/components/DistanceScale.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/convert-units/lib/index.js"),convert_units__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(convert_units__WEBPACK_IMPORTED_MODULE_1__);const DistanceScale=({zoom:zoom,incrementValue:incrementValue,widthPerUnit:widthPerUnit,style:style,scaleUnit:scaleUnit})=>{if(!(zoom&&widthPerUnit&&incrementValue&&scaleUnit))return null;if(!convert_units__WEBPACK_IMPORTED_MODULE_1___default()().possibilities().includes(scaleUnit))return null;const widthInUnits=widthPerUnit/Math.pow(2,zoom),scaleValue=widthInUnits<incrementValue?Math.round(widthInUnits):(num=widthInUnits,step=incrementValue,Math.floor(num/step+.5)*step);var num,step;const convertedUnit=convert_units__WEBPACK_IMPORTED_MODULE_1___default()(scaleValue).from(scaleUnit).toBest().unit,convertedValue=convert_units__WEBPACK_IMPORTED_MODULE_1___default()(scaleValue).from(scaleUnit).toBest().val,scaleRulerStyle={width:scaleValue*Math.pow(2,zoom),height:"4px",border:"2px solid",borderTop:"none",display:"inline-block",marginLeft:"3px"};return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{style:{position:"absolute",...style}},react__WEBPACK_IMPORTED_MODULE_0__.createElement("label",{style:{...style}},convertedValue.toFixed(0),convertedUnit),react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{style:scaleRulerStyle}))};DistanceScale.defaultProps={zoom:-3,incrementValue:100,widthPerUnit:100,scaleUnit:"m"},__webpack_exports__.Z=DistanceScale;try{DistanceScale.displayName="DistanceScale",DistanceScale.__docgenInfo={description:"",displayName:"DistanceScale",props:{zoom:{defaultValue:{value:"-3"},description:"",name:"zoom",required:!1,type:{name:"number"}},incrementValue:{defaultValue:{value:"100"},description:"",name:"incrementValue",required:!1,type:{name:"number | null"}},widthPerUnit:{defaultValue:{value:"100"},description:"",name:"widthPerUnit",required:!1,type:{name:"number | null"}},style:{defaultValue:null,description:"",name:"style",required:!1,type:{name:"Record<string, unknown>"}},scaleUnit:{defaultValue:{value:"m"},description:"",name:"scaleUnit",required:!1,type:{name:"enum",value:[{value:'"m"'},{value:'"mm"'},{value:'"cm"'},{value:'"km"'},{value:'"in"'},{value:'"ft-us"'},{value:'"ft"'},{value:'"mi"'},{value:'"mm2"'},{value:'"cm2"'},{value:'"m2"'},{value:'"ha"'},{value:'"km2"'},{value:'"in2"'},{value:'"ft2"'},{value:'"ac"'},{value:'"mi2"'},{value:'"mcg"'},{value:'"mg"'},{value:'"g"'},{value:'"kg"'},{value:'"oz"'},{value:'"lb"'},{value:'"mt"'},{value:'"t"'},{value:'"mm3"'},{value:'"cm3"'},{value:'"ml"'},{value:'"l"'},{value:'"kl"'},{value:'"m3"'},{value:'"km3"'},{value:'"tsp"'},{value:'"Tbs"'},{value:'"in3"'},{value:'"fl-oz"'},{value:'"cup"'},{value:'"pnt"'},{value:'"qt"'},{value:'"gal"'},{value:'"ft3"'},{value:'"yd3"'},{value:'"mm3/s"'},{value:'"cm3/s"'},{value:'"ml/s"'},{value:'"cl/s"'},{value:'"dl/s"'},{value:'"l/s"'},{value:'"l/min"'},{value:'"l/h"'},{value:'"kl/s"'},{value:'"kl/min"'},{value:'"kl/h"'},{value:'"m3/s"'},{value:'"m3/min"'},{value:'"m3/h"'},{value:'"km3/s"'},{value:'"tsp/s"'},{value:'"Tbs/s"'},{value:'"in3/s"'},{value:'"in3/min"'},{value:'"in3/h"'},{value:'"fl-oz/s"'},{value:'"fl-oz/min"'},{value:'"fl-oz/h"'},{value:'"cup/s"'},{value:'"pnt/s"'},{value:'"pnt/min"'},{value:'"pnt/h"'},{value:'"qt/s"'},{value:'"gal/s"'},{value:'"gal/min"'},{value:'"gal/h"'},{value:'"ft3/s"'},{value:'"ft3/min"'},{value:'"ft3/h"'},{value:'"yd3/s"'},{value:'"yd3/min"'},{value:'"yd3/h"'},{value:'"C"'},{value:'"F"'},{value:'"K"'},{value:'"R"'},{value:'"ns"'},{value:'"mu"'},{value:'"ms"'},{value:'"s"'},{value:'"min"'},{value:'"h"'},{value:'"d"'},{value:'"week"'},{value:'"month"'},{value:'"year"'},{value:'"Hz"'},{value:'"mHz"'},{value:'"kHz"'},{value:'"MHz"'},{value:'"GHz"'},{value:'"THz"'},{value:'"rpm"'},{value:'"deg/s"'},{value:'"rad/s"'},{value:'"m/s"'},{value:'"km/h"'},{value:'"m/h"'},{value:'"knot"'},{value:'"ft/s"'},{value:'"s/m"'},{value:'"min/km"'},{value:'"s/ft"'},{value:'"Pa"'},{value:'"hPa"'},{value:'"kPa"'},{value:'"MPa"'},{value:'"bar"'},{value:'"torr"'},{value:'"psi"'},{value:'"ksi"'},{value:'"b"'},{value:'"Kb"'},{value:'"Mb"'},{value:'"Gb"'},{value:'"Tb"'},{value:'"B"'},{value:'"KB"'},{value:'"MB"'},{value:'"GB"'},{value:'"TB"'},{value:'"lx"'},{value:'"ft-cd"'},{value:'"ppm"'},{value:'"ppb"'},{value:'"ppt"'},{value:'"ppq"'},{value:'"V"'},{value:'"mV"'},{value:'"kV"'},{value:'"A"'},{value:'"mA"'},{value:'"kA"'},{value:'"W"'},{value:'"mW"'},{value:'"kW"'},{value:'"MW"'},{value:'"GW"'},{value:'"VA"'},{value:'"mVA"'},{value:'"kVA"'},{value:'"MVA"'},{value:'"GVA"'},{value:'"VAR"'},{value:'"mVAR"'},{value:'"kVAR"'},{value:'"MVAR"'},{value:'"GVAR"'},{value:'"Wh"'},{value:'"mWh"'},{value:'"kWh"'},{value:'"MWh"'},{value:'"GWh"'},{value:'"J"'},{value:'"kJ"'},{value:'"VARh"'},{value:'"mVARh"'},{value:'"kVARh"'},{value:'"MVARh"'},{value:'"GVARH"'},{value:'"deg"'},{value:'"rad"'},{value:'"grad"'},{value:'"arcmin"'},{value:'"arcsec"'}]}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/components/DistanceScale.tsx#DistanceScale"]={docgenInfo:DistanceScale.__docgenInfo,name:"DistanceScale",path:"packages/subsurface-viewer/src/components/DistanceScale.tsx#DistanceScale"})}catch(__react_docgen_typescript_loader_error){}},"./packages/subsurface-viewer/src/components/InfoCard.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),_mui_material__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@mui/material/Table/Table.js"),_mui_material__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/@mui/material/TableCell/TableCell.js"),_mui_material__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./node_modules/@mui/material/TableRow/TableRow.js"),_mui_material__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__("./node_modules/@mui/material/Collapse/Collapse.js"),_mui_material__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__("./node_modules/@mui/material/TableBody/TableBody.js"),_mui_material__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__("./node_modules/@mui/material/TableContainer/TableContainer.js"),_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Icon/index.js"),_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Button/Button.js"),_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@equinor/eds-icons/dist/esm/index.js"),_mui_system__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@mui/system/esm/styled.js"),d3_color__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__("./node_modules/d3-color/src/color.js");_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.J.add({arrow_drop_up:_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__.sBW,arrow_drop_down:_equinor_eds_icons__WEBPACK_IMPORTED_MODULE_1__._Oe});const StyledTable=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.Z)(_mui_material__WEBPACK_IMPORTED_MODULE_4__.Z)({"& > *":{backgroundColor:"#ffffffcc",color:"#000000ff",border:"2px solid #ccc",padding:"0px",borderRadius:"5px",position:"absolute",bottom:0,left:0,marginLeft:"3px",marginBottom:"3px"}}),StyledTableCell=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.Z)(_mui_material__WEBPACK_IMPORTED_MODULE_5__.Z)({border:"none",padding:0,width:"20px"}),StyledTableRow=(0,_mui_system__WEBPACK_IMPORTED_MODULE_3__.Z)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Z)({"& > *":{padding:0}});function Row(props){const{layer_data:layer_data}=props,[open,setOpen]=react__WEBPACK_IMPORTED_MODULE_0__.useState(!0);return 0==layer_data.properties?.length?null:react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableCell,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_7__.z,{style:{padding:0},variant:"ghost",onClick:()=>setOpen(!open)},open?react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.J,{color:"currentColor",name:"arrow_drop_up"}):react__WEBPACK_IMPORTED_MODULE_0__.createElement(_equinor_eds_core_react__WEBPACK_IMPORTED_MODULE_2__.J,{color:"currentColor",name:"arrow_drop_down"}))),react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.Z,null," ",layer_data.layerName," ")),react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.Z,{style:{paddingBottom:0,paddingTop:0},colSpan:2},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_8__.Z,{in:open,timeout:"auto",unmountOnExit:!0},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_4__.Z,{size:"small","aria-label":"properties"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_9__.Z,null,layer_data.properties?.map((propertyRow=>{return react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTableRow,{key:propertyRow.name},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.Z,{style:{border:"none",paddingLeft:10,paddingRight:10}},propertyRow.color&&react__WEBPACK_IMPORTED_MODULE_0__.createElement("span",{style:{color:(0,d3_color__WEBPACK_IMPORTED_MODULE_10__.B8)(...propertyRow.color).toString()}},"â¬¤"),propertyRow.name),react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_5__.Z,{style:{border:"none",textAlign:"right"}},"number"==typeof propertyRow.value?(num=propertyRow.value,parseFloat(num.toExponential(Math.max(1,2+Math.log10(Math.abs(num)))))):propertyRow.value));var num}))))))))}const InfoCard=props=>{const[infoCardData,setInfoCardData]=react__WEBPACK_IMPORTED_MODULE_0__.useState(null);return react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{if(0===props.pickInfos.length)return void setInfoCardData(null);const topObject=props.pickInfos[0];if(void 0===topObject.coordinate||topObject.coordinate.length<2)return;const xy_properties=[];xy_properties.push({name:"x",value:Number(topObject.coordinate[0]).toFixed(2).toString()+" m"}),xy_properties.push({name:"y",value:Number(topObject.coordinate[1]).toFixed(2).toString()+" m"});const info_card_data=[];info_card_data.push({layerName:"Position",properties:xy_properties}),props.pickInfos.forEach((info=>{const layer_properties=info.properties,layer_name=info.layer?.props?.name,zValue=info.propertyValue;if(void 0!==zValue){const property=xy_properties.find((item=>item.name===layer_name));property?property.value=zValue:xy_properties.push({name:layer_name,value:zValue})}const layer=info_card_data.find((item=>item.layerName===layer_name));layer?layer_properties?.forEach((layer_prop=>{const property=layer.properties?.find((item=>item.name===layer_prop.name));property?property.value=layer_prop.value:layer.properties?.push(layer_prop)})):info_card_data.push({layerName:layer_name||"unknown-layer",properties:layer_properties})})),setInfoCardData(info_card_data)}),[props.pickInfos]),infoCardData&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_11__.Z,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(StyledTable,{"aria-label":"info-card"},react__WEBPACK_IMPORTED_MODULE_0__.createElement(_mui_material__WEBPACK_IMPORTED_MODULE_9__.Z,null,infoCardData.map((card_data=>card_data.properties&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(Row,{key:card_data.layerName,layer_data:card_data}))))))};__webpack_exports__.Z=InfoCard;try{InfoCard.displayName="InfoCard",InfoCard.__docgenInfo={description:"",displayName:"InfoCard",props:{pickInfos:{defaultValue:null,description:"List of JSON object describing picking information of layers\nthat are under the cursor.",name:"pickInfos",required:!0,type:{name:"LayerPickInfo[]"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/components/InfoCard.tsx#InfoCard"]={docgenInfo:InfoCard.__docgenInfo,name:"InfoCard",path:"packages/subsurface-viewer/src/components/InfoCard.tsx#InfoCard"})}catch(__react_docgen_typescript_loader_error){}},"./packages/subsurface-viewer/src/components/Map.tsx":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{ZP:function(){return components_Map},tX:function(){return jsonToObject},oO:function(){return useHoverInfo}});var views_namespaceObject={};__webpack_require__.r(views_namespaceObject),__webpack_require__.d(views_namespaceObject,{IntersectionView:function(){return IntersectionView}});var json_configuration=__webpack_require__("./node_modules/@deck.gl/json/dist/esm/json-configuration.js"),json_converter=__webpack_require__("./node_modules/@deck.gl/json/dist/esm/json-converter.js"),deckgl=__webpack_require__("./node_modules/@deck.gl/react/dist/esm/deckgl.js"),orbit_view=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/views/orbit-view.js"),point_light=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js"),orthographic_view=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js"),react=__webpack_require__("./node_modules/react/index.js"),first_person_view=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/views/first-person-view.js"),map_view=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/views/map-view.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/constants.js"),esm=__webpack_require__("./node_modules/@deck.gl/aggregation-layers/dist/esm/index.js"),dist_esm=__webpack_require__("./node_modules/@deck.gl/geo-layers/dist/esm/index.js"),layers_dist_esm=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/index.js"),mesh_layers_dist_esm=__webpack_require__("./node_modules/@deck.gl/mesh-layers/dist/esm/index.js"),dist_es6=__webpack_require__("./node_modules/@nebula.gl/layers/dist-es6/index.js"),register_loaders=__webpack_require__("./node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js"),constants_dist_esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js"),src_layers=__webpack_require__("./packages/subsurface-viewer/src/layers/index.ts"),view=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/views/view.js"),intersectionViewport=__webpack_require__("./packages/subsurface-viewer/src/viewports/intersectionViewport.ts");class IntersectionView extends view.Z{static displayName="IntersectionView";constructor(props){super({...props,controller:!1,viewState:{target:[275,0,-500]}})}get ViewportType(){return intersectionViewport.Z}get ControllerType(){throw new Error("Method not implemented.")}}(0,register_loaders.fh)([]);var utils_configuration={classes:Object.assign({FirstPersonView:first_person_view.Z,MapView:map_view.Z,OrbitView:orbit_view.Z,OrthographicView:orthographic_view.Z,...views_namespaceObject},layers_dist_esm,esm,dist_esm,mesh_layers_dist_esm,src_layers,{EditableGeoJsonLayer:dist_es6.nk}),functions:{},enumerations:{COORDINATE_SYSTEM:constants.COORDINATE_SYSTEM,GL:constants_dist_esm.default},constants:{}},InfoCard=__webpack_require__("./packages/subsurface-viewer/src/components/InfoCard.tsx"),DistanceScale=__webpack_require__("./packages/subsurface-viewer/src/components/DistanceScale.tsx"),CircularProgress=__webpack_require__("./packages/subsurface-viewer/node_modules/@equinor/eds-core-react/dist/esm/components/Progress/Circular/CircularProgress.js");const StatusIndicator=({layers:layers,isLoaded:isLoaded})=>{if(isLoaded)return react.createElement("div",null);const progress=function getLoadProgress(layers){const loaded=layers?.filter((layer=>layer?.isLoaded)),count=loaded?.length;return count/layers?.length*100}(layers);return react.createElement("div",null,react.createElement(CircularProgress.D,{size:48,value:progress,variant:"determinate"}),react.createElement("br",null),"Loading assets...")};var components_StatusIndicator=StatusIndicator;try{StatusIndicator.displayName="StatusIndicator",StatusIndicator.__docgenInfo={description:"",displayName:"StatusIndicator",props:{layers:{defaultValue:null,description:"",name:"layers",required:!0,type:{name:"LayersList"}},isLoaded:{defaultValue:null,description:"",name:"isLoaded",required:!0,type:{name:"boolean"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/components/StatusIndicator.tsx#StatusIndicator"]={docgenInfo:StatusIndicator.__docgenInfo,name:"StatusIndicator",path:"packages/subsurface-viewer/src/components/StatusIndicator.tsx#StatusIndicator"})}catch(__react_docgen_typescript_loader_error){}const log2=Math.log2||function ieLog2(x){return Math.log(x)*Math.LOG2E};function fitBounds({width:width,height:height,bounds:bounds,minExtent:minExtent=0,maxZoom:maxZoom=24,padding:padding=0,offset:offset=[0,0]}){if(Number.isFinite(padding)){padding={top:padding,bottom:padding,left:padding,right:padding}}else console.assert(Number.isFinite(padding.top)&&Number.isFinite(padding.bottom)&&Number.isFinite(padding.left)&&Number.isFinite(padding.right));const[west,south]=[bounds[0],bounds[1]],[east,north]=[bounds[2],bounds[3]],nw=[west,north],se=[east,south],size=[Math.max(Math.abs(se[0]-nw[0]),minExtent),Math.max(Math.abs(se[1]-nw[1]),minExtent)],targetSize=[width-padding.left-padding.right-2*Math.abs(offset[0]),height-padding.top-padding.bottom-2*Math.abs(offset[1])],scaleX=targetSize[0]/size[0],scaleY=targetSize[1]/size[1],offsetX=(padding.right-padding.left)/2/scaleX,offsetY=(padding.bottom-padding.top)/2/scaleY,centerLngLat=[(se[0]+nw[0])/2+offsetX,(se[1]+nw[1])/2+offsetY];let zoom=Math.min(maxZoom,log2(Math.abs(Math.min(scaleX,scaleY))));return Number.isFinite(zoom)||(zoom=0),{x:centerLngLat[0],y:centerLngLat[1],zoom:zoom}}var dist_ajv=__webpack_require__("./packages/subsurface-viewer/node_modules/ajv/dist/ajv.js"),Wells_namespaceObject=JSON.parse('{"$comment":"Inspired from https://github.com/geojson/schema","$schema":"http://json-schema.org/draft-07/schema#","$id":"inputSchema/Wells.json","title":"GeoJSON FeatureCollection","type":"object","required":["type","features"],"properties":{"type":{"type":"string","enum":["FeatureCollection"]},"features":{"type":"array","items":{"title":"GeoJSON Feature","type":"object","required":["type","properties","geometry"],"properties":{"type":{"type":"string","enum":["Feature"]},"id":{"oneOf":[{"type":"number"},{"type":"string"}]},"properties":{"oneOf":[{"type":"null"},{"type":"object"}]},"geometry":{"title":"GeoJSON GeometryCollection","type":"object","required":["type","geometries"],"properties":{"type":{"type":"string","enum":["GeometryCollection"]},"geometries":{"type":"array","items":{"oneOf":[{"title":"GeoJSON Point","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["Point"]},"coordinates":{"type":"array","minItems":2,"items":{"type":"number"}}}},{"title":"GeoJSON LineString","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["LineString"]},"coordinates":{"type":"array","minItems":2,"items":{"type":"array","minItems":2,"items":{"type":"number"}}}}}]}}}}}}}}}'),WellLog_namespaceObject=JSON.parse('{"$comment":"See https://jsonwelllogformat.org","$id":"inputSchema/WellLog.json","type":"object","properties":{"header":{"$ref":"#/definitions/header"},"curves":{"type":"array","items":{"$ref":"#/definitions/curve"}},"data":{"type":"array","items":{"$ref":"#/definitions/data_row"}},"metadata_discrete":{"type":"object"}},"required":["curves","data","header"],"definitions":{"header":{"type":"object","properties":{"name":{"type":"string","description":"Log name"},"description":{"type":"string","description":"Log description"},"externalIds":{"type":"object","description":"Record<string,string>; IDs within external storage, key being the storage name, and value being the ID."},"well":{"type":"string","description":"Well name"},"wellbore":{"type":"string","description":"wellbore name"},"field":{"type":"string","description":"Field name"},"country":{"type":"string","description":"Country of operation"},"date":{"type":"string","description":"datetime; Logging date"},"operator":{"type":"string","description":"Operator company name"},"serviceCompany":{"type":"string","description":"Service company name"},"source":{"type":"string","description":"Source system or process of this log"},"runNumber":{"type":"string","description":"Run number"},"elevation":{"type":"number","description":"float; Vertical distance between measured depth 0.0 and mean sea level in SI unit (meters)"},"startIndex":{"type":"number","description":"Value of the first index. Unit according to index curve"},"endIndex":{"type":"number","description":"Value of the last index. Unit according to index curve"},"step":{"type":["number","null"],"description":"Distance between indices if regularly sampled. Unit according to index curve. If log is time based, milliseconds assumed. null if irregular step"},"dataUri":{"type":"string","description":"Point to data source in case this is kept separate. Can be absolute or relative according to the URI specification"}}},"curve":{"type":"object","properties":{"name":{"type":"string","description":"Curve name or mnemonic. Mandatory. Non-null"},"description":{"type":["string","null"],"description":"Curve description. Optional"},"quantity":{"type":["string","null"],"description":"Curve quantity such as length, pressure, force etc. Optional"},"unit":{"type":["string","null"],"description":"Unit of measurement such as m, ft, bar, etc. Optional"},"valueType":{"type":["string","null"],"description":"Curve value type: float, integer, string, datetime or boolean. Non-null. Optional. float assumed if not present"},"dimensions":{"type":"number","description":"Number of dimensions. [1,>. Non-null. Optional. 1 assumed if not present"}},"required":["name"]},"data_row":{"type":"array","items":{"anyOf":[{"type":"number"},{"type":"string"},{"type":"null"}]}},"metadata_discrete":{"type":"object"}}}'),WellLogs_namespaceObject=JSON.parse('{"$id":"inputSchema/WellLogs.json","type":"array","items":{"$ref":"./WellLog.json#"}}'),WellLogTemplate_namespaceObject=JSON.parse('{"type":"object","properties":{"name":{"type":"string"},"scale":{"type":"object","properties":{"primary":{"type":"string"},"allowSecondary":{"type":"boolean"}},"required":["primary"]},"tracks":{"type":"array","items":{"$ref":"#/definitions/track"}},"styles":{"type":"array","items":{"$ref":"#/definitions/style"}}},"required":["tracks"],"definitions":{"domain":{"type":"array","minItems":2,"maxItems":2,"items":{"type":"number"}},"css_color":{"type":"string","description":"Any valid CSS color value (named colors, three-digit hex color, six-digit hex color, RGB colors)","examples":["green","#ff8000","rgb(128,33,23)","rgba(128,33,23,0.6)"]},"plot_type":{"enum":["line","linestep","dot","area","differential","gradientfill","stacked"],"default":"line"},"scale_type":{"enum":["log","linear"],"default":"linear"},"plot_prop":{"type":"object","properties":{"scale":{"$ref":"#/definitions/scale_type"},"type":{"$ref":"#/definitions/plot_type"},"color":{"$ref":"#/definitions/css_color"},"inverseColor":{"$ref":"#/definitions/css_color"},"fill":{"$ref":"#/definitions/css_color"},"fillOpacity":{"type":"number","minimum":0,"maximum":1,"default":0.25,"description":"for \'area\' and \'gradientfill\' plots"},"colorTable":{"type":"string","description":"table id (name) for \'gradientfill\' plot"},"inverseColorTable":{"type":"string","description":"table id (name) for \'gradientfill\' plot"},"colorScale":{"$ref":"#/definitions/scale_type","description":"table id (name) for \'gradientfill\' plot"},"inverseColorScale":{"$ref":"#/definitions/scale_type","description":"table id (name) for \'gradientfill\' plot"},"color2":{"$ref":"#/definitions/css_color","description":"for \'differetial\' plot"},"fill2":{"$ref":"#/definitions/css_color","description":"for \'differetial\' plot"}}},"plot":{"allOf":[{"$ref":"#/definitions/plot_prop"}],"type":"object","properties":{"name":{"type":"string"},"style":{"type":"string"},"scale":{"$ref":"#/definitions/scale_type"},"name2":{"type":"string"}},"required":["name"]},"style":{"allOf":[{"$ref":"#/definitions/plot_prop"}],"type":"object","properties":{"name":{"type":"string"}},"required":["name"]},"track":{"type":"object","properties":{"title":{"type":"string"},"required":{"type":"boolean"},"scale":{"$ref":"#/definitions/scale_type"},"domain":{"$ref":"#/definitions/domain"},"plots":{"type":"array","items":{"$ref":"#/definitions/plot"}}},"required":["plots"]}}}'),PieChart_namespaceObject=JSON.parse('{"$comment":"PieChart data schema","$id":"inputSchema/PieChart.json","type":"object","properties":{"pies":{"type":"array","items":{"$ref":"#/definitions/pie"}},"properties":{"type":"array","items":{"$ref":"#/definitions/property"}}},"required":["pies","properties"],"definitions":{"pie":{"type":"object","properties":{"x":{"type":"number","description":"Pie chart y-coordinate"},"y":{"type":"number","description":"Pie chart x-coordinate"},"R":{"type":"number","description":"Pie chart radius."},"fractions":{"type":"array","description":"Number and proportion of slices on pie chart.","items":{"$ref":"#/definitions/fraction"}}},"required":["x","y","R","fractions"]},"property":{"type":"object","properties":{"color":{"type":"array","minItems":3,"maxItems":3,"items":{"type":"number"},"description":"Pie slice color as RGB array."},"label":{"type":"string","description":"Pie slice name."}},"required":["color","label"]},"fraction":{"type":"object","properties":{"value":{"type":"number","description":"Proportion on pie slice."},"idx":{"type":"number","description":"Pie slice color and label indexed from properties array."}},"required":["value","idx"]}}}'),Grid_namespaceObject=JSON.parse('{"$comment":"See https://jsonwelllogformat.org","$id":"inputSchema/Grid.json","type":"array","items":{"$ref":"#/definitions/data_row"},"definitions":{"data_row":{"type":"object","required":["cs","vs"],"properties":{"i":{"type":"number","description":"Cell i-index, increases toward east."},"j":{"type":"number","description":"Cell j-index, increases towards north."},"z":{"type":"number","description":"Cell depth."},"cs":{"type":"array","description":"Cell corners","items":{"$ref":"#/definitions/cell_corner"},"minItems":3},"vs":{"type":"array","description":"Time dependent cell values.","items":{"type":"number"}}}},"cell_corner":{"type":"array","items":{"type":"number"},"minItems":3}}}'),FaultPolygons_namespaceObject=JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$comment":"Inspired from https://geojson.org/schema/FeatureCollection.json","$id":"inputSchema/FaultPolygons.json","title":"GeoJSON FeatureCollection","type":"object","required":["type","features"],"properties":{"type":{"type":"string","enum":["FeatureCollection"]},"features":{"type":"array","items":{"title":"GeoJSON Feature","type":"object","required":["type","properties","geometry"],"properties":{"type":{"type":"string","enum":["Feature"]},"id":{"oneOf":[{"type":"number"},{"type":"string"}]},"properties":{"oneOf":[{"type":"null"},{"type":"object"}]},"geometry":{"title":"GeoJSON Polygon","type":"object","required":["type","coordinates"],"properties":{"type":{"type":"string","enum":["Polygon"]},"coordinates":{"type":"array","items":{"type":"array","minItems":4,"items":{"type":"array","minItems":2,"items":{"type":"number"}}}},"bbox":{"type":"array","minItems":4,"items":{"type":"number"}}}}}}}}}'),ColorTables_namespaceObject=JSON.parse('{"$comment":"ColorTables data schema","$id":"inputSchema/ColorTables.json","type":"array","items":{"$ref":"#/definitions/color-table"},"definitions":{"color-table":{"type":"object","required":["name","discrete","colors"],"properties":{"name":{"type":"string","description":"Color table name"},"discrete":{"type":"boolean","description":"True if color table is for discrete data"},"colors":{"type":"array","description":"Color entries as [anchor, R, G, B] for continuous and [index, R, G, B] for discrete","items":{"$ref":"#/definitions/color-row","minItems":4}},"description":{"type":"string","description":"Description"},"colorNaN":{"$ref":"#/definitions/color-row","description":"Color for NaN/undefined value"},"colorBelow":{"$ref":"#/definitions/color-row","description":"Color for value below minimum color range"},"colorAbove":{"$ref":"#/definitions/color-row","description":"Color for value above minimum color range"}}},"color-row":{"type":"array","items":{"type":"number"},"minItems":3}}}');function validateSchema(data,schema_type){let validator=null;try{validator=function createSchemaValidator(schema_type){const ajv=new dist_ajv.ZP({schemas:[WellLog_namespaceObject]});switch(schema_type){case"Wells":return ajv.compile(Wells_namespaceObject);case"WellLog":return ajv.compile(WellLog_namespaceObject);case"WellLogs":return ajv.compile(WellLogs_namespaceObject);case"WellLogTemplate":return ajv.compile(WellLogTemplate_namespaceObject);case"PieChart":return ajv.compile(PieChart_namespaceObject);case"Grid":return ajv.compile(Grid_namespaceObject);case"FaultPolygons":return ajv.compile(FaultPolygons_namespaceObject);case"ColorTables":return ajv.compile(ColorTables_namespaceObject);default:return null}}(schema_type)}catch(e){throw"Wrong JSON schema for "+schema_type+". "+String(e)}if(!validator)throw"Wrong schema type.";if(validator(data),validator.errors)throw function formatSchemaError(schema_type,errors){let error_text="";error_text=errors[0]?(errors[0].dataPath?errors[0].dataPath+": ":"")+errors[0].message:"JSON schema validation failed";return`${schema_type}: ${error_text}.`}(schema_type,validator.errors)}function validateColorTables(colorTables){validateSchema(colorTables,"ColorTables")}function validateLayers(layers){layers.forEach((layer=>{if(layer.isLoaded){validateLayer(layer);try{layer.validateProps()}catch(e){throw`${layer.id}- ${String(e)}`}}}))}function validateLayer(layer){switch(layer.id){case"wells-layer":!function validateWellsLayer(wellsLayer){validateSchema(wellsLayer.props.data,"Wells");validateSchema(function getLogData(wellsLayer){const sub_layers=wellsLayer.internalState?.subLayers,log_layer=sub_layers?.find((layer=>"wells-layer-log_curve"===layer.id));return log_layer?.props.data}(wellsLayer),"WellLogs")}(layer);break;case"pie-layer":validateSchema(layer.props.data,"PieChart");break;case"grid-layer":validateSchema(layer.props.data,"Grid");break;case"fault-polygons-layer":validateSchema(layer.props.data,"FaultPolygons");break;default:return}}try{validateColorTables.displayName="validateColorTables",validateColorTables.__docgenInfo={description:"",displayName:"validateColorTables",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateColorTables"]={docgenInfo:validateColorTables.__docgenInfo,name:"validateColorTables",path:"packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateColorTables"})}catch(__react_docgen_typescript_loader_error){}try{validateLayers.displayName="validateLayers",validateLayers.__docgenInfo={description:"",displayName:"validateLayers",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateLayers"]={docgenInfo:validateLayers.__docgenInfo,name:"validateLayers",path:"packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateLayers"})}catch(__react_docgen_typescript_loader_error){}try{validateLayer.displayName="validateLayer",validateLayer.__docgenInfo={description:"",displayName:"validateLayer",props:{internalState:{defaultValue:null,description:"",name:"internalState",required:!0,type:{name:"LayerState<Layer<{}>> | null"}},lifecycle:{defaultValue:null,description:"",name:"lifecycle",required:!0,type:{name:"enum",value:[{value:'"Awaiting state"'},{value:'"Matched. State transferred from previous layer"'},{value:'"Initialized"'},{value:'"Discarded. Awaiting garbage collection"'},{value:'"No longer matched. Awaiting garbage collection"'},{value:'"Finalized! Awaiting garbage collection"'}]}},context:{defaultValue:null,description:"",name:"context",required:!0,type:{name:"LayerContext"}},state:{defaultValue:null,description:"",name:"state",required:!0,type:{name:"Record<string, any>"}},parent:{defaultValue:null,description:"",name:"parent",required:!0,type:{name:"Layer<{}> | null"}},root:{defaultValue:null,description:"",name:"root",required:!0,type:{name:"Layer<{}>"}},toString:{defaultValue:null,description:"Returns a string representation of an object.",name:"toString",required:!1,type:{name:"() => string"}},project:{defaultValue:null,description:"Projects a point with current view state from the current layer's coordinate system to screen",name:"project",required:!0,type:{name:"(xyz: number[]) => number[]"}},unproject:{defaultValue:null,description:"Unprojects a screen pixel to the current view's default coordinate system\nNote: this does not reverse `project`.",name:"unproject",required:!0,type:{name:"(xy: number[]) => number[]"}},projectPosition:{defaultValue:null,description:"Projects a point with current view state from the current layer's coordinate system to the world space",name:"projectPosition",required:!0,type:{name:"(xyz: number[], params?: { viewport?: Viewport | undefined; fromCoordinateSystem?: CoordinateSystem | undefined; fromCoordinateOrigin?: [number, number, number] | undefined; autoOffset?: boolean | undefined; } | undefined) => [...]"}},isComposite:{defaultValue:null,description:"`true` if this layer renders other layers",name:"isComposite",required:!0,type:{name:"boolean"}},setState:{defaultValue:null,description:"Updates selected state members and marks the layer for redraw",name:"setState",required:!0,type:{name:"(partialState: any) => void"}},setNeedsRedraw:{defaultValue:null,description:"Sets the redraw flag for this layer, will trigger a redraw next animation frame",name:"setNeedsRedraw",required:!0,type:{name:"() => void"}},setNeedsUpdate:{defaultValue:null,description:"Mark this layer as needs a deep update",name:"setNeedsUpdate",required:!0,type:{name:"() => void"}},isLoaded:{defaultValue:null,description:"Returns true if all async resources are loaded",name:"isLoaded",required:!0,type:{name:"boolean"}},wrapLongitude:{defaultValue:null,description:"Returns true if using shader-based WGS84 longitude wrapping",name:"wrapLongitude",required:!0,type:{name:"boolean"}},isPickable:{defaultValue:null,description:"@deprecated Returns true if the layer is visible in the picking pass",name:"isPickable",required:!0,type:{name:"() => boolean"}},getModels:{defaultValue:null,description:"Returns an array of models used by this layer, can be overriden by layer subclass",name:"getModels",required:!0,type:{name:"() => Model[]"}},setModuleParameters:{defaultValue:null,description:"Update shader module parameters",name:"setModuleParameters",required:!0,type:{name:"(moduleParameters: any) => void"}},getAttributeManager:{defaultValue:null,description:"Returns the attribute manager of this layer",name:"getAttributeManager",required:!0,type:{name:"() => AttributeManager | null"}},getCurrentLayer:{defaultValue:null,description:"Returns the most recent layer that matched to this state\n(When reacting to an async event, this layer may no longer be the latest)",name:"getCurrentLayer",required:!0,type:{name:"() => Layer<{}> | null"}},getLoadOptions:{defaultValue:null,description:"Returns the default parse options for async props",name:"getLoadOptions",required:!0,type:{name:"() => any"}},use64bitPositions:{defaultValue:null,description:"",name:"use64bitPositions",required:!0,type:{name:"() => boolean"}},onHover:{defaultValue:null,description:"",name:"onHover",required:!0,type:{name:"(info: PickingInfo, pickingEvent: any) => boolean"}},onClick:{defaultValue:null,description:"",name:"onClick",required:!0,type:{name:"(info: PickingInfo, pickingEvent: any) => boolean"}},nullPickingColor:{defaultValue:null,description:"",name:"nullPickingColor",required:!0,type:{name:"() => number[]"}},encodePickingColor:{defaultValue:null,description:"",name:"encodePickingColor",required:!0,type:{name:"(i: any, target?: number[] | undefined) => number[]"}},decodePickingColor:{defaultValue:null,description:"",name:"decodePickingColor",required:!0,type:{name:"(color: any) => number"}},getNumInstances:{defaultValue:null,description:"Deduces number of instances. Intention is to support:\n- Explicit setting of numInstances\n- Auto-deduction for ES6 containers that define a size member\n- Auto-deduction for Classic Arrays via the built-in length attribute\n- Auto-deduction via arrays",name:"getNumInstances",required:!0,type:{name:"() => number"}},getStartIndices:{defaultValue:null,description:"Buffer layout describes how many attribute values are packed for each data object\nThe default (null) is one value each object.\nSome data formats (e.g. paths, polygons) have various length. Their buffer layout\nis in the form of [L0, L1, L2, ...]",name:"getStartIndices",required:!0,type:{name:"() => NumericArray | null"}},getBounds:{defaultValue:null,description:"",name:"getBounds",required:!0,type:{name:"() => [number[], number[]] | null"}},initializeState:{defaultValue:null,description:"Called once to set up the initial state. Layers can create WebGL resources here.",name:"initializeState",required:!0,type:{name:"(context: LayerContext) => void"}},getShaders:{defaultValue:null,description:"",name:"getShaders",required:!0,type:{name:"(shaders: any) => any"}},shouldUpdateState:{defaultValue:null,description:"Controls if updateState should be called. By default returns true if any prop has changed",name:"shouldUpdateState",required:!0,type:{name:"(params: UpdateParameters<Layer<{}>>) => boolean"}},updateState:{defaultValue:null,description:"Default implementation, all attributes will be invalidated and updated when data changes",name:"updateState",required:!0,type:{name:"(params: UpdateParameters<Layer<{}>>) => void"}},finalizeState:{defaultValue:null,description:"Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here.",name:"finalizeState",required:!0,type:{name:"(context: LayerContext) => void"}},draw:{defaultValue:null,description:"",name:"draw",required:!0,type:{name:"(opts: any) => void"}},getPickingInfo:{defaultValue:null,description:"",name:"getPickingInfo",required:!0,type:{name:"({ info, mode, sourceLayer }: GetPickingInfoParams) => PickingInfo"}},raiseError:{defaultValue:null,description:"(Internal) Propagate an error event through the system",name:"raiseError",required:!0,type:{name:"(error: Error, message: string) => void"}},getNeedsRedraw:{defaultValue:null,description:"(Internal) Checks if this layer needs redraw",name:"getNeedsRedraw",required:!0,type:{name:"(opts?: { clearRedrawFlags: boolean; } | undefined) => string | false"}},needsUpdate:{defaultValue:null,description:"(Internal) Checks if this layer needs a deep update",name:"needsUpdate",required:!0,type:{name:"() => boolean"}},hasUniformTransition:{defaultValue:null,description:"Checks if this layer has ongoing uniform transition",name:"hasUniformTransition",required:!0,type:{name:"() => boolean"}},activateViewport:{defaultValue:null,description:"Called when this layer is rendered into the given viewport",name:"activateViewport",required:!0,type:{name:"(viewport: Viewport) => void"}},invalidateAttribute:{defaultValue:null,description:"Default implementation of attribute invalidation, can be redefined",name:"invalidateAttribute",required:!0,type:{name:"(name?: string | undefined) => void"}},updateAttributes:{defaultValue:null,description:"Send updated attributes to the WebGL model",name:"updateAttributes",required:!0,type:{name:"(changedAttributes: { [id: string]: Attribute; }) => void"}},_updateAttributes:{defaultValue:null,description:"Recalculate any attributes if needed",name:"_updateAttributes",required:!0,type:{name:"() => void"}},_updateAttributeTransition:{defaultValue:null,description:"Update attribute transitions. This is called in drawLayer, no model updates required.",name:"_updateAttributeTransition",required:!0,type:{name:"any"}},_updateUniformTransition:{defaultValue:null,description:"Update uniform (prop) transitions. This is called in updateState, may result in model updates.",name:"_updateUniformTransition",required:!0,type:{name:"any"}},calculateInstancePickingColors:{defaultValue:null,description:"Updater for the automatically populated instancePickingColors attribute",name:"calculateInstancePickingColors",required:!0,type:{name:"(attribute: Attribute, { numInstances }: { numInstances: number; }) => void"}},_setModelAttributes:{defaultValue:null,description:"Apply changed attributes to",name:"_setModelAttributes",required:!0,type:{name:"(model: Model, changedAttributes: { [id: string]: Attribute; }) => void"}},disablePickingIndex:{defaultValue:null,description:"(Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.\nThis method may be overriden by layer implementations",name:"disablePickingIndex",required:!0,type:{name:"(objectIndex: number) => void"}},_disablePickingIndex:{defaultValue:null,description:"",name:"_disablePickingIndex",required:!0,type:{name:"(objectIndex: number) => void"}},restorePickingColors:{defaultValue:null,description:"(Internal) Re-enable all picking indices after multi-depth picking",name:"restorePickingColors",required:!0,type:{name:"() => void"}},_initialize:{defaultValue:null,description:"",name:"_initialize",required:!0,type:{name:"() => void"}},_transferState:{defaultValue:null,description:"(Internal) Called by layer manager to transfer state from an old layer",name:"_transferState",required:!0,type:{name:"(oldLayer: Layer<{}>) => void"}},_update:{defaultValue:null,description:"(Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance",name:"_update",required:!0,type:{name:"() => void"}},_finalize:{defaultValue:null,description:"(Internal) Called by manager when layer is about to be disposed\nNote: not guaranteed to be called on application shutdown",name:"_finalize",required:!0,type:{name:"() => void"}},_drawLayer:{defaultValue:null,description:"",name:"_drawLayer",required:!0,type:{name:"({ moduleParameters, uniforms, parameters }: { moduleParameters: any; uniforms: any; parameters: any; }) => void"}},getChangeFlags:{defaultValue:null,description:"Returns the current change flags",name:"getChangeFlags",required:!0,type:{name:"() => ChangeFlags | undefined"}},setChangeFlags:{defaultValue:null,description:"Dirty some change flags, will be handled by updateLayer",name:"setChangeFlags",required:!0,type:{name:"(flags: Partial<ChangeFlags>) => void"}},_clearChangeFlags:{defaultValue:null,description:"Clear all changeFlags, typically after an update",name:"_clearChangeFlags",required:!0,type:{name:"any"}},_diffProps:{defaultValue:null,description:"Compares the layers props with old props from a matched older layer\nand extracts change flags that describe what has change so that state\ncan be update correctly with minimal effort",name:"_diffProps",required:!0,type:{name:"any"}},validateProps:{defaultValue:null,description:"(Internal) called by layer manager to perform extra props validation (in development only)",name:"validateProps",required:!0,type:{name:"() => void"}},updateAutoHighlight:{defaultValue:null,description:"(Internal) Called by deck picker when the hovered object changes to update the auto highlight",name:"updateAutoHighlight",required:!0,type:{name:"(info: PickingInfo) => void"}},_updateAutoHighlight:{defaultValue:null,description:"Update picking module parameters to highlight the hovered object",name:"_updateAutoHighlight",required:!0,type:{name:"(info: PickingInfo) => void"}},_getAttributeManager:{defaultValue:null,description:"Create new attribute manager",name:"_getAttributeManager",required:!0,type:{name:"() => AttributeManager | null"}},_postUpdate:{defaultValue:null,description:"Called after updateState to perform common tasks",name:"_postUpdate",required:!0,type:{name:"(updateParams: UpdateParameters<Layer<{}>>, forceUpdate: boolean) => void"}},_getUpdateParams:{defaultValue:null,description:"",name:"_getUpdateParams",required:!0,type:{name:"any"}},_getNeedsRedraw:{defaultValue:null,description:"Checks state of attributes and model",name:"_getNeedsRedraw",required:!0,type:{name:"any"}},_onAsyncPropUpdated:{defaultValue:null,description:"Callback when asyn prop is loaded",name:"_onAsyncPropUpdated",required:!0,type:{name:"any"}},id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"string"}},props:{defaultValue:null,description:"",name:"props",required:!0,type:{name:"StatefulComponentProps<Required<LayerProps>>"}},count:{defaultValue:null,description:"",name:"count",required:!0,type:{name:"number"}},clone:{defaultValue:null,description:"",name:"clone",required:!0,type:{name:"(newProps: Partial<Required<LayerProps>>) => any"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateLayer"]={docgenInfo:validateLayer.__docgenInfo,name:"validateLayer",path:"packages/subsurface-viewer/src/inputSchema/schemaValidationUtil.tsx#validateLayer"})}catch(__react_docgen_typescript_loader_error){}var layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts"),lodash=__webpack_require__("./node_modules/lodash/lodash.js"),dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),orbit_controller=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"),orthographic_controller=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"),camera_light=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js"),ambient_light=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js"),directional_light=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js"),lighting_effect=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"),line_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js"),matrix4=__webpack_require__("./node_modules/@math.gl/core/dist/esm/classes/matrix4.js"),web_mercator_dist_esm=__webpack_require__("./node_modules/@math.gl/web-mercator/dist/esm/index.js");function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}const minZoom3D=-12,maxZoom3D=12,maxZoom2D=4;class ZScaleOrbitController extends orbit_controller.Z{static setZScaleUp=null;static setZScaleDown=null;static setZScaleUpReference(setZScaleUp){ZScaleOrbitController.setZScaleUp=setZScaleUp}static setZScaleDownReference(setZScaleDown){ZScaleOrbitController.setZScaleDown=setZScaleDown}handleEvent(event){return null===ZScaleOrbitController.setZScaleUp?super.handleEvent(event):ZScaleOrbitController.setZScaleUp&&"keydown"===event.type&&"ArrowUp"===event.key?(ZScaleOrbitController.setZScaleUp(Math.random()),!0):ZScaleOrbitController.setZScaleDown&&"keydown"===event.type&&"ArrowDown"===event.key?(ZScaleOrbitController.setZScaleDown(Math.random()),!0):super.handleEvent(event)}}class ZScaleOrbitView extends orbit_view.Z{get ControllerType(){return ZScaleOrbitController}}function compareViewsProp(views){if(void 0===views)return views;const copy=(0,lodash.cloneDeep)(views),viewports=copy.viewports.map((e=>(delete e.layerIds,e)));return copy.viewports=viewports,JSON.stringify(copy)}function useHoverInfo(){const[hoverInfo,setHoverInfo]=react.useState([]);return[hoverInfo,react.useCallback((pickEvent=>{setHoverInfo(pickEvent.infos)}),[])]}function defaultTooltip(info){if(info?.logName)return info?.logName;if("drawing-layer"===info.layer?.id)return info.propertyValue?.toFixed(2);const feat=info.object;return feat?.properties?.name}function adjustCameraTarget(viewStates,scale,newScale){const vs=(0,lodash.cloneDeep)(viewStates);for(const key in vs)if(void 0!==vs[key].target){const t=vs[key].target,z=newScale*(t[2]/scale);vs[key].target=[t[0],t[1],z]}return vs}const Map=({id:id,layers:layers,bounds:bounds,views:views,coords:coords,scale:scale,coordinateUnit:coordinateUnit,colorTables:colorTables,setEditedData:setEditedData,checkDatafileSchema:checkDatafileSchema,onMouseEvent:onMouseEvent,selection:selection,children:children,getTooltip:getTooltip=defaultTooltip,cameraPosition:cameraPosition,getCameraPosition:getCameraPosition,isLoadedCallback:isLoadedCallback,triggerHome:triggerHome,lights:lights,triggerResetMultipleWells:triggerResetMultipleWells})=>{const deckRef=(0,react.useRef)(null),bboxInitial=[0,0,0,1,1,1],[deckGLViews,setDeckGLViews]=(0,react.useState)([]),[viewStates,setViewStates]=(0,react.useState)({}),[reportedBoundingBox,setReportedBoundingBox]=(0,react.useState)(bboxInitial),[reportedBoundingBoxAcc,setReportedBoundingBoxAcc]=(0,react.useState)(bboxInitial),[deckGLLayers,setDeckGLLayers]=(0,react.useState)([]),[viewPortMargins,setViewPortMargins]=(0,react.useState)({left:0,right:0,top:0,bottom:0}),[camera,setCamera]=(0,react.useState)();react.useEffect((()=>{const camera=function calculateZoomFromBBox3D(camera,deck){const DEGREES_TO_RADIANS=Math.PI/180,RADIANS_TO_DEGREES=180/Math.PI,IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],camera_=(0,lodash.cloneDeep)(camera);if(void 0===camera_||!Array.isArray(camera_.zoom))return camera;if(void 0===deck)return camera_.zoom=0,camera_.target=[0,0,0],camera_;const width=deck.width,height=deck.height,fD=(0,web_mercator_dist_esm.sj)(50),bbox=camera_.zoom,xMin=bbox[0],yMin=bbox[1],zMin=bbox[2],xMax=bbox[3],yMax=bbox[4],zMax=bbox[5],target=[xMin+(xMax-xMin)/2,yMin+(yMax-yMin)/2,zMin+(zMax-zMin)/2],angle_ver=25*DEGREES_TO_RADIANS,r=height/2/Math.sin(angle_ver)*Math.cos(angle_ver),angle_hor=2*Math.atan(width/2/r)*RADIANS_TO_DEGREES/2*DEGREES_TO_RADIANS,points=[];points.push([xMin,yMin,zMin]),points.push([xMin,yMax,zMin]),points.push([xMax,yMax,zMin]),points.push([xMax,yMin,zMin]),points.push([xMin,yMin,zMax]),points.push([xMin,yMax,zMax]),points.push([xMax,yMax,zMax]),points.push([xMax,yMin,zMax]);let zoom=999;for(const point of points){const x_=(point[0]-target[0])/height,y_=(point[1]-target[1])/height,z_=(point[2]-target[2])/height,m=new matrix4.Z(IDENTITY);m.rotateX(camera_.rotationX*DEGREES_TO_RADIANS),m.rotateZ(camera_.rotationOrbit*DEGREES_TO_RADIANS);const[x,y,z]=m.transformAsVector([x_,y_,z_]);if(y>=0)continue;const fwX=fD*Math.tan(angle_hor);let y_new=fwX/(Math.abs(x)/y-fwX/fD);const zoom_x=Math.log2(y_new/y),fwY=fD*Math.tan(angle_ver);y_new=fwY/(Math.abs(z)/y-fwY/fD);const zoom_z=Math.log2(y_new/y);zoom=zoom_x<zoom?zoom_x:zoom,zoom=zoom_z<zoom?zoom_z:zoom}return camera_.zoom=zoom,camera_.target=target,camera_}(cameraPosition,deckRef.current?.deck);setCamera(camera)}),[cameraPosition,deckRef?.current?.deck]);const[scaleZ,setScaleZ]=(0,react.useState)(1),[scaleZUp,setScaleZUp]=(0,react.useState)(Number.MAX_VALUE),[scaleZDown,setScaleZDown]=(0,react.useState)(Number.MAX_VALUE);react.useEffect((()=>{ZScaleOrbitController.setZScaleUpReference(setScaleZUp)}),[setScaleZUp]),react.useEffect((()=>{ZScaleOrbitController.setZScaleDownReference(setScaleZDown)}),[setScaleZDown]),(0,react.useEffect)((()=>{const[Views,viewStates]=createViewsAndViewStates(views,viewPortMargins,bounds,void 0,reportedBoundingBoxAcc,deckRef.current?.deck);setDeckGLViews(Views),setViewStates(viewStates)}),[triggerHome]),(0,react.useEffect)((()=>{const[Views,viewStates]=createViewsAndViewStates(views,viewPortMargins,bounds,camera,reportedBoundingBoxAcc,deckRef.current?.deck);setDeckGLViews(Views),setViewStates(viewStates)}),[bounds,camera,deckRef?.current?.deck,reportedBoundingBoxAcc,compareViewsProp(views)]),(0,react.useEffect)((()=>{const union_of_reported_bboxes=function addBoundingBoxes(b1,b2){const boxDefault=[0,0,0,1,1,1];return void 0===b1||void 0===b2?boxDefault:(0,lodash.isEqual)(b1,boxDefault)?b2:[Math.min(b1[0],b2[0]),Math.min(b1[1],b2[1]),Math.min(b1[2],b2[2]),Math.max(b1[3],b2[3]),Math.max(b1[4],b2[4]),Math.max(b1[5],b2[5])]}(reportedBoundingBoxAcc,reportedBoundingBox);setReportedBoundingBoxAcc(union_of_reported_bboxes)}),[reportedBoundingBox]),(0,react.useEffect)((()=>{if(scaleZUp!==Number.MAX_VALUE){const newScaleZ=1.05*scaleZ;setScaleZ(newScaleZ);const vs=adjustCameraTarget(viewStates,scaleZ,newScaleZ);setViewStates(vs)}}),[scaleZUp]),(0,react.useEffect)((()=>{if(scaleZUp!==Number.MAX_VALUE){const newScaleZ=.95*scaleZ;setScaleZ(newScaleZ);const vs=adjustCameraTarget(viewStates,scaleZ,newScaleZ);setViewStates(vs)}}),[scaleZDown]),(0,react.useEffect)((()=>{if(void 0===layers)return;if(0===layers.length){const dummy_layer=new line_layer.Z({visible:!1});layers.push(dummy_layer)}const axes2DLayer=layers?.find((e=>e?.constructor===src_layers.Axes2DLayer)),left=axes2DLayer&&axes2DLayer.props.isLeftRuler?axes2DLayer.props.marginH:0,right=axes2DLayer&&axes2DLayer.props.isRightRuler?axes2DLayer.props.marginH:0,top=axes2DLayer&&axes2DLayer.props.isTopRuler?axes2DLayer.props.marginV:0,bottom=axes2DLayer&&axes2DLayer.props.isBottomRuler?axes2DLayer.props.marginV:0;setViewPortMargins({left:left,right:right,top:top,bottom:bottom});const layers_copy=layers.map((item=>item?.constructor.name===src_layers.NorthArrow3DLayer.name?item:item.clone({setReportedBoundingBox:setReportedBoundingBox})));setDeckGLLayers(layers_copy)}),[layers]),(0,react.useEffect)((()=>{if(void 0===layers)return;const m=(0,layerTools.BZ)(scaleZ),layers_copy=deckGLLayers.map((item=>item?.constructor.name===src_layers.NorthArrow3DLayer.name?item:item.clone({modelMatrix:m})));setDeckGLLayers(layers_copy)}),[scaleZ]),(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(layers){const wellslayer=(0,layerTools.eG)(layers,src_layers.WellsLayer.name)?.[0];wellslayer?.setSelection(selection?.well,selection?.selection)}}),[selection]);const[multipleWells,setMultipleWells]=(0,react.useState)([]),[selectedWell,setSelectedWell]=(0,react.useState)(""),[shiftHeld,setShiftHeld]=(0,react.useState)(!1);function downHandler({key:key}){"Shift"===key&&setShiftHeld(!0)}function upHandler({key:key}){"Shift"===key&&setShiftHeld(!1)}(0,react.useEffect)((()=>(window.addEventListener("keydown",downHandler),window.addEventListener("keyup",upHandler),()=>{window.removeEventListener("keydown",downHandler),window.removeEventListener("keyup",upHandler)})),[]),(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(layers){const wellslayer=(0,layerTools.kF)(layers,"WellsLayer",selectedWell)?.[0];wellslayer?.setMultiSelection(multipleWells)}}),[multipleWells,selectedWell]),(0,react.useEffect)((()=>{void 0!==triggerResetMultipleWells&&setMultipleWells([])}),[triggerResetMultipleWells]);const getPickingInfos=(0,react.useCallback)(((pickInfo,event)=>{if(coords?.multiPicking&&pickInfo.layer?.context.deck){const pickInfos=pickInfo.layer.context.deck.pickMultipleObjects({x:event.offsetCenter.x,y:event.offsetCenter.y,depth:coords.pickDepth?coords.pickDepth:void 0});return pickInfos.forEach((item=>{if(item.properties){let unit=item.sourceLayer?.props.data?.unit;null==unit&&(unit=" "),item.properties.forEach((element=>{(element.name.includes("MD")||element.name.includes("TVD"))&&(element.value=Number(element.value).toFixed(2).toString()+" "+unit)}))}})),pickInfos}return[pickInfo]}),[coords?.multiPicking,coords?.pickDepth]),callOnMouseEvent=(0,react.useCallback)(((type,infos,event)=>{if(!onMouseEvent)return;const ev=function handleMouseEvent(type,infos,event){const ev={type:type,infos:infos};"click"===ev.type&&event.rightButton&&(ev.type="contextmenu");for(const info of infos)if(info.coordinate&&(ev.x=info.coordinate[0],ev.y=info.coordinate[1]),info.layer&&"wells-layer"===info.layer.id){{const feat=info.object,properties=feat?.properties;properties&&(ev.wellname=properties.name,ev.wellcolor=properties.color)}if(ev.wellname||info.object&&(ev.wellname=info.object.header?.well),info.properties)for(const property of info.properties){ev.wellcolor||(ev.wellcolor=property.color);let propname=property.name;if(propname){const sep=propname.indexOf(" ");sep>=0&&(ev.wellname||(ev.wellname=propname.substring(sep+1)),propname=propname.substring(0,sep))}const names_tvd=["TVD","TVDSS","DVER","TVD_MSL"];if(["DEPTH","DEPT","MD","TDEP","MD_RKB"].find((name=>name==propname))?ev.md=parseFloat(property.value):names_tvd.find((name=>name==propname))&&(ev.tvd=parseFloat(property.value)),void 0!==ev.md&&void 0!==ev.tvd&&void 0!==ev.wellname)break}break}return ev}(type,infos,event);onMouseEvent(ev)}),[onMouseEvent]),[hoverInfo,setHoverInfo]=(0,react.useState)([]),onHover=(0,react.useCallback)(((pickInfo,event)=>{const infos=getPickingInfos(pickInfo,event);setHoverInfo(infos),callOnMouseEvent?.("hover",infos,event)}),[callOnMouseEvent,getPickingInfos]),onClick=(0,react.useCallback)(((pickInfo,event)=>{const infos=getPickingInfos(pickInfo,event);callOnMouseEvent?.("click",infos,event)}),[callOnMouseEvent,getPickingInfos]),[isLoaded,setIsLoaded]=(0,react.useState)(!1),onAfterRender=(0,react.useCallback)((()=>{if(deckGLLayers){const state=deckGLLayers.every((layer=>layer.isLoaded));setIsLoaded(state),void 0!==isLoadedCallback&&isLoadedCallback(state)}}),[deckGLLayers,isLoadedCallback]),[errorText,setErrorText]=(0,react.useState)();(0,react.useEffect)((()=>{const layers=deckRef.current?.deck?.props.layers;if(checkDatafileSchema&&layers&&isLoaded)try{validateLayers(layers),colorTables&&validateColorTables(colorTables)}catch(e){setErrorText(String(e))}else setErrorText(void 0)}),[checkDatafileSchema,colorTables,deckRef?.current?.deck?.props.layers,isLoaded]);const layerFilter=(0,react.useCallback)((args=>{if(!views||!views.viewports||!views.layout)return!0;const cur_view=views.viewports.find((({id:id})=>args.viewport.id&&id===args.viewport.id));if(cur_view?.layerIds&&cur_view.layerIds.length>0){return cur_view.layerIds.some((layer_id=>layer_id===args.layer.id))}return!0}),[views]),onViewStateChange=(0,react.useCallback)((({viewId:viewId,viewState:viewState})=>{const viewports=views?.viewports||[];2===viewState.target.length&&viewState.target.push(viewStates[viewId].target[2]);const isSyncIds=viewports.filter((item=>item.isSync)).map((item=>item.id));if(isSyncIds?.includes(viewId)){const viewStateTable=views?.viewports.filter((item=>item.isSync)).map((item=>[item.id,viewState])),tempViewStates=Object.fromEntries(viewStateTable??[]);setViewStates((currentViewStates=>({...currentViewStates,...tempViewStates})))}else setViewStates((currentViewStates=>({...currentViewStates,[viewId]:viewState})));getCameraPosition&&getCameraPosition(viewState)}),[getCameraPosition,viewStates,views?.viewports]),effects=function parseLights(lights){if(void 0===lights)return;const effects=[];let lightsObj={};if(lights.headLight){const headLight=new camera_light.Z({intensity:lights.headLight.intensity,color:lights.headLight.color??[255,255,255]});lightsObj={...lightsObj,headLight:headLight}}if(lights.ambientLight){const ambientLight=new ambient_light.M({intensity:lights.ambientLight.intensity,color:lights.ambientLight.color??[255,255,255]});lightsObj={...lightsObj,ambientLight:ambientLight}}if(void 0!==lights.pointLights)for(const light of lights.pointLights){const pointLight=new point_light.c({...light,color:light.color??[255,255,255]});lightsObj={...lightsObj,pointLight:pointLight}}if(void 0!==lights.directionalLights)for(const light of lights.directionalLights){const directionalLight=new directional_light.O({...light,color:light.color??[255,255,255]});lightsObj={...lightsObj,directionalLight:directionalLight}}const lightingEffect=new lighting_effect.Z(lightsObj);return effects.push(lightingEffect),effects}(lights);return!deckGLViews||(0,lodash.isEmpty)(deckGLViews)||(0,lodash.isEmpty)(deckGLLayers)?null:react.createElement("div",{onContextMenu:event=>event.preventDefault()},react.createElement(deckgl.Z,{id:id,viewState:viewStates,views:deckGLViews,layerFilter:layerFilter,layers:deckGLLayers,userData:{setEditedData:updated_prop=>{if(setSelectedWell(updated_prop.selectedWell),Object.keys(updated_prop).includes("selectedWell"))if(shiftHeld)if(multipleWells.includes(updated_prop.selectedWell)){const temp=multipleWells.filter((item=>item!==updated_prop.selectedWell));setMultipleWells(temp)}else{const temp=multipleWells.concat(updated_prop.selectedWell);setMultipleWells(temp)}else setMultipleWells([]);setEditedData?.(updated_prop)},colorTables:colorTables},getCursor:({isDragging:isDragging})=>isDragging?"grabbing":"default",getTooltip:getTooltip,ref:deckRef,onViewStateChange:onViewStateChange,onHover:onHover,onClick:onClick,onAfterRender:onAfterRender,effects:effects},children),scale?.visible?react.createElement(DistanceScale.Z,_extends({},scale,{zoom:viewStates[Object.keys(viewStates)[0]]?.zoom??-5,scaleUnit:coordinateUnit,style:scale.cssStyle??{}})):null,react.createElement(components_StatusIndicator,{layers:deckGLLayers,isLoaded:isLoaded}),coords?.visible?react.createElement(InfoCard.Z,{pickInfos:hoverInfo}):null,errorText&&react.createElement("pre",{style:{flex:"0, 0",color:"rgb(255, 64, 64)",backgroundColor:"rgb(255, 255, 192)"}},errorText))};Map.defaultProps={coords:{visible:!0,multiPicking:!0,pickDepth:10},scale:{visible:!0,incrementValue:100,widthPerUnit:100,cssStyle:{top:10,left:10}},toolbar:{visible:!1},coordinateUnit:"m",views:{layout:[1,1],showLabel:!1,viewports:[{id:"main-view",show3D:!1,layerIds:[]}]},colorTables:dist.Su,checkDatafileSchema:!1};var components_Map=Map;function jsonToObject(data,enums=void 0){if(!data)return[];const configuration=new json_configuration.Z(utils_configuration);enums?.forEach((enumeration=>{enumeration&&configuration.merge({enumerations:{...enumeration}})}));const jsonConverter=new json_converter.Z({configuration:configuration}),filtered_data=data.filter((value=>0!==Object.keys(value).length));return jsonConverter.convert(filtered_data)}function getViewState(viewPortMargins,bounds_accessor,centerOfData,views,viewPort,deck){let bounds=[0,0,1,1];bounds="function"==typeof bounds_accessor?bounds_accessor():bounds_accessor;let w=bounds[2]-bounds[0],h=bounds[3]-bounds[1];const z=centerOfData[2],fb=fitBounds({width:w,height:h,bounds:bounds});let fb_target=[fb.x,fb.y,z],fb_zoom=fb.zoom;if(deck){const w_bounds=w,h_bounds=h,ml=viewPortMargins.left,mr=viewPortMargins.right,mb=viewPortMargins.bottom,mt=viewPortMargins.top,marginH=(ml>0?ml:0)+(mr>0?mr:0),marginV=(mb>0?mb:0)+(mt>0?mt:0);if(w=deck.width-marginH,h=deck.height-marginV,void 0!==views?.layout){const[nY,nX]=views.layout;if(1!==nX||1!==nY){const mPixels=views?.marginPixels??0,w_=99.5/nX,h_=99.5/nY,marginHorPercentage=mPixels/(w_*deck.width)*1e4,marginVerPercentage=mPixels/(h_*deck.height)*1e4;w=w_/100*deck.width*(1-marginHorPercentage/100*2)-marginH,h=h_/100*deck.height*(1-marginVerPercentage/100*2)-marginV}}const m_pr_pixel=h_bounds/w_bounds>h/w?h_bounds/h:w_bounds/w;let translate_x=0;ml>0&&0===mr?translate_x=.5*ml*m_pr_pixel:0===ml&&mr>0&&(translate_x=-.5*mr*m_pr_pixel);let translate_y=0;mb>0&&0===mt?translate_y=.5*mb*m_pr_pixel:0===mb&&mt>0&&(translate_y=-.5*mt*m_pr_pixel);const fb=fitBounds({width:w,height:h,bounds:bounds});fb_target=[fb.x-translate_x,fb.y-translate_y,z],fb_zoom=fb.zoom}return{target:viewPort.target??fb_target,zoom:viewPort.zoom??fb_zoom,rotationX:90,rotationOrbit:0,minZoom:minZoom3D,maxZoom:viewPort.show3D?maxZoom3D:maxZoom2D}}function getViewState3D(is3D,bounds,zoom,deck){const xMin=bounds[0],yMin=bounds[1],zMin=bounds[2],xMax=bounds[3],yMax=bounds[4],zMax=bounds[5];let width=xMax-xMin,height=yMax-yMin;deck&&(width=deck.width,height=deck.height);const target=[xMin+(xMax-xMin)/2,yMin+(yMax-yMin)/2,is3D?zMin+(zMax-zMin)/2:0],fitted_bound=fitBounds({width:width,height:height,bounds:[xMin,yMin,xMax,yMax]});return{target:target,zoom:zoom??1.2*fitted_bound.zoom,rotationX:45,rotationOrbit:0,minZoom:minZoom3D,maxZoom:maxZoom3D}}function createViewsAndViewStates(views,viewPortMargins,bounds,cameraPosition,boundingBox,deck){const deckgl_views=[];let viewStates={};const centerOfData=function boundingBoxCenter(box){const xmin=box[0],ymin=box[1],zmin=box[2];return[xmin+.5*(box[3]-xmin),ymin+.5*(box[4]-ymin),zmin+.5*(box[5]-zmin)]}(boundingBox),widthViewPort=deck?.width??1,heightViewPort=deck?.height??1,mPixels=views?.marginPixels??0;if(deck&&views&&views.layout[0]>=1&&views.layout[1]>=1){let yPos=0;const[nY,nX]=views.layout,w=99.5/nX,h=99.5/nY,singleView=1===nX&&1===nY,marginHorPercentage=singleView?0:mPixels/(w*widthViewPort)*1e4,marginVerPercentage=singleView?0:mPixels/(h*heightViewPort)*1e4;for(let y=1;y<=nY;y++){let xPos=0;for(let x=1;x<=nX;x++){if(null==views.viewports||deckgl_views.length>=views.viewports.length)return[deckgl_views,viewStates];const currentViewport=views.viewports[deckgl_views.length];let ViewType=ZScaleOrbitView;currentViewport.show3D||(ViewType="intersection_view"===currentViewport.id?IntersectionView:orthographic_view.Z);const far=9999,near=currentViewport.show3D?.1:-9999,controller={type:currentViewport.show3D?ZScaleOrbitController:orthographic_controller.Z,doubleClickZoom:!1};deckgl_views.push(new ViewType({id:currentViewport.id,controller:controller,x:xPos+marginHorPercentage/nX+"%",y:yPos+marginVerPercentage/nY+"%",width:w*(1-marginHorPercentage/100*2)+"%",height:h*(1-marginVerPercentage/100*2)+"%",flipY:!1,far:far,near:near}));const isBoundsDefined=void 0!==bounds;let viewState=cameraPosition;void 0!==cameraPosition&&0!==Object.keys(cameraPosition).length||(viewState=isBoundsDefined?getViewState(viewPortMargins,bounds??[0,0,1,1],centerOfData,views,currentViewport,deck):getViewState3D(currentViewport.show3D??!1,boundingBox,currentViewport.zoom,deck)),viewStates={...viewStates,[currentViewport.id]:viewState},xPos+=w}yPos+=h}}else deckgl_views.push(new orthographic_view.Z({id:"main",controller:{doubleClickZoom:!1},x:"0%",y:"0%",width:"100%",height:"100%",flipY:!1,far:99999,near:-99999})),viewStates={...viewStates,dummy:{target:[0,0],zoom:0,rotationX:0,rotationOrbit:0,minZoom:-12,maxZoom:maxZoom2D}};return[deckgl_views,viewStates]}try{Map.displayName="Map",Map.__docgenInfo={description:"",displayName:"Map",props:{id:{defaultValue:null,description:"The ID of this component, used to identify dash components\nin callbacks. The ID needs to be unique across all of the\ncomponents in an app.",name:"id",required:!0,type:{name:"string"}},resources:{defaultValue:null,description:'Resource dictionary made available in the DeckGL specification as an enum.\nThe values can be accessed like this: `"@@#resources.resourceId"`, where\n`resourceId` is the key in the `resources` dict. For more information,\nsee the DeckGL documentation on enums in the json spec:\nhttps://deck.gl/docs/api-reference/json/conversion-reference#enumerations-and-using-the--prefix',name:"resources",required:!1,type:{name:"Record<string, unknown>"}},layers:{defaultValue:null,description:"",name:"layers",required:!1,type:{name:"LayersList"}},bounds:{defaultValue:null,description:"Coordinate boundary for the view defined as [left, bottom, right, top].",name:"bounds",required:!1,type:{name:"[number, number, number, number] | BoundsAccessor"}},views:{defaultValue:{value:'{\n        layout: [1, 1],\n        showLabel: false,\n        viewports: [{ id: "main-view", show3D: false, layerIds: [] }],\n    }'},description:"Views configuration for map. If not specified, all the layers will be\ndisplayed in a single 2D viewport",name:"views",required:!1,type:{name:"ViewsType"}},coords:{defaultValue:{value:"{\n        visible: true,\n        multiPicking: true,\n        pickDepth: 10,\n    }"},description:"Parameters for the InfoCard component",name:"coords",required:!1,type:{name:"{ visible?: boolean | null; multiPicking?: boolean | null; pickDepth?: number | null | undefined; } | undefined"}},scale:{defaultValue:{value:"{\n        visible: true,\n        incrementValue: 100,\n        widthPerUnit: 100,\n        cssStyle: { top: 10, left: 10 },\n    }"},description:"Parameters for the Distance Scale component",name:"scale",required:!1,type:{name:"{ visible?: boolean | null; incrementValue?: number | null; widthPerUnit?: number | null | undefined; cssStyle?: Record<string, unknown> | null | undefined; } | undefined"}},coordinateUnit:{defaultValue:{value:"m"},description:"",name:"coordinateUnit",required:!1,type:{name:"enum",value:[{value:'"m"'},{value:'"mm"'},{value:'"cm"'},{value:'"km"'},{value:'"in"'},{value:'"ft-us"'},{value:'"ft"'},{value:'"mi"'},{value:'"mm2"'},{value:'"cm2"'},{value:'"m2"'},{value:'"ha"'},{value:'"km2"'},{value:'"in2"'},{value:'"ft2"'},{value:'"ac"'},{value:'"mi2"'},{value:'"mcg"'},{value:'"mg"'},{value:'"g"'},{value:'"kg"'},{value:'"oz"'},{value:'"lb"'},{value:'"mt"'},{value:'"t"'},{value:'"mm3"'},{value:'"cm3"'},{value:'"ml"'},{value:'"l"'},{value:'"kl"'},{value:'"m3"'},{value:'"km3"'},{value:'"tsp"'},{value:'"Tbs"'},{value:'"in3"'},{value:'"fl-oz"'},{value:'"cup"'},{value:'"pnt"'},{value:'"qt"'},{value:'"gal"'},{value:'"ft3"'},{value:'"yd3"'},{value:'"mm3/s"'},{value:'"cm3/s"'},{value:'"ml/s"'},{value:'"cl/s"'},{value:'"dl/s"'},{value:'"l/s"'},{value:'"l/min"'},{value:'"l/h"'},{value:'"kl/s"'},{value:'"kl/min"'},{value:'"kl/h"'},{value:'"m3/s"'},{value:'"m3/min"'},{value:'"m3/h"'},{value:'"km3/s"'},{value:'"tsp/s"'},{value:'"Tbs/s"'},{value:'"in3/s"'},{value:'"in3/min"'},{value:'"in3/h"'},{value:'"fl-oz/s"'},{value:'"fl-oz/min"'},{value:'"fl-oz/h"'},{value:'"cup/s"'},{value:'"pnt/s"'},{value:'"pnt/min"'},{value:'"pnt/h"'},{value:'"qt/s"'},{value:'"gal/s"'},{value:'"gal/min"'},{value:'"gal/h"'},{value:'"ft3/s"'},{value:'"ft3/min"'},{value:'"ft3/h"'},{value:'"yd3/s"'},{value:'"yd3/min"'},{value:'"yd3/h"'},{value:'"C"'},{value:'"F"'},{value:'"K"'},{value:'"R"'},{value:'"ns"'},{value:'"mu"'},{value:'"ms"'},{value:'"s"'},{value:'"min"'},{value:'"h"'},{value:'"d"'},{value:'"week"'},{value:'"month"'},{value:'"year"'},{value:'"Hz"'},{value:'"mHz"'},{value:'"kHz"'},{value:'"MHz"'},{value:'"GHz"'},{value:'"THz"'},{value:'"rpm"'},{value:'"deg/s"'},{value:'"rad/s"'},{value:'"m/s"'},{value:'"km/h"'},{value:'"m/h"'},{value:'"knot"'},{value:'"ft/s"'},{value:'"s/m"'},{value:'"min/km"'},{value:'"s/ft"'},{value:'"Pa"'},{value:'"hPa"'},{value:'"kPa"'},{value:'"MPa"'},{value:'"bar"'},{value:'"torr"'},{value:'"psi"'},{value:'"ksi"'},{value:'"b"'},{value:'"Kb"'},{value:'"Mb"'},{value:'"Gb"'},{value:'"Tb"'},{value:'"B"'},{value:'"KB"'},{value:'"MB"'},{value:'"GB"'},{value:'"TB"'},{value:'"lx"'},{value:'"ft-cd"'},{value:'"ppm"'},{value:'"ppb"'},{value:'"ppt"'},{value:'"ppq"'},{value:'"V"'},{value:'"mV"'},{value:'"kV"'},{value:'"A"'},{value:'"mA"'},{value:'"kA"'},{value:'"W"'},{value:'"mW"'},{value:'"kW"'},{value:'"MW"'},{value:'"GW"'},{value:'"VA"'},{value:'"mVA"'},{value:'"kVA"'},{value:'"MVA"'},{value:'"GVA"'},{value:'"VAR"'},{value:'"mVAR"'},{value:'"kVAR"'},{value:'"MVAR"'},{value:'"GVAR"'},{value:'"Wh"'},{value:'"mWh"'},{value:'"kWh"'},{value:'"MWh"'},{value:'"GWh"'},{value:'"J"'},{value:'"kJ"'},{value:'"VARh"'},{value:'"mVARh"'},{value:'"kVARh"'},{value:'"MVARh"'},{value:'"GVARH"'},{value:'"deg"'},{value:'"rad"'},{value:'"grad"'},{value:'"arcmin"'},{value:'"arcsec"'}]}},toolbar:{defaultValue:{value:"{\n        visible: false,\n    }"},description:"Parameters to control toolbar",name:"toolbar",required:!1,type:{name:"{ visible?: boolean | null; }"}},colorTables:{defaultValue:null,description:"Prop containing color table data",name:"colorTables",required:!1,type:{name:"colorTablesArray"}},editedData:{defaultValue:null,description:"Prop containing edited data from layers",name:"editedData",required:!1,type:{name:"Record<string, unknown>"}},setEditedData:{defaultValue:null,description:"For reacting to prop changes",name:"setEditedData",required:!1,type:{name:"((data: Record<string, unknown>) => void)"}},checkDatafileSchema:{defaultValue:{value:"false"},description:"Validate JSON datafile against schema",name:"checkDatafileSchema",required:!1,type:{name:"boolean"}},onMouseEvent:{defaultValue:null,description:"For get mouse events",name:"onMouseEvent",required:!1,type:{name:"EventCallback"}},getCameraPosition:{defaultValue:null,description:"",name:"getCameraPosition",required:!1,type:{name:"((input: ViewStateType) => void)"}},isLoadedCallback:{defaultValue:null,description:"Will be called after all layers have finished loading data.",name:"isLoadedCallback",required:!1,type:{name:"((arg: boolean) => void)"}},triggerHome:{defaultValue:null,description:"If changed will reset camera to default position.",name:"triggerHome",required:!1,type:{name:"number"}},triggerResetMultipleWells:{defaultValue:null,description:"",name:"triggerResetMultipleWells",required:!1,type:{name:"number"}},selection:{defaultValue:null,description:"",name:"selection",required:!1,type:{name:"{ well: string; selection: [number, number | undefined] | undefined; } | undefined"}},lights:{defaultValue:null,description:"",name:"lights",required:!1,type:{name:"LightsType"}},getTooltip:{defaultValue:null,description:"",name:"getTooltip",required:!1,type:{name:"TooltipCallback"}},cameraPosition:{defaultValue:null,description:"",name:"cameraPosition",required:!1,type:{name:"ViewStateType"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/components/Map.tsx#Map"]={docgenInfo:Map.__docgenInfo,name:"Map",path:"packages/subsurface-viewer/src/components/Map.tsx#Map"})}catch(__react_docgen_typescript_loader_error){}},"./packages/subsurface-viewer/src/layers/BoxSelectionLayer/boxSelectionLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return BoxSelectionLayer}});var _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),_nebula_gl_layers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@nebula.gl/layers/dist-es6/index.js"),_deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js"),_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts");class BoxSelectionLayer extends _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_2__.Z{setMultiSelection(pickingInfos){if(this.internalState){const data=pickingInfos.map((item=>item.object)).filter((item=>"Feature"===item.type));this.setState({pickingInfos:pickingInfos,data:data})}}renderLayers(){if(0==this.props.visible)return[];const positionFormat="OrthographicViewport"===this.context.viewport.constructor.name?"XY":"XYZ",geoJsonLayer=new _deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_3__.Z({id:"geoJson",data:this.state.data,pickable:!1,stroked:!1,positionFormat:positionFormat,pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale?this.props.pointRadiusScale:1,lineWidthScale:this.props.lineWidthScale?this.props.lineWidthScale:1,getLineWidth:(0,_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__.ap)("line",this.props.lineStyle?.width,-1),getPointRadius:(0,_wells_wellsLayer__WEBPACK_IMPORTED_MODULE_1__.ap)("point",this.props.wellHeadStyle?.size,2),getFillColor:[255,140,0],getLineColor:[255,140,0]});return[new _nebula_gl_layers__WEBPACK_IMPORTED_MODULE_0__.Xr(this.getSubLayerProps({id:"selection",selectionType:"rectangle",onSelect:({pickingInfos:pickingInfos})=>{this.setMultiSelection(pickingInfos),this.props.handleSelection&&this.props.handleSelection(pickingInfos)},layerIds:this.props.layerIds,getTentativeFillColor:()=>[255,0,255,100],getTentativeLineColor:()=>[0,0,255,255],getTentativeLineDashArray:()=>[0,0],lineWidthMinPixels:3})),geoJsonLayer]}}BoxSelectionLayer.layerName="BoxSelectionLayer",BoxSelectionLayer.defaultProps={name:"boxSelection",id:"boxSelection-layer",pickable:!0,visible:!0,selectedFeatureIndexes:[],data:{type:"FeatureCollection",features:[]}}},"./packages/subsurface-viewer/src/layers/axes/axesLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return AxesLayer}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/layer.js"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"),esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/lib/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");const defaultProps={name:"Box",id:"box-layer",coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,lines:[],color:[0,0,0,1]};class BoxLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context;this.setState(this._getModels(gl))}shouldUpdateState(){return!0}updateState({context:context}){const{gl:gl}=context;this.setState(this._getModels(gl))}_getModels(gl){const color=this.props.color.map((x=>(x??0)/255)),grids=new model.Z(gl,{id:`${this.props.id}-grids`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",uniforms:{uColor:color},geometry:new geometry.Z({drawMode:esm.default.LINES,attributes:{positions:new Float32Array(this.props.lines)},vertexCount:this.props.lines.length/3}),modules:[project.Z],isInstanced:!1});return{model:grids,models:[grids].filter(Boolean),modelsByName:{grids:grids}}}}BoxLayer.layerName="BoxLayer",BoxLayer.defaultProps=defaultProps;var text_layer_text_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js");class AxesLayer extends composite_layer.Z{rebuildData(reportBoundingBox){const bounds=(0,lodash.cloneDeep)(this.props.bounds);this.props.ZIncreasingDownwards&&(bounds[2]*=-1,bounds[5]*=-1),bounds[2]>bounds[5]&&([bounds[2],bounds[5]]=[bounds[5],bounds[2]]),bounds[0]>bounds[3]&&([bounds[0],bounds[3]]=[bounds[3],bounds[0]]),bounds[1]>bounds[4]&&([bounds[1],bounds[4]]=[bounds[4],bounds[1]]);const box_lines=function GetBoxLines(bounds){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5];return[x_min,y_min,z_min,x_max,y_min,z_min,x_min,y_min,z_min,x_min,y_max,z_min,x_min,y_max,z_min,x_max,y_max,z_min,x_max,y_max,z_min,x_max,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_max,x_min,y_min,z_max,x_min,y_max,z_max,x_min,y_max,z_max,x_max,y_max,z_max,x_max,y_max,z_max,x_max,y_min,z_max,x_min,y_min,z_min,x_min,y_min,z_max,x_max,y_min,z_min,x_max,y_min,z_max,x_max,y_max,z_min,x_max,y_max,z_max,x_min,y_max,z_min,x_min,y_max,z_max]}(bounds),is_orthographic=this.context.viewport.constructor===orthographic_viewport.Z,[tick_lines,tick_labels]=function GetTickLines(isZIncreasingDownwards,is_orthographic,bounds,viewport){const ndecimals=0,n_minor_ticks=3,x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],lines=[],tick_labels=[];let x_tick=0,y_tick=0,z_tick=0;const delta=(x_max-x_min+(y_max-y_min)+(z_max-z_min))/3*.025,Lz=LineLengthInPixels([x_min,y_min,z_min],[x_min,y_min,z_max],viewport);if(!is_orthographic){const z_ticks=GetTicks(z_min,z_max,Lz);x_tick=x_min,y_tick=y_min;for(let i=0;i<z_ticks.length;i++){const tick=z_ticks[i],label=((isZIncreasingDownwards?-1:1)*tick).toFixed(ndecimals);tick_labels.push(label),lines.push(x_tick,y_tick,tick);const x=-delta*Math.cos(.7853925),y=-delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}if(z_ticks.length>1){const tick1=z_ticks[0],d=(z_ticks[1]-tick1)/(n_minor_ticks+1),z_start=tick1;let i=0;for(;z_start+(i+1)*d<z_max;){const tick=z_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}for(i=0;z_start-(i+1)*d>z_min;){const tick=z_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,y_tick,tick);const x=-.5*delta*Math.cos(.7853925),y=-.5*delta*Math.sin(.7853925);lines.push(x_tick+x,y_tick+y,tick)}}}const Lx=LineLengthInPixels([x_min,y_min,z_min],[x_max,y_min,z_min],viewport),x_ticks=GetTicks(x_min,x_max,Lx);y_tick=y_min,z_tick=z_min;for(let i=0;i<x_ticks.length;i++){const tick=x_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label),lines.push(tick,y_tick,z_tick);const z=0,y=-delta;lines.push(tick,y_tick+y,z_tick+z)}if(x_ticks.length>1){const tick1=x_ticks[0],d=(x_ticks[1]-tick1)/(n_minor_ticks+1),x_start=tick1;let i=0;for(;x_start+(i+1)*d<x_max;){const tick=x_start+(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}for(i=0;x_start-(i+1)*d>x_min;){const tick=x_start-(i+1)*d;tick_labels.push(""),i++,lines.push(tick,y_tick,z_tick);const z=0,y=-.5*delta;lines.push(tick,y_tick+y,z_tick+z)}}const Ly=LineLengthInPixels([x_min,y_min,z_min],[x_min,y_max,z_min],viewport),y_ticks=GetTicks(y_min,y_max,Ly);for(let i=0;i<y_ticks.length;i++){const tick=y_ticks[i],label=tick.toFixed(ndecimals);tick_labels.push(label);const x_tick=x_min,z_tick=z_min;lines.push(x_tick,tick,z_tick);const z=0,x=-delta;if(lines.push(x_tick+x,tick,z_tick+z),y_ticks.length>1){const tick1=y_ticks[0],d=(y_ticks[1]-tick1)/(n_minor_ticks+1),y_start=tick1;let i=0;for(;y_start+(i+1)*d<y_max;){const tick=y_start+(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}for(i=0;y_start-(i+1)*d>y_min;){const tick=y_start-(i+1)*d;tick_labels.push(""),i++,lines.push(x_tick,tick,z_tick);const z=0,x=-.5*delta;lines.push(x_tick+x,tick,z_tick+z)}}}return[lines,tick_labels]}(this.props.ZIncreasingDownwards,is_orthographic,bounds,this.context.viewport),textlayerData=function maketextLayerData(is_orthographic,tick_lines,tick_labels,bounds,labelFontSize){const x_min=bounds[0],x_max=bounds[3],y_min=bounds[1],y_max=bounds[4],z_min=bounds[2],z_max=bounds[5],dx=Math.abs(x_max-x_min),dy=Math.abs(y_max-y_min),dz=Math.abs(z_max-z_min),offset=(dx+dy+dz)/3*.1,data=[{label:"X",from:[0,0,0],to:[x_max+offset,y_min,z_min],size:labelFontSize??26},{label:"Y",from:[0,0,0],to:[x_min,y_max+offset,z_min],size:labelFontSize??26}];if(!is_orthographic){const z_axis_annotaion={label:"Z",from:[0,0,0],to:[x_min,y_min,z_max+offset],size:labelFontSize??26};data.push(z_axis_annotaion)}for(let i=0;i<tick_lines.length/6;i++){const from=[tick_lines[6*i+0],tick_lines[6*i+1],tick_lines[6*i+2]],to=[tick_lines[6*i+3],tick_lines[6*i+4],tick_lines[6*i+5]],label=tick_labels[i];data.push({label:label,from:from,to:to,size:labelFontSize??11})}return data}(is_orthographic,tick_lines,tick_labels,bounds,this.props.labelFontSize);this.setState({box_lines:box_lines,tick_lines:tick_lines,textlayerData:textlayerData}),void 0!==this.props.setReportedBoundingBox&&reportBoundingBox&&this.props.setReportedBoundingBox(bounds)}initializeState(){this.rebuildData(!0)}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.viewportChanged}updateState(){this.rebuildData(!1)}getAnchor(d,is_orthographic){const is_xaxis=d.from[1]!==d.to[1];if(is_orthographic&&is_xaxis)return"middle";const screen_from=this.context.viewport.project(d.from),screen_to=this.context.viewport.project(d.to);return"X"!==d.label&&"Y"!==d.label&&"Z"!==d.label&&screen_from[0]<screen_to[0]?"start":"end"}getLabelPosition(d){if("X"!==d.label&&"Y"!==d.label&&"Z"!==d.label){const tick_vec=[d.to[0]-d.from[0],d.to[1]-d.from[1]];d.to[2]&&d.from[2]&&tick_vec.push(d.to[2]-d.from[2]);const s=.5;return[d.to[0]+s*tick_vec[0],d.to[1]+s*tick_vec[1],d.to[2]+s*tick_vec[2]]}return d.to}getBaseLine(d,is_orthographic){if("X"===d.label)return"center";const is_xaxis_label=d.from[1]!==d.to[1];return is_orthographic&&is_xaxis_label?"top":"center"}renderLayers(){const is_orthographic=this.context.viewport.constructor===orthographic_viewport.Z,lines=[...this.state.box_lines,...this.state.tick_lines];return[new BoxLayer(this.getSubLayerProps({lines:lines,coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,color:this.props.axisColor||[0,0,0,255]})),new text_layer_text_layer.Z(this.getSubLayerProps({fontFamily:this.props.fontFamily??"Monaco, monospace",data:this.state.textlayerData,id:"text-layer",pickable:!0,getPosition:d=>this.getLabelPosition(d),getText:d=>d.label,sizeUnits:"pixels",getSize:d=>d.size,getAngle:0,getTextAnchor:d=>this.getAnchor(d,is_orthographic),getAlignmentBaseline:d=>this.getBaseLine(d,is_orthographic),coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,getColor:this.props.labelColor||[0,0,0,255]}))]}}function LineLengthInPixels(p0,p1,viewport){const screen_from=viewport.project(p0),screen_to=viewport.project(p1),v=[screen_from[0]-screen_to[0],screen_from[1]-screen_to[1],screen_from[2]-screen_to[2]];return Math.sqrt(v[0]*v[0]+v[1]*v[1])}function GetTicks(min,max,axis_pixel_length){let step=Math.min(Math.round(axis_pixel_length/100)+1,20);const range=max-min,delta=Math.abs(range)/step;let decade=1;if(delta>=10){const logde=Math.log10(delta),pot=Math.floor(logde);decade=Math.pow(10,pot)}let scaled_delta=Math.round(delta/decade);3==scaled_delta?scaled_delta=2:4==scaled_delta||6==scaled_delta||7==scaled_delta?scaled_delta=5:scaled_delta>7?scaled_delta=10:scaled_delta<1&&(scaled_delta=1);const incr=scaled_delta*decade,start=Math.ceil(min/incr)*incr,stop=Math.floor(max/incr)*incr,calc_step=Math.floor(Math.abs(stop-start)/incr);step=calc_step>0?calc_step:0;const ticks=[];for(let i=0;i<=step;i++){const x=start+i*incr;ticks.push(x)}return ticks}AxesLayer.layerName="AxesLayer",AxesLayer.defaultProps={"@@type":"AxesLayer",name:"Axes",id:"axes-layer",visible:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/axes2d/axes2DLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return Axes2DLayer}});var constants=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/layer.js"),orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"),esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js"),lib_model=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/lib/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"),line_vertex_glsl="#version 300 es\n#define SHADER_NAME axes2d-layer-vertex-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",line_fragment_glsl="#version 300 es\n#define SHADER_NAME axes2d-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec4 uColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",load=__webpack_require__("./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js"),texture_2d=__webpack_require__("./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"),image_loader=__webpack_require__("./node_modules/@loaders.gl/images/dist/esm/image-loader.js"),vec4=__webpack_require__("./node_modules/gl-matrix/esm/vec4.js"),mat4=__webpack_require__("./node_modules/gl-matrix/esm/mat4.js"),font_atlas_namespaceObject=__webpack_require__.p+"static/media/font-atlas.72792226.png";const DEFAULT_TEXTURE_PARAMETERS={[esm.default.TEXTURE_MIN_FILTER]:esm.default.LINEAR_MIPMAP_LINEAR,[esm.default.TEXTURE_MAG_FILTER]:esm.default.LINEAR,[esm.default.TEXTURE_WRAP_S]:esm.default.CLAMP_TO_EDGE,[esm.default.TEXTURE_WRAP_T]:esm.default.CLAMP_TO_EDGE};var TEXT_ANCHOR=function(TEXT_ANCHOR){return TEXT_ANCHOR[TEXT_ANCHOR.start=0]="start",TEXT_ANCHOR[TEXT_ANCHOR.middle=1]="middle",TEXT_ANCHOR[TEXT_ANCHOR.end=2]="end",TEXT_ANCHOR}(TEXT_ANCHOR||{}),ALIGNMENT_BASELINE=function(ALIGNMENT_BASELINE){return ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.top=1]="top",ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.center=0]="center",ALIGNMENT_BASELINE[ALIGNMENT_BASELINE.bottom=-1]="bottom",ALIGNMENT_BASELINE}(ALIGNMENT_BASELINE||{}),ViewSide=function(ViewSide){return ViewSide[ViewSide.Left=0]="Left",ViewSide[ViewSide.Right=1]="Right",ViewSide[ViewSide.Bottom=2]="Bottom",ViewSide[ViewSide.Top=3]="Top",ViewSide}(ViewSide||{});const defaultProps={"@@type":"Axes2DLayer",name:"Axes2D",id:"axes2d-layer",visible:!0,coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,marginH:80,marginV:30,isLeftRuler:!0,isRightRuler:!1,isBottomRuler:!0,isTopRuler:!1},fontInfo={letterHeight:92,spaceWidth:0,spacing:-1,textureWidth:1714,textureHeight:200,glyphInfos:{A:{x:0,y:0,width:86},B:{x:86,y:0,width:86},C:{x:172,y:0,width:86},D:{x:258,y:0,width:86},E:{x:344,y:0,width:86},F:{x:430,y:0,width:86},G:{x:516,y:0,width:86},H:{x:602,y:0,width:86},I:{x:688,y:0,width:86},J:{x:774,y:0,width:86},K:{x:860,y:0,width:86},L:{x:946,y:0,width:86},M:{x:1032,y:0,width:86},N:{x:1118,y:0,width:86},O:{x:1204,y:0,width:86},P:{x:1290,y:0,width:86},Q:{x:1376,y:0,width:86},R:{x:1462,y:0,width:86},S:{x:1548,y:0,width:86},T:{x:1634,y:0,width:86},U:{x:0,y:97,width:86},V:{x:86,y:97,width:86},W:{x:172,y:97,width:86},X:{x:258,y:97,width:86},Y:{x:344,y:97,width:86},Z:{x:430,y:97,width:86},0:{x:516,y:97,width:86},1:{x:602,y:97,width:86},2:{x:688,y:97,width:86},3:{x:774,y:97,width:86},4:{x:860,y:97,width:86},5:{x:946,y:97,width:86},6:{x:1032,y:97,width:86},7:{x:1118,y:97,width:86},8:{x:1204,y:97,width:86},9:{x:1290,y:97,width:86},"+":{x:1376,y:97,width:86},"-":{x:1462,y:97,width:86},".":{x:1548,y:97,width:86},",":{x:1634,y:97,width:86}}};class Axes2DLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context;(0,load.z)(font_atlas_namespaceObject,image_loader.S,{image:{type:"data"}}).then((data=>{const fontTexture=new texture_2d.Z(gl,{width:data.width,height:data.height,format:esm.default.RGB,data:data,parameters:DEFAULT_TEXTURE_PARAMETERS});this.setState({fontTexture:fontTexture,model:new lib_model.Z(gl,{id:"dummy",vs:line_vertex_glsl,fs:line_fragment_glsl})})}))}GetTickLinesAndLabels(min,max,viewSide,pixel2world){const lines=[],tick_labels=[],mv=this.props.marginV*pixel2world,mh=this.props.marginH*pixel2world,vpBounds=this.context.viewport.getBounds();let start,y_tick=0,x_tick=0;viewSide===ViewSide.Top?(start=vpBounds[3]-mv,y_tick=start):viewSide===ViewSide.Bottom?(start=vpBounds[1]+mv,y_tick=start):viewSide===ViewSide.Left?(start=vpBounds[0]+mh,x_tick=start):viewSide===ViewSide.Right&&(start=vpBounds[2]-mh,x_tick=start);const delta=10*pixel2world,L=function LineLengthInPixels(p0,p1,viewport){const screen_from=viewport.project(p0),screen_to=viewport.project(p1),v=[screen_from[0]-screen_to[0],screen_from[1]-screen_to[1],screen_from[2]-screen_to[2]],L=Math.sqrt(v[0]*v[0]+v[1]*v[1]);return L}([min,0,0],[max,0,0],this.context.viewport),isHorizontal=viewSide===ViewSide.Top||viewSide===ViewSide.Bottom,ticks=function GetTicks(min,max,axis_pixel_length){let step=Math.min(Math.round(axis_pixel_length/100)+1,20);const range=max-min,delta=Math.abs(range)/step;let decade=1;if(delta>=10){const logde=Math.log10(delta),pot=Math.floor(logde);decade=Math.pow(10,pot)}let scaled_delta=Math.round(delta/decade);3==scaled_delta?scaled_delta=2:4==scaled_delta||6==scaled_delta||7==scaled_delta?scaled_delta=5:scaled_delta>7?scaled_delta=10:scaled_delta<1&&(scaled_delta=1);const incr=scaled_delta*decade,start=Math.ceil(min/incr)*incr,stop=Math.floor(max/incr)*incr,calc_step=Math.floor(Math.abs(stop-start)/incr);step=calc_step>0?calc_step:0;const ticks=[];for(let i=0;i<=step;i++){const x=start+i*incr;ticks.push(x)}return ticks}(min,max,L),tick_length=viewSide===ViewSide.Left||viewSide===ViewSide.Bottom?-delta:delta;for(let i=0;i<ticks.length;i++){const tick=ticks[i],label=tick.toFixed(0);tick_labels.push(label),isHorizontal?(lines.push(tick,y_tick,92),lines.push(tick,y_tick+tick_length,92)):(lines.push(x_tick,tick,92),lines.push(x_tick+tick_length,tick,92))}if(ticks.length>1){const tick1=ticks[0],d=(ticks[1]-tick1)/4,tick_start=tick1;let i=0;for(;tick_start+(i+1)*d<max;){const tick=tick_start+(i+1)*d;tick_labels.push(""),i++,isHorizontal?(lines.push(tick,y_tick,92),lines.push(tick,y_tick+.5*tick_length,92)):(lines.push(x_tick,tick,92),lines.push(x_tick+.5*tick_length,tick,92))}for(i=0;tick_start-(i+1)*d>min;){const tick=tick_start-(i+1)*d;tick_labels.push(""),i++,isHorizontal?(lines.push(tick,y_tick,92),lines.push(tick,y_tick+.5*tick_length,92)):(lines.push(x_tick,tick,92),lines.push(x_tick+.5*tick_length,tick,92))}}return[lines,this.makeLabelsData(lines,tick_labels)]}GetBacgroundTriangleLinesHorizontal(x_min_w,x_max_w,isTop,pixel2world){const mv=this.props.marginV*pixel2world,vp_bounds=this.context.viewport.getBounds(),y_max=isTop?vp_bounds[3]:vp_bounds[1]+mv,y_min=isTop?vp_bounds[3]-mv:vp_bounds[1],p2=[x_max_w,y_max,90],p3=[x_max_w,y_min,90],p4=[x_min_w,y_min,90];return[...[x_min_w,y_max,90],...p2,...p4,...p2,...p4,...p3]}GetBacgroundTriangleLinesVertical(y_min_w,y_max_w,isLeft,pixel2world){const mh=this.props.marginH*pixel2world,vp_bounds=this.context.viewport.getBounds(),x_max=isLeft?vp_bounds[0]+mh:vp_bounds[2],x_min=isLeft?vp_bounds[0]:vp_bounds[2]-mh,p2=[x_max,y_max_w,90],p3=[x_min,y_max_w,90],p4=[x_min,y_min_w,90];return[...[x_max,y_min_w,90],...p2,...p4,...p2,...p4,...p3]}makeLabelsData(tick_lines,tick_labels){const labels=[];for(let i=0;i<tick_lines.length/6;i++){const from=[tick_lines[6*i+0],tick_lines[6*i+1],tick_lines[6*i+2]],to=[tick_lines[6*i+3],tick_lines[6*i+4],tick_lines[6*i+5]],label=tick_labels[i],tick_vec=[to[0]-from[0],to[1]-from[1],to[2]-from[2]],s=.5,pos=[to[0]+s*tick_vec[0],to[1]+s*tick_vec[1],to[2]+s*tick_vec[2]];let anchor=TEXT_ANCHOR.end,aligment=ALIGNMENT_BASELINE.center;if(from[1]!==to[1])anchor=TEXT_ANCHOR.middle,aligment=ALIGNMENT_BASELINE.top;else{const screen_from=this.context.viewport.project(from),screen_to=this.context.viewport.project(to);screen_from[0]<screen_to[0]&&(anchor=TEXT_ANCHOR.start)}labels.push({label:label,pos:pos,anchor:anchor,aligment:aligment})}return labels}draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}){const is_orthographic=this.context.viewport.constructor===orthographic_viewport.Z;if(void 0===this.state.fontTexture||!is_orthographic)return;const{gl:gl}=context;super.draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context});const{projectionMatrix:projectionMatrix}=this.context.viewport,{label_models:label_models,line_model:line_model,background_model:background_model}=this._getModels(gl),fontTexture=this.state.fontTexture;for(const model of label_models)model.setUniforms({projectionMatrix:projectionMatrix,fontTexture:fontTexture}).draw();line_model.draw(),gl.enable(esm.default.POLYGON_OFFSET_FILL),gl.polygonOffset(1,1),background_model.draw(),gl.disable(esm.default.POLYGON_OFFSET_FILL)}_getModels(gl){const world_from=this.context.viewport.unproject([0,0,0]),world_to=this.context.viewport.unproject([0,100,0]),v=[world_from[0]-world_to[0],world_from[1]-world_to[1],world_from[2]-world_to[2]],pixel2world=Math.sqrt(v[0]*v[0]+v[1]*v[1])/100,{viewMatrix:viewMatrix}=this.context.viewport,mh=this.props.marginH*pixel2world,mv=this.props.marginV*pixel2world,viewport_bounds_w=this.context.viewport.getBounds(),xBoundsMin=viewport_bounds_w[0],xBoundsMax=viewport_bounds_w[2],yBoundsMin=viewport_bounds_w[1],yBoundsMax=viewport_bounds_w[3];let tick_and_axes_lines=[],background_lines=[],labelData=[];const isB=this.props.isBottomRuler,isT=this.props.isTopRuler,isL=this.props.isLeftRuler,isR=this.props.isRightRuler,xmin=xBoundsMin+(isL?mh:0),xmax=xBoundsMax-(isR?mh:0),ymin=isB?yBoundsMin+mv:yBoundsMin,ymax=isT?yBoundsMax-mv:yBoundsMax;if(isB){const axes=[xmin,yBoundsMin+mv,91,xmax,yBoundsMin+mv,91],[ticks,labels]=this.GetTickLinesAndLabels(xmin,xmax,ViewSide.Bottom,pixel2world),back_lines=this.GetBacgroundTriangleLinesHorizontal(xBoundsMin,xBoundsMax,!1,pixel2world);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isT){const axes=[xmin,yBoundsMax-mv,91,xmax,yBoundsMax-mv,91],[ticks,labels]=this.GetTickLinesAndLabels(xmin,xmax,ViewSide.Top,pixel2world),back_lines=this.GetBacgroundTriangleLinesHorizontal(xBoundsMin,xBoundsMax,!0,pixel2world);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isL){const axes=[xBoundsMin+mh,ymin,91,xBoundsMin+mh,ymax,91],[ticks,labels]=this.GetTickLinesAndLabels(ymin,yBoundsMax-mv,ViewSide.Left,pixel2world),back_lines=this.GetBacgroundTriangleLinesVertical(ymin,ymax,!0,pixel2world);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}if(isR){const axes=[xBoundsMax-mh,ymin,91,xBoundsMax-mh,ymax,91],[ticks,labels]=this.GetTickLinesAndLabels(ymin,ymax,ViewSide.Right,pixel2world),back_lines=this.GetBacgroundTriangleLinesVertical(ymin,ymax,!1,pixel2world);tick_and_axes_lines=[...tick_and_axes_lines,...axes,...ticks],background_lines=[...background_lines,...back_lines],labelData=[...labelData,...labels]}let lineColor=[0,0,0,1];void 0!==this.props.axisColor&&(lineColor=this.props.axisColor,3===lineColor.length&&lineColor.push(255),lineColor=lineColor.map((x=>(x??0)/255)));const line_model=new lib_model.Z(gl,{id:`${this.props.id}-lines`,vs:line_vertex_glsl,fs:line_fragment_glsl,uniforms:{uColor:lineColor},geometry:new geometry.Z({drawMode:esm.default.LINES,attributes:{positions:new Float32Array(tick_and_axes_lines)},vertexCount:tick_and_axes_lines.length/3}),modules:[project.Z],isInstanced:!1});let bColor=[1,1,1,1];void 0!==this.props.backgroundColor&&(bColor=this.props.backgroundColor,3===bColor.length&&bColor.push(255),bColor=bColor.map((x=>(x??0)/255)));const background_model=new lib_model.Z(gl,{id:`${this.props.id}-background`,vs:line_vertex_glsl,fs:line_fragment_glsl,uniforms:{uColor:bColor},geometry:new geometry.Z({drawMode:esm.default.TRIANGLES,attributes:{positions:new Float32Array(background_lines)},vertexCount:background_lines.length/3}),modules:[project.Z],isInstanced:!1}),label_models=[];for(const item of labelData){const x=item.pos[0],y=item.pos[1],z=item.pos[2],label=item.label,anchor=item.anchor??TEXT_ANCHOR.start,aligment_baseline=item.aligment??ALIGNMENT_BASELINE.center;if(""===label)continue;const pos_view=word2view(viewMatrix,vec4.al(x,y,z,1)),pixelScale=8,len=label.length,numVertices=6*len,positions=new Float32Array(3*numVertices),texcoords=new Float32Array(2*numVertices),maxX=fontInfo.textureWidth,maxY=fontInfo.textureHeight;let offset=0,offsetTexture=0,x1=0;anchor===TEXT_ANCHOR.end?x1=-len:anchor===TEXT_ANCHOR.middle&&(x1=-len/2);let y_aligment_offset=0;aligment_baseline===ALIGNMENT_BASELINE.center?y_aligment_offset=.5*pixelScale:aligment_baseline===ALIGNMENT_BASELINE.top&&(y_aligment_offset=1*pixelScale);for(let ii=0;ii<len;++ii){const letter=label[ii],glyphInfo=fontInfo.glyphInfos[letter];if(glyphInfo){const x2=x1+1,u1=glyphInfo.x/maxX,v1=(glyphInfo.y+fontInfo.letterHeight-1)/maxY,u2=(glyphInfo.x+glyphInfo.width-1)/maxX,v2=glyphInfo.y/maxY,h=1,x=pos_view[0],y=pos_view[1]-y_aligment_offset,z=pos_view[2];positions[offset+0]=x+x1*pixelScale,positions[offset+1]=y+0*pixelScale,positions[offset+2]=z,texcoords[offsetTexture+0]=u1,texcoords[offsetTexture+1]=v1,positions[offset+3]=x+x2*pixelScale,positions[offset+4]=y+0*pixelScale,positions[offset+5]=z,texcoords[offsetTexture+2]=u2,texcoords[offsetTexture+3]=v1,positions[offset+6]=x+x1*pixelScale,positions[offset+7]=y+h*pixelScale,positions[offset+8]=z,texcoords[offsetTexture+4]=u1,texcoords[offsetTexture+5]=v2,positions[offset+9]=x+x1*pixelScale,positions[offset+10]=y+h*pixelScale,positions[offset+11]=z,texcoords[offsetTexture+6]=u1,texcoords[offsetTexture+7]=v2,positions[offset+12]=x+x2*pixelScale,positions[offset+13]=y+0*pixelScale,positions[offset+14]=z,texcoords[offsetTexture+8]=u2,texcoords[offsetTexture+9]=v1,positions[offset+15]=x+x2*pixelScale,positions[offset+16]=y+h*pixelScale,positions[offset+17]=z,texcoords[offsetTexture+10]=u2,texcoords[offsetTexture+11]=v2,x1+=1,offset+=18,offsetTexture+=12}else x1+=1}const id=`${this.props.id}-${label}`,model=new lib_model.Z(gl,{id:id,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nin vec2 vTexCoord;\nout vec2 _vTexCoord;\n\nuniform mat4 projectionMatrix;\n\nvoid main(void) {\n   _vTexCoord = vTexCoord;\n\n   vec3 position_commonspace = positions; // These positions are in view space.\n   gl_Position = projectionMatrix * vec4(position_commonspace, 1.0); // From viewspace to clip\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform sampler2D fontTexture;\n\nuniform vec4 uAxisColor;\nuniform vec4 uBackGroundColor;\n\nin vec2 _vTexCoord;\n\nvoid main(void) {\n  vec4 color = texture(fontTexture, _vTexCoord);\n  \n  float x = 1.0 - (color.r + color.g + color.b) / 3.0;  // intensity of text color\n  x = smoothstep(0.0, 0.2, x);  \n\n  float text_r = uAxisColor.r;\n  float text_g = uAxisColor.g;\n  float text_b = uAxisColor.b;\n\n  float bg_r = uBackGroundColor.r;\n  float bg_g = uBackGroundColor.g;\n  float bg_b = uBackGroundColor.b;\n  \n  float r = x * text_r + (1.0 - x) * bg_r;\n  float g = x * text_g + (1.0 - x) * bg_g;\n  float b = x * text_b + (1.0 - x) * bg_b;\n\n  fragColor = vec4(r, g, b, 1.0);\n  return;\n}\n",uniforms:{uAxisColor:lineColor,uBackGroundColor:bColor},geometry:new geometry.Z({drawMode:esm.default.TRIANGLES,attributes:{positions:positions,vTexCoord:{value:texcoords,size:2}},vertexCount:positions.length/3}),modules:[project.Z],isInstanced:!1});label_models.push(model)}return{label_models:label_models,line_model:line_model,background_model:background_model}}}function word2view(viewMatrix,pos_w){return vec4.fF(vec4.Ue(),pos_w,mat4.al(...viewMatrix.slice(0,mat4.al.length))).slice(0,3)}Axes2DLayer.layerName="Axes2DLayer",Axes2DLayer.defaultProps=defaultProps},"./packages/subsurface-viewer/src/layers/index.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Axes2DLayer:function(){return axes2DLayer.Z},Axes2DLayerProps:function(){return axes2DLayer.Axes2DLayerProps},AxesLayer:function(){return axesLayer.Z},AxesLayerProps:function(){return axesLayer.AxesLayerProps},BoxSelectionLayer:function(){return boxSelectionLayer.Z},BoxSelectionLayerProps:function(){return boxSelectionLayer.BoxSelectionLayerProps},ColormapLayer:function(){return ColormapLayer},ColormapLayerProps:function(){return colormapLayer_namespaceObject.ColormapLayerProps},DrawingLayer:function(){return DrawingLayer},DrawingLayerProps:function(){return drawingLayer_namespaceObject.DrawingLayerProps},FaultPolygonsLayer:function(){return FaultPolygonsLayer},FaultPolygonsLayerProps:function(){return faultPolygonsLayer_namespaceObject.FaultPolygonsLayerProps},Grid3DLayer:function(){return Grid3DLayer},Grid3DLayerProps:function(){return grid3dLayer_namespaceObject.Grid3DLayerProps},Hillshading2DLayer:function(){return Hillshading2DLayer},Hillshading2DProps:function(){return hillshading2dLayer_namespaceObject.Hillshading2DProps},Map3DLayer:function(){return Map3DLayer},Map3DLayerProps:function(){return map3DLayer_namespaceObject.Map3DLayerProps},MapLayer:function(){return mapLayer.Z},MapLayerProps:function(){return mapLayer.MapLayerProps},NorthArrow3DLayer:function(){return NorthArrow3DLayer},NorthArrow3DLayerProps:function(){return northArrow3DLayer_namespaceObject.NorthArrow3DLayerProps},PieChartLayer:function(){return PieChartLayer},PieChartLayerProps:function(){return pieChartLayer_namespaceObject.PieChartLayerProps},PointsLayer:function(){return pointsLayer.Z},PointsLayerProps:function(){return pointsLayer.PointsLayerProps},PolylinesLayer:function(){return polylinesLayer.Z},PolylinesLayerProps:function(){return polylinesLayer.PolylinesLayerProps},SelectableGeoJsonLayer:function(){return SelectableGeoJsonLayer},TriangleLayer:function(){return TriangleLayer},TriangleLayerProps:function(){return triangleLayer_namespaceObject.TriangleLayerProps},UnfoldedGeoJsonLayer:function(){return unfoldedGeoJsonLayer.Z},WellsLayer:function(){return wellsLayer.ZP},WellsLayerProps:function(){return wellsLayer.WellsLayerProps}});var colormapLayer_namespaceObject={};__webpack_require__.r(colormapLayer_namespaceObject),__webpack_require__.d(colormapLayer_namespaceObject,{Z:function(){return ColormapLayer}});var triangleLayer_namespaceObject={};__webpack_require__.r(triangleLayer_namespaceObject),__webpack_require__.d(triangleLayer_namespaceObject,{Z:function(){return TriangleLayer}});var map3DLayer_namespaceObject={};__webpack_require__.r(map3DLayer_namespaceObject),__webpack_require__.d(map3DLayer_namespaceObject,{Z:function(){return Map3DLayer}});var drawingLayer_namespaceObject={};__webpack_require__.r(drawingLayer_namespaceObject),__webpack_require__.d(drawingLayer_namespaceObject,{Z:function(){return DrawingLayer}});var hillshading2dLayer_namespaceObject={};__webpack_require__.r(hillshading2dLayer_namespaceObject),__webpack_require__.d(hillshading2dLayer_namespaceObject,{Z:function(){return Hillshading2DLayer}});var pieChartLayer_namespaceObject={};__webpack_require__.r(pieChartLayer_namespaceObject),__webpack_require__.d(pieChartLayer_namespaceObject,{Z:function(){return PieChartLayer}});var faultPolygonsLayer_namespaceObject={};__webpack_require__.r(faultPolygonsLayer_namespaceObject),__webpack_require__.d(faultPolygonsLayer_namespaceObject,{Z:function(){return FaultPolygonsLayer}});var northArrow3DLayer_namespaceObject={};__webpack_require__.r(northArrow3DLayer_namespaceObject),__webpack_require__.d(northArrow3DLayer_namespaceObject,{Z:function(){return NorthArrow3DLayer}});var grid3dLayer_namespaceObject={};__webpack_require__.r(grid3dLayer_namespaceObject),__webpack_require__.d(grid3dLayer_namespaceObject,{Z:function(){return Grid3DLayer}});var bitmap_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js"),esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js"),texture_2d=__webpack_require__("./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");const DEFAULT_DECODER={rgbScaler:[1,1,1],floatScaler:1,offset:0,step:0};var decoder={name:"decoder",fs:"struct Decoder\n{\n  vec3 rgbScaler; // r, g and b multipliers\n  float floatScaler; // value multiplier\n  float offset; // translation of the r, g, b sum\n  float step; // discretize the value in a number of steps\n};\n\nuniform Decoder decoder;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\n// Decode the RGB value using the decoder parameter.\nfloat decode_rgb2float(vec3 rgb, Decoder dec) {\n  rgb *= dec.rgbScaler * vec3(16711680.0, 65280.0, 255.0); //255*256*256, 255*256, 255\n  float value = (rgb.r + rgb.g + rgb.b + dec.offset) * dec.floatScaler;\n\n  // Value must be in [0, 1] and step in (0, 1]\n  value = floor(value / dec.step + 0.5) * dec.step;\n\n  // If colorMapRangeMin/Max specified, color map will span this interval.\n  float x  = value * (valueRangeMax - valueRangeMin) + valueRangeMin;\n  x = (x - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n  x = max(0.0, x);\n  x = min(1.0, x);\n\n  return x;\n}\n\n// Decode the RGB value using the decoder uniform.\nfloat decode_rgb2float(vec3 rgb) {\n  return decode_rgb2float(rgb, decoder);\n}\n",getUniforms:function getUniforms(opts){if(opts&&opts.valueDecoder){const{rgbScaler:rgbScaler=DEFAULT_DECODER.rgbScaler,floatScaler:floatScaler=DEFAULT_DECODER.floatScaler,offset:offset=DEFAULT_DECODER.offset,step:step=DEFAULT_DECODER.step}=opts.valueDecoder;return{"decoder.rgbScaler":rgbScaler,"decoder.floatScaler":floatScaler,"decoder.offset":offset,"decoder.step":Math.max(step,1e-7)}}return{}}};function decodeRGB([r,g,b],decoder,remapToRange){const{rgbScaler:rgbScaler,floatScaler:floatScaler,offset:offset,step:step}=decoder,[rScale,gScale,bScale]=rgbScaler;let decodedValue=((r*=256*rScale*256)+(g*=256*gScale)+(b*=bScale)+offset)*floatScaler;if(step>0&&(decodedValue=Math.floor(decodedValue/step+.5)*step),remapToRange){const[min,max]=remapToRange;decodedValue=decodedValue*(max-min)+min}return decodedValue}var layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");var dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js");const DEFAULT_TEXTURE_PARAMETERS={[esm.default.TEXTURE_MIN_FILTER]:esm.default.LINEAR_MIPMAP_LINEAR,[esm.default.TEXTURE_MAG_FILTER]:esm.default.LINEAR,[esm.default.TEXTURE_WRAP_S]:esm.default.CLAMP_TO_EDGE,[esm.default.TEXTURE_WRAP_T]:esm.default.CLAMP_TO_EDGE};function getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined=void 0!==colorMapFunction,data=new Uint8Array(768);for(let i=0;i<256;i++){const value=i/255,rgb=isColorMapFunctionDefined?colorMapFunction(i/255):(0,dist.cF)(value,colorMapName,colorTables);let color=[];null!=rgb&&(color=Array.isArray(rgb)?rgb:[rgb.r,rgb.g,rgb.b]),data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2]}return data}const defaultProps={"@@type":"ColormapLayer",name:"Property map",id:"colormap-layer",pickable:!0,visible:!0,valueRange:{type:"array",value:[0,1]},colorMapRange:{type:"array"},valueDecoder:{rgbScaler:[1,1,1],floatScaler:1/16777215,offset:0,step:0},rotDeg:0,colorMapName:"Rainbow"};class ColormapLayer extends bitmap_layer.Z{initializeState(){this.setState({isLoaded:!1}),super.initializeState()}draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}){if(!this.state.isLoaded&&(this.setState({isLoaded:!0}),void 0!==this.props.setReportedBoundingBox)){const bbox=[this.props.bounds[0],this.props.bounds[1],1,this.props.bounds[2],this.props.bounds[3],-1];this.props.setReportedBoundingBox(bbox)}const mergedModuleParams={...moduleParameters,valueDecoder:{...defaultProps.valueDecoder,...moduleParameters.valueDecoder},modelMatrix:(0,layerTools.RT)(this.props.rotDeg,this.props.bounds[0],this.props.bounds[3])};super.setModuleParameters(mergedModuleParams);const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax;super.draw({uniforms:{...uniforms,colormap:new texture_2d.Z(context.gl,{width:256,height:1,format:esm.default.RGB,data:getImageData(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction),parameters:DEFAULT_TEXTURE_PARAMETERS}),valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax},moduleParameters:mergedModuleParams})}getShaders(){const parentShaders=super.getShaders();return parentShaders.fs="#define SHADER_NAME colormap-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D bitmapTexture; // Property map\nuniform sampler2D colormap;\n\nuniform float opacity;\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  // If it's a picking pass, we just return the raw property map value.\n  if (picking_uActive) {\n    gl_FragColor = bitmapColor;\n    return;\n  }\n\n  // Decode the RGB value into a float. See decoder.fs.glsl for more details.\n  float val = decode_rgb2float(bitmapColor.rgb);\n  // The resulting val will be in [0, 1] interval, so we can use it directly as a texture coord\n  // to sample from the colormap.\n  // 0 => Leftmost color in the colormap, 1 => rightmost color, linearly interpolated in between.\n  vec4 color = texture2D(colormap, vec2(val, 0.5));\n\n  // The final pixel opacity is the combination of the user provided image-wide opacity,\n  // the colormap opacity at the sampled pixel and the property map opacity of the sampled pixel.\n  gl_FragColor = vec4(color.rgb, color.a * bitmapColor.a * opacity);\n\n  // Support for existing functionality that comes from the BitmapLayer, such as desaturate, tintColor etc.\n  // See https://deck.gl/docs/api-reference/layers/bitmap-layer#render-options for more details.\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n}\n",parentShaders.modules.push(decoder),parentShaders}getPickingInfo({info:info}){if(this.state.pickingDisabled||!info.color)return info;const mergedDecoder={...defaultProps.valueDecoder,...this.props.valueDecoder},val=decodeRGB(info.color,mergedDecoder,this.props.valueRange);return{...info,index:0,propertyValue:val}}getLegendData(){const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1;return{discrete:!1,valueRange:[this.props.colorMapRange?.[0]??valueRangeMin,this.props.colorMapRange?.[1]??valueRangeMax],colorName:this.props.colorMapName,title:"PropertyMapLayer",colorMapFunction:this.props.colorMapFunction}}}ColormapLayer.layerName="ColormapLayer",ColormapLayer.defaultProps=defaultProps;var mapLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/map/mapLayer.ts"),composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/layer.js"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"),phong_lighting=__webpack_require__("./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js"),lib_model=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/lib/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");const privateTriangleLayer_defaultProps={data:["dummy"],contours:[-1,-1],isContoursDepth:!0,gridLines:!1,color:[100,100,255],coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,depthTest:!0};class PrivateTriangleLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context,[triangleModel,lineMode]=this._getModels(gl);this.setState({models:[triangleModel,lineMode]})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(gl){return[new lib_model.Z(gl,{id:`${this.props.id}-mesh`,vs:"#version 300 es\n#define SHADER_NAME vertex-shader\n\nprecision highp float;\n\n// Primitive attributes\nin vec3 positions;\nin float properties;\nin vec3 normals;\n\n// Outputs to fragment shader\n//out vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec3 worldPos;\nout float property;\n\n\nvoid main(void) {\n   cameraPosition = project_uCameraPosition;\n\n   worldPos = positions;\n\n   normals_commonspace = normals;\n\n   property = properties;\n\n   position_commonspace = vec4(project_position(positions), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n}\n",fs:'#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec3 worldPos;\nin float property;\n\nout vec4 fragColor;\n\nuniform sampler2D colormap;\nuniform vec4 uColor;\nuniform bool smoothShading;\n\n\nvec3 getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    \n   vec3 halfway_direction = normalize(light_direction + view_direction);   \n   float lambertian = abs(dot(light_direction, normal_worldspace));\n\n   float specular_angle = abs(dot(normal_worldspace, halfway_direction));\n\n   float specular = pow(specular_angle, lighting_uShininess);       \n   return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;    \n}\n\nvec3 getLightColor(vec3 surfaceColor,vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvoid main(void) {\n   //geometry.uv = vTexCoord;\n\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n   \n   //Picking pass.\n   if (picking_uActive) {\n      // Readout is surface height (z value).\n      float range = 10000.0;  // May represent depths in range 0 - 10000 meter.\n\n      // Express in 255 system.\n      float depth = abs(worldPos.z);\n      float depthScaled = (256.0 * 256.0 * 256.0) * (depth / range); // scaled to within max range in 256 system.\n\n      float r = 0.0;\n      float g = 0.0;\n      float b = 0.0;\n\n      if (depthScaled >= (256.0 * 256.0) - 1.0) {\n         r = floor(depthScaled / (256.0 * 256.0));\n         depthScaled -= r * (256.0 * 256.0);\n      }\n\n      if (depthScaled >= 256.0 - 1.0) {\n         g = floor(depthScaled / 256.0);\n         depthScaled -= g * 256.0;\n      }\n\n      b = floor(depthScaled);\n\n      fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n      return;\n   }\n\n   vec4 color = uColor;\n\n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val = (abs(worldPos.z) - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use normal lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',geometry:new geometry.Z(this.props.geometryTriangles),modules:[project.Z,picking.Z,phong_lighting.s],isInstanced:!1}),new lib_model.Z(gl,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n  // Picking pass.\n  if (picking_uActive) {\n    discard;\n    return;\n  }\n\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.Z(this.props.geometryLines),modules:[project.Z,picking.Z],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{uniforms:uniforms,context:context}=args,{gl:gl}=context,contourReferencePoint=this.props.contours[0]??-1,contourInterval=this.props.contours[1]??-1,[triangleModel,lineModel]=this.state.models,smoothShading=this.props.smoothShading,uColor=this.props.color.map((x=>(x??0)/255));uColor.push(1),this.props.depthTest||gl.disable(esm.default.DEPTH_TEST),gl.enable(esm.default.POLYGON_OFFSET_FILL),gl.polygonOffset(1,1),triangleModel.setUniforms({...uniforms,contourReferencePoint:contourReferencePoint,contourInterval:contourInterval,smoothShading:smoothShading,uColor:uColor}).draw(),gl.disable(esm.default.POLYGON_OFFSET_FILL),this.props.gridLines&&lineModel.draw(),this.props.depthTest||gl.enable(esm.default.DEPTH_TEST)}decodePickingColor(){return 0}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],depth=(256*info.color[0]*256+256*info.color[1]+1*info.color[2])/16777216*1e4;return layer_properties.push((0,layerTools.ws)("Depth",depth)),{...info,properties:layer_properties}}}PrivateTriangleLayer.layerName="privateTriangleLayer",PrivateTriangleLayer.defaultProps=privateTriangleLayer_defaultProps;var lodash=__webpack_require__("./node_modules/lodash/lodash.js");function makeFullMesh(e){const params=e.data,t0=performance.now();function normalize(a){const L=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);a[0]/=L,a[1]/=L,a[2]/=L}const line_positions=[],vertexArray=params.vertexArray,indexArray=params.indexArray,ntriangles=indexArray.length/3,nvertices=vertexArray.length/3,trianglesNormals=Array(3*ntriangles).fill(0),vertexsNormals=Array(vertexArray.length).fill(0);for(let t_no=0;t_no<ntriangles;t_no++){let indx=indexArray[3*t_no+0];const x0=vertexArray[3*indx+0],y0=vertexArray[3*indx+1],z0=vertexArray[3*indx+2];indx=indexArray[3*t_no+1];const x1=vertexArray[3*indx+0],y1=vertexArray[3*indx+1],z1=vertexArray[3*indx+2];indx=indexArray[3*t_no+2];const x2=vertexArray[3*indx+0],y2=vertexArray[3*indx+1],z2=vertexArray[3*indx+2];line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1),line_positions.push(x0,y0,z0),line_positions.push(x2,y2,z2),line_positions.push(x1,y1,z1),line_positions.push(x2,y2,z2);const normal=[(a=[x2-x1,y2-y1,z2-z1])[1]*(b=[x2-x0,y2-y0,z2-z0])[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];trianglesNormals[3*t_no+0]=normal[0],trianglesNormals[3*t_no+1]=normal[1],trianglesNormals[3*t_no+2]=normal[2]}var a,b;const vertexTrianglesArray=Array(vertexArray.length/3);for(let i=0;i<vertexTrianglesArray.length;i++)vertexTrianglesArray[i]=new Array(0);for(let t_no=0;t_no<ntriangles;t_no++){vertexTrianglesArray[indexArray[3*t_no+0]].push(t_no);vertexTrianglesArray[indexArray[3*t_no+1]].push(t_no);vertexTrianglesArray[indexArray[3*t_no+2]].push(t_no)}for(let vertex_no=0;vertex_no<nvertices;vertex_no++){const n_triangles=vertexTrianglesArray[vertex_no].length,t0=vertexTrianglesArray[vertex_no][0],normal_mean=[trianglesNormals[3*t0+0],trianglesNormals[3*t0+1],trianglesNormals[3*t0+2]];for(let t_no=1;t_no<n_triangles;t_no++){const t=vertexTrianglesArray[vertex_no][t_no],normal=[trianglesNormals[3*t+0],trianglesNormals[3*t+1],trianglesNormals[3*t+2]];normal_mean[0]+=normal[0],normal_mean[1]+=normal[1],normal_mean[2]+=normal[2]}normalize(normal_mean),vertexsNormals[3*vertex_no+0]=normal_mean[0],vertexsNormals[3*vertex_no+1]=normal_mean[1],vertexsNormals[3*vertex_no+2]=normal_mean[2];if(params.displayNormals){const x0=vertexArray[3*vertex_no+0],y0=vertexArray[3*vertex_no+1],z0=vertexArray[3*vertex_no+2],scale=50,x1=x0+normal_mean[0]*scale,y1=y0+normal_mean[1]*scale,z1=z0+normal_mean[2]*scale;line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1)}}const geometryTriangles={drawMode:4,attributes:{positions:{value:new Float32Array(vertexArray),size:3},normals:{value:new Float32Array(vertexsNormals),size:3},vertex_indexs:{value:new Int32Array(indexArray),size:1}},vertexCount:indexArray.length,indices:{value:new Uint32Array(indexArray),size:1}},geometryLines={drawMode:1,attributes:{positions:{value:new Float32Array(line_positions),size:3}},vertexCount:line_positions.length/3},t1=performance.now();console.debug(`Task makeMesh took ${.001*(t1-t0)}  seconds.`),postMessage([geometryTriangles,geometryLines])}class TriangleLayer extends composite_layer.Z{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinished=this.state?.isFinishedLoading??!1;return isLoaded&&isFinished}rebuildData(reportBoundingBox){const p=async function loadData(pointsData,triangleData,ZIncreasingDownwards){let vertexArray=new Float32Array;if(Array.isArray(pointsData))vertexArray=new Float32Array(pointsData);else{const response_mesh=await fetch(pointsData);response_mesh.ok||console.error("Could not load vertex data");const blob_mesh=await response_mesh.blob(),buffer=await blob_mesh.arrayBuffer();vertexArray=new Float32Array(buffer)}if(ZIncreasingDownwards)for(let i=0;i<pointsData.length/3;i++)vertexArray[3*i+2]*=-1;let indexArray=new Uint32Array;if(Array.isArray(triangleData))indexArray=new Uint32Array(triangleData);else{const response_mesh=await fetch(triangleData);response_mesh.ok||console.error("Could not load triangle index data");const blob_mesh=await response_mesh.blob(),buffer=await blob_mesh.arrayBuffer();indexArray=new Uint32Array(buffer)}return Promise.all([vertexArray,indexArray])}(this.props.pointsData,this.props.triangleData,this.props.ZIncreasingDownwards);p.then((([vertexArray,indexArray])=>{const blob=new Blob(["self.onmessage = ",makeFullMesh.toString()],{type:"text/javascript"}),url=URL.createObjectURL(blob),webWorker=new Worker(url),webworkerParams={vertexArray:vertexArray,indexArray:indexArray,smoothShading:this.props.smoothShading,displayNormals:this.props.debug};webWorker.postMessage(webworkerParams),webWorker.onmessage=e=>{const[geometryTriangles,geometryLines]=e.data;if(this.setState({geometryTriangles:geometryTriangles,geometryLines:geometryLines}),void 0!==this.props.setReportedBoundingBox&&reportBoundingBox){let xmax=-99999999,xmin=99999999,ymax=-99999999,ymin=99999999,zmax=-99999999,zmin=99999999;for(let i=0;i<vertexArray.length/3;i++)xmax=vertexArray[3*i+0]>xmax?vertexArray[3*i+0]:xmax,xmin=vertexArray[3*i+0]<xmin?vertexArray[3*i+0]:xmin,ymax=vertexArray[3*i+1]>ymax?vertexArray[3*i+1]:ymax,ymin=vertexArray[3*i+1]<ymin?vertexArray[3*i+1]:ymin,zmax=vertexArray[3*i+2]>zmax?vertexArray[3*i+2]:zmax,zmin=vertexArray[3*i+2]<zmin?vertexArray[3*i+2]:zmin;if(this.props.ZIncreasingDownwards){const tmp=zmin;zmin=zmax,zmax=tmp}this.props.setReportedBoundingBox([xmin,ymin,zmin,xmax,ymax,zmax])}webWorker.terminate(),this.setState({...this.state,isFinishedLoading:!0})}}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.debug,oldProps.debug)&&(0,lodash.isEqual)(props.pointsData,oldProps.pointsData)&&(0,lodash.isEqual)(props.triangleData,oldProps.triangleData)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];return[new PrivateTriangleLayer(this.getSubLayerProps({geometryTriangles:this.state.geometryTriangles,geometryLines:this.state.geometryLines,pickable:this.props.pickable,contours:this.props.contours,gridLines:this.props.gridLines,color:this.props.color,material:this.props.material,smoothShading:this.props.smoothShading,depthTest:this.props.depthTest}))]}}TriangleLayer.layerName="TriangleLayer",TriangleLayer.defaultProps={"@@type":"TriangleLayer",name:"TriangleLayer",id:"triangle-layer",pickable:!0,visible:!0,contours:[-1,-1],color:[100,100,255],gridLines:!1,smoothShading:!0,material:!0,depthTest:!0,ZIncreasingDownwards:!0,debug:!1};var pointsLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/points/pointsLayer.ts"),polylinesLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/polylines/polylinesLayer.ts"),simple_mesh_layer=__webpack_require__("./node_modules/@deck.gl/mesh-layers/dist/esm/simple-mesh-layer/simple-mesh-layer.js");var legendCommonFunction=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/component/Utils/legendCommonFunction.js");const terrainMapLayer_DEFAULT_TEXTURE_PARAMETERS={[esm.default.TEXTURE_MIN_FILTER]:esm.default.LINEAR_MIPMAP_LINEAR,[esm.default.TEXTURE_MAG_FILTER]:esm.default.LINEAR,[esm.default.TEXTURE_WRAP_S]:esm.default.CLAMP_TO_EDGE,[esm.default.TEXTURE_WRAP_T]:esm.default.CLAMP_TO_EDGE},DECODER={rScaler:65536,gScaler:256,bScaler:1,offset:0};function terrainMapLayer_getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined=void 0!==colorMapFunction,isColorMapNameDefined=!!colorMapName,data=new Uint8Array(768),defaultColorMap=legendCommonFunction.z$;let colorMap=colorMapFunction;isColorMapFunctionDefined||(colorMap=isColorMapNameDefined?value=>(0,dist.CA)(value,colorMapName,colorTables):defaultColorMap());for(let i=0;i<256;i++){const color=colorMap?colorMap(i/255):[0,0,0];color&&(data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2])}return data||[0,0,0]}const terrainMapLayer_defaultProps={data:[{position:[0,0],angle:0,color:[255,0,0,0]}],getPosition:d=>d.position,getColor:d=>d.color,getOrientation:d=>[0,d.angle,0],contours:[-1,-1],colorMapName:"",propertyValueRange:[0,1],isContoursDepth:!0,coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,textureImageData:{value:null,type:"object",async:!0},meshImageData:{value:null,type:"object",async:!0},meshValueRange:[0,1],depthTest:!0};class TerrainMapLayer extends simple_mesh_layer.Z{draw({uniforms:uniforms,context:context}){const{gl:gl}=context,contourReferencePoint=this.props.contours[0]??-1,contourInterval=this.props.contours[1]??-1,isContoursDepth=this.props.isContoursDepth,valueRangeMin=this.props.propertyValueRange[0]??0,valueRangeMax=this.props.propertyValueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,isClampColor=void 0!==this.props.colorMapClampColor&&!0!==this.props.colorMapClampColor&&!1!==this.props.colorMapClampColor;let colorMapClampColor=isClampColor?this.props.colorMapClampColor:[0,0,0];colorMapClampColor=colorMapClampColor.map((x=>(x??0)/255));const isColorMapClampColorTransparent=!1===this.props.colorMapClampColor;this.props.depthTest||gl.disable(esm.default.DEPTH_TEST),super.draw({uniforms:{...uniforms,colormap:new texture_2d.Z(context.gl,{width:256,height:1,format:esm.default.RGB,data:terrainMapLayer_getImageData(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction),parameters:terrainMapLayer_DEFAULT_TEXTURE_PARAMETERS}),valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax,contourReferencePoint:contourReferencePoint,contourInterval:contourInterval,isContoursDepth:isContoursDepth,colorMapClampColor:colorMapClampColor,isColorMapClampColorTransparent:isColorMapClampColorTransparent,isClampColor:isClampColor}}),this.props.depthTest||gl.enable(esm.default.DEPTH_TEST)}getShaders(){const parentShaders=super.getShaders();return parentShaders.fs="#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\n\nuniform bool isContoursDepth;\n\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nin vec4 positions;\n\nout vec4 fragColor;\n\nin vec3 worldPos; // we export this from vertex shader (by injecting into it).\n\nuniform sampler2D colormap;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform vec3 colorMapClampColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\n\n\nvoid main(void) {\n   geometry.uv = vTexCoord;\n\n   vec3 normal;\n   if (flatShading) {\n#ifdef DERIVATIVES_AVAILABLE\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n      normal = vec3(0.0, 0.0, 1.0);\n#endif\n   } else {\n      normal = normals_commonspace;\n   }\n\n   vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\n\n   float texture_alpha = color.a;\n\n   // Discard transparent pixels.\n   if (!picking_uActive && color.w < 0.99) {\n         discard;\n         return;\n   }\n\n   // Picking pass.\n   if (picking_uActive) {\n      // Send texture coordinates.\n      float s = vTexCoord.x;\n      float t = vTexCoord.y;\n      float b = texture_alpha > 0.95 ? 255.0 : 0.0;\n\n      fragColor = vec4(s, t, b, 1.0);\n      return;\n   }\n\n   float propertyValue = 0.0;\n   if (hasTexture) {\n      float opcacity = color.w;\n      float floatScaler =  1.0 / (256.0 * 256.0 * 256.0 - 1.0);\n      vec3 rgb = color.rgb;\n      rgb *= vec3(16711680.0, 65280.0, 255.0); //255*256*256, 255*256, 255\n      float propertyValue_norm = (rgb.r + rgb.g + rgb.b) * floatScaler; // propertyValue_norm will be in range [0-1]\n\n      // If colorMapRangeMin/Max specified, color map will span this interval.\n      propertyValue  = propertyValue_norm * (valueRangeMax - valueRangeMin) + valueRangeMin;\n      float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n;\n      if (x < 0.0 || x > 1.0) {\n         // Out of range. Use clampcolor.\n         if (isClampColor) {\n            color = vec4(colorMapClampColor.rgb, 1.0);\n\n         }\n         else if (isColorMapClampColorTransparent) {\n            discard;\n            return;\n         }\n         else {\n            // Use min/max color to clamp.\n            x = max(0.0, x);\n            x = min(1.0, x);\n\n            color = texture2D(colormap, vec2(x, 0.5));\n            color.a = opcacity;\n         }\n      }\n      else {\n         color = texture2D(colormap, vec2(x, 0.5));\n         color.a = opcacity;\n      }\n   }\n\n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val =  (hasTexture && !isContoursDepth) ? (propertyValue - contourReferencePoint) / contourInterval\n                                                    : (abs(worldPos.z) - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use normal lighting.\n   vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, color.a * opacity);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",{...parentShaders,inject:{"vs:#decl":"\n                  out vec3 worldPos;\n                ","vs:#main-start":"\n                   worldPos = positions;\n                "}}}decodePickingColor(){return 0}getPickingInfo({info:info}){const pickColor=info.color;if(!pickColor)return info;const s=pickColor[0]/255,t=pickColor[1]/255;if(0==pickColor[2])return info;const meshImageData=this.props.meshImageData,isMeshImageData=null!==meshImageData,value_mesh=isMeshImageData?getValue(meshImageData,s,t,DECODER):0,value_property=getValue(this.props.textureImageData,s,t,DECODER),layer_properties=[];return layer_properties.push(getMapProperty("Property",value_property,this.props.propertyValueRange),isMeshImageData?getMapProperty("Depth",value_mesh,this.props.meshValueRange):{name:"Depth",value:0}),{...info,properties:layer_properties}}}function getMapProperty(name,value,value_range){const[min,max]=value_range;return value=value*(1/16777215)*(max-min)+min,(0,layerTools.ws)(name,value)}function getValue(imageData,s,t,decoder){const int_view=new Uint8ClampedArray(imageData.data,0,imageData.data.length),w=imageData.width,h=imageData.height,j=Math.min(Math.floor(w*s),w-1),pixelNo=Math.min(Math.floor(h*t),h-1)*w+j;return int_view[4*pixelNo+0]*decoder.rScaler+int_view[4*pixelNo+1]*decoder.gScaler+int_view[4*pixelNo+2]*decoder.bScaler}TerrainMapLayer.layerName="TerrainMapLayer",TerrainMapLayer.defaultProps=terrainMapLayer_defaultProps;var dist_esm=__webpack_require__("./node_modules/@loaders.gl/terrain/dist/esm/index.js"),image_loader=__webpack_require__("./node_modules/@loaders.gl/images/dist/esm/image-loader.js"),load=__webpack_require__("./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js"),vector3=__webpack_require__("./node_modules/@math.gl/core/dist/esm/classes/vector3.js");function getMinMax(dim){const nx=dim.count[0],ny=dim.count[1],dx=dim.increment[0],dy=dim.increment[1],xmin=dim.origin[0],ymin=dim.origin[1];return[xmin,ymin,xmin+nx*dx,ymin+ny*dy]}async function load_mesh_and_texture(mesh_name,bounds,meshMaxError,meshValueRange,smoothShading,texture_name){const isMesh=""!==mesh_name,isTexture=""!==texture_name;isMesh||isTexture||console.error("Error. One or both of texture and mesh must be given!");const image_name=isTexture?texture_name:mesh_name,texture=await(0,load.z)(image_name,image_loader.S,{image:{type:"data"}});let mesh,meshImageData=null;if(isMesh)mesh=await(0,load.z)(mesh_name,dist_esm.xu,{terrain:{elevationDecoder:DECODER,bounds:bounds,meshMaxError:meshMaxError,skirtHeight:0},worker:!1}),mesh=function mapToRange(resolved_mesh,meshValueRange){const[min,max]=meshValueRange,delta=max-min,vertexs=resolved_mesh.attributes.POSITION.value,nvertexs=vertexs.length/3;for(let i=0;i<nvertexs;i++){let Z=vertexs[3*i+2];Z*=5.960464832810452e-8,Z=min+Z*delta,vertexs[3*i+2]=-Z}return resolved_mesh}(mesh,meshValueRange),meshImageData=await(0,load.z)(mesh_name,image_loader.S,{image:{type:"data"}}),smoothShading&&meshImageData&&(mesh=function add_normals(resolved_mesh,meshImageData,bounds){const vertexs=resolved_mesh.attributes.POSITION.value;let indices=resolved_mesh.indices.value,ntriangles=indices.length/3;const[xmin,ymin,xmax,ymax]=bounds,w=meshImageData.width,h=meshImageData.height,int_view=new Uint8ClampedArray(meshImageData.data,0,meshImageData.data.length),dx=(xmax-xmin)/(w-1),dy=(ymax-ymin)/(h-1),indices_reduced=[];for(let tn=0;tn<ntriangles;tn++){const i0=indices[3*tn+0],i1=indices[3*tn+1],i2=indices[3*tn+2];[i0,i1,i2].map((index=>{const x=vertexs[3*index+0],y=vertexs[3*index+1],j=Math.round((x-xmin)/dx),i=h-Math.round((y-ymin)/dy);return int_view[4*(i*w+j)+3]<255})).some((a=>a))||(indices_reduced.push(i0),indices_reduced.push(i1),indices_reduced.push(i2))}resolved_mesh.indices.value=new Uint32Array(indices_reduced),indices=resolved_mesh.indices.value,ntriangles=indices.length/3;const no_unique_vertexes=vertexs.length/3,vertex_triangles=Array(no_unique_vertexes);for(let i=0;i<no_unique_vertexes;i++)vertex_triangles[i]=new Set;const triangle_normals=Array(ntriangles);for(let t=0;t<ntriangles;t++){const i0=indices[3*t+0],i1=indices[3*t+1],i2=indices[3*t+2];vertex_triangles[i0].add(t),vertex_triangles[i1].add(t),vertex_triangles[i2].add(t);const v0=new vector3.Z(vertexs[3*i0+0],vertexs[3*i0+1],vertexs[3*i0+2]),v1=new vector3.Z(vertexs[3*i1+0],vertexs[3*i1+1],vertexs[3*i1+2]),v2=new vector3.Z(vertexs[3*i2+0],vertexs[3*i2+1],vertexs[3*i2+2]),vec1=v1.subtract(v0),vec2=v2.subtract(v0),normal=vec1.cross(vec2).normalize();triangle_normals[t]=normal}const normals=Array(vertexs.length).fill(0);for(let i=0;i<no_unique_vertexes;i++){const triangles=[...vertex_triangles[i]],v=0!==triangles.length?triangle_normals[triangles[0]]:new vector3.Z(0,0,1);for(let t=1;t<triangles.length;t++)v.add(triangle_normals[triangles[t]]);v.normalize();const idx=3*i;normals[idx+0]=v[0],normals[idx+1]=v[1],normals[idx+2]=v[2]}return resolved_mesh.attributes.normals={value:new Float32Array(normals),size:3},resolved_mesh}(mesh,meshImageData,bounds));else{const[minX,minY,maxX,maxY]=bounds,vertexes=[...[minX,minY,0],...[minX,maxY,0],...[maxX,maxY,0],...[maxX,minY,0]],texture_coord=[0,1,0,0,1,0,1,1];mesh={attributes:{POSITION:{value:new Float32Array(vertexes),size:3},TEXCOORD_0:{value:new Float32Array(texture_coord),size:2}},indices:{value:new Uint32Array([0,1,3,1,3,2]),size:1}}}return Promise.all([mesh,meshImageData,texture])}class Map3DLayer extends composite_layer.Z{initializeState(){const isBounds=void 0!==this.props.bounds;isBounds&&console.warn('"bounds" is deprecated. Use "frame" instead.');const isFrame=void 0!==this.props.frame;isBounds||isFrame||console.error('Error. Either "Frame" or "bounds" must be given for map3DLayer!');const bounds=isFrame?getMinMax(this.props.frame):this.props.bounds,p=load_mesh_and_texture(this.props.mesh,bounds,this.props.meshMaxError,this.props.meshValueRange,this.props.smoothShading,this.props.propertyTexture);p.then((([mesh,meshImageData,texture])=>{this.setState({mesh:mesh,meshImageData:meshImageData,texture:texture})})),p.then((()=>{const xinc=this.props.frame?.increment?.[0]??0,yinc=this.props.frame?.increment?.[1]??0,xcount=this.props.frame?.count?.[0]??1,ycount=this.props.frame?.count?.[1]??1,xMin=this.props.frame?.origin?.[0]??bounds[0],yMin=this.props.frame?.origin?.[1]??bounds[1],zMin=-this.props.meshValueRange[1],xMax=isFrame?xMin+xinc*xcount:bounds[2],yMax=isFrame?yMin+yinc*ycount:bounds[3],zMax=-this.props.meshValueRange[0];void 0!==this.props.setReportedBoundingBox&&this.props.setReportedBoundingBox([xMin,yMin,zMin,xMax,yMax,zMax])}))}updateState({props:props,oldProps:oldProps}){!((0,lodash.isEqual)(props.mesh,oldProps.mesh)&&(0,lodash.isEqual)(props.bounds,oldProps.bounds)&&(0,lodash.isEqual)(props.frame,oldProps.frame)&&(0,lodash.isEqual)(props.meshMaxError,oldProps.meshMaxError)&&(0,lodash.isEqual)(props.meshValueRange,oldProps.meshValueRange)&&(0,lodash.isEqual)(props.smoothShading,oldProps.smoothShading)&&(0,lodash.isEqual)(props.propertyTexture,oldProps.propertyTexture))&&this.initializeState()}renderLayers(){const bounds=void 0!==this.props.bounds?this.props.bounds:getMinMax(this.props.frame),isRotDegDefined=void 0!==this.props.rotDeg,isRotPointDefined=void 0!==this.props.rotPoint;isRotDegDefined&&console.warn('"rotDeg" is deprecated. Use "frame.rotDeg" instead.'),isRotPointDefined&&console.warn('"rotPoint" is deprecated. Use "frame.rotPoint" instead.');const[minX,minY]=[bounds[0],bounds[1]],center=this.props.frame?.rotPoint??(isRotPointDefined?this.props.rotPoint:[minX,minY]),rotatingModelMatrix=(0,layerTools.RT)(this.props.frame?.rotDeg??(isRotDegDefined?this.props.rotDeg:0),center[0],center[1]);void 0!==this.props.modelMatrix&&null!==this.props.modelMatrix&&rotatingModelMatrix.multiplyRight(this.props.modelMatrix);const isMesh=void 0!==this.props.mesh&&""!==this.props.mesh;return[new TerrainMapLayer(this.getSubLayerProps({mesh:this.state.mesh,texture:this.state.texture,textureImageData:this.state.texture,meshImageData:this.state.meshImageData,meshValueRange:this.props.meshValueRange,pickable:this.props.pickable,modelMatrix:rotatingModelMatrix,contours:this.props.contours,colorMapName:this.props.colorMapName,colorMapFunction:this.props.colorMapFunction,propertyValueRange:this.props.propertyValueRange,colorMapRange:this.props.colorMapRange,colorMapClampColor:this.props.colorMapClampColor,isContoursDepth:!!isMesh&&this.props.isContoursDepth,material:this.props.material,wireframe:!1,depthTest:this.props.depthTest}))]}getLegendData(){const colorRange=this.props.colorMapRange,propertyRange=this.props.propertyTexture&&this.props.propertyValueRange,meshRange=this.props.mesh&&this.props.meshValueRange;return{discrete:!1,valueRange:colorRange||propertyRange||meshRange,colorName:this.props.colorMapName,title:"Map3dLayer",colorMapFunction:this.props.colorMapFunction}}}Map3DLayer.layerName="Map3DLayer",Map3DLayer.defaultProps={"@@type":"Map3DLayer",name:"Map 3D",id:"map3d-layer",pickable:!0,visible:!0,mesh:"",meshValueRange:{type:"array",value:[0,1]},meshMaxError:{type:"number",value:5},propertyTexture:"",propertyValueRange:{type:"array",value:[0,1]},contours:[-1,-1],isContoursDepth:!0,smoothShading:!0,material:!0,depthTest:!0};var dist_es6=__webpack_require__("./node_modules/@nebula.gl/edit-modes/dist-es6/index.js"),layers_dist_es6=__webpack_require__("./node_modules/@nebula.gl/layers/dist-es6/index.js"),es=__webpack_require__("./node_modules/@turf/meta/dist/es/index.js");function measurement_length(geojson){return(0,es.hE)(geojson,(function(previousValue,segment){if(void 0===segment||void 0===previousValue)return 0;const coords=segment.geometry.coordinates;return previousValue+function distance(from,to){const[x1,y1,z1]=from,[x2,y2,z2]=to;let a=Math.pow(x1-x2,2)+Math.pow(y1-y2,2);z1&&z2&&(a+=Math.pow(z2-z1,2));return Math.sqrt(a)}(coords[0],coords[1])}),0)}function measurement_area(geojson){return(0,es.mm)(geojson,(function(value,geom){return value+function calculateArea(geom){const coords=geom.coordinates[0];let total=0;for(let i=0,l=coords.length;i<l;i++){total+=coords[i][0]*coords[i==coords.length-1?0:i+1][1]*.5,total-=coords[i==coords.length-1?0:i+1][0]*coords[i][1]*.5}return Math.abs(total)}(geom)}),0)}class CustomModifyMode extends dist_es6.ModifyMode{handleKeyUp(event,props){if(super.handleKeyUp(event,props),"Delete"===event.key){const updatedData=new dist_es6.ImmutableFeatureCollection(props.data).deleteFeatures(props.selectedIndexes).getObject();updatedData&&props.onEdit({updatedData:updatedData,editType:"removeFeature",editContext:{featureIndexes:props.selectedIndexes}})}}}function deleteEscapeKeyHandler(drawMode,event,props){if("Escape"===event.key)drawMode.getClickSequence().pop();else{if("Delete"!==event.key)return;drawMode.resetClickSequence()}const updatedData=new dist_es6.ImmutableFeatureCollection(props.data).getObject();updatedData&&props.onEdit({updatedData:updatedData,editType:"undoDrawing",editContext:{featureIndexes:props.selectedIndexes}})}class CustomDrawLineStringMode extends dist_es6.DrawLineStringMode{handleKeyUp(event,props){super.handleKeyUp(event,props),deleteEscapeKeyHandler(this,event,props)}}class CustomDrawPolygonMode extends dist_es6.DrawPolygonMode{handleKeyUp(event,props){super.handleKeyUp(event,props),deleteEscapeKeyHandler(this,event,props)}}const MODE_MAP={view:dist_es6.ViewMode,modify:CustomModifyMode,transform:dist_es6.TransformMode,drawPoint:dist_es6.DrawPointMode,drawLineString:CustomDrawLineStringMode,drawPolygon:CustomDrawPolygonMode},UNSELECTED_LINE_COLOR=[80,80,80,204],SELECTED_LINE_COLOR=[0,0,0,255];class DrawingLayer extends composite_layer.Z{initializeState(context){super.initializeState(context),this.setState({data:this.props.data,selectedFeatureIndexes:this.props.selectedFeatureIndexes})}onClick(info){return("view"===this.props.mode||"modify"===this.props.mode)&&(this.setState({selectedFeatureIndexes:[info.index]}),this.context.userData.setEditedData({selectedFeatureIndexes:[info.index]}),!0)}getPickingInfo({info:info}){if(!info.object)return info;const feature=info.object;let measurement;if("LineString"===feature.geometry.type)measurement=measurement_length(feature);else{if("Polygon"!==feature.geometry.type)return info;measurement=measurement_area(feature)}return{...info,propertyValue:measurement}}_onEdit(editAction){switch(editAction.editType){case"addFeature":this.setState({data:editAction.updatedData,selectedFeatureIndexes:editAction.editContext.featureIndexes}),this.context.userData.setEditedData({data:editAction.updatedData,selectedFeatureIndexes:editAction.editContext.featureIndexes});break;case"removeFeature":this.setState({data:editAction.updatedData,selectedFeatureIndexes:[]}),this.context.userData.setEditedData({data:editAction.updatedData,selectedFeatureIndexes:[]});break;case"removePosition":case"finishMovePosition":this.setState({data:editAction.updatedData}),this.context.userData.setEditedData({data:editAction.updatedData});break;case"movePosition":case"undoDrawing":this.setState({data:editAction.updatedData})}}_getLineColor(feature){return this.state.selectedFeatureIndexes.some((i=>this.state.data.features[i]===feature))?SELECTED_LINE_COLOR:UNSELECTED_LINE_COLOR}renderLayers(){if(0==this.props.visible)return[];const sub_layer_props=this.getSubLayerProps({data:this.state.data,mode:MODE_MAP[this.props.mode],modeConfig:{viewport:this.context.viewport},selectedFeatureIndexes:this.state.selectedFeatureIndexes,coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,onEdit:editAction=>this._onEdit(editAction),_subLayerProps:{geojson:{autoHighlight:!0,getLineColor:feature=>this._getLineColor(feature)}}});return[new layers_dist_es6.nk(sub_layer_props)]}}DrawingLayer.layerName="DrawingLayer",DrawingLayer.defaultProps={"@@type":"DrawingLayer",name:"Drawing",id:"drawing-layer",pickable:!0,visible:!0,mode:"drawLineString",selectedFeatureIndexes:[],data:{type:"FeatureCollection",features:[]}};try{drawingLayer.displayName="drawingLayer",drawingLayer.__docgenInfo={description:"",displayName:"drawingLayer",props:{mode:{defaultValue:null,description:"",name:"mode",required:!0,type:{name:"string"}},selectedFeatureIndexes:{defaultValue:null,description:"",name:"selectedFeatureIndexes",required:!0,type:{name:"number[]"}},"@@type":{defaultValue:null,description:"",name:"@@type",required:!1,type:{name:"string"}},name:{defaultValue:null,description:"",name:"name",required:!0,type:{name:"string"}},id:{defaultValue:null,description:"Unique identifier of the layer.",name:"id",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"The data to visualize.",name:"data",required:!1,type:{name:"unknown"}},dataComparator:{defaultValue:null,description:"Callback to determine if two data values are equal.",name:"dataComparator",required:!1,type:{name:"(<LayerDataT = LayerData<unknown>>(newData: LayerDataT, oldData?: LayerDataT) => boolean) | null"}},_dataDiff:{defaultValue:null,description:"Callback to determine the difference between two data values, in order to perform a partial update.",name:"_dataDiff",required:!1,type:{name:"(<LayerDataT = LayerData<unknown>>(newData: LayerDataT, oldData?: LayerDataT) => { startRow: number; endRow?: number; }[]) | null"}},dataTransform:{defaultValue:null,description:"Callback to manipulate remote data when it's fetched and parsed.",name:"dataTransform",required:!1,type:{name:"(<LayerDataT = LayerData<unknown>>(data: unknown, previousData?: LayerDataT) => LayerDataT) | null"}},fetch:{defaultValue:null,description:"Custom implementation to fetch and parse content from URLs.",name:"fetch",required:!1,type:{name:"(url: string, context: { propName: string; layer: Layer<{}>; loaders?: Loader[]; loadOptions?: any; signal?: AbortSignal; }) => any"}},updateTriggers:{defaultValue:null,description:"The dependencies used to trigger re-evaluation of functional accessors (get*).",name:"updateTriggers",required:!1,type:{name:"Record<string, any>"}},operation:{defaultValue:null,description:"Rendering operation of the layer. `+` separated list of names.",name:"operation",required:!1,type:{name:"enum",value:[{value:'"draw"'},{value:'"mask"'},{value:'"terrain"'},{value:'"draw+draw"'},{value:'"draw+mask"'},{value:'"draw+terrain"'},{value:'"mask+draw"'},{value:'"mask+mask"'},{value:'"mask+terrain"'},{value:'"terrain+draw"'},{value:'"terrain+mask"'},{value:'"terrain+terrain"'}]}},visible:{defaultValue:null,description:"If the layer should be rendered. Default true.",name:"visible",required:!1,type:{name:"boolean"}},pickable:{defaultValue:null,description:"If the layer can be picked on pointer events. Default false.",name:"pickable",required:!1,type:{name:"boolean"}},opacity:{defaultValue:null,description:"Opacity of the layer, between 0 and 1. Default 1.",name:"opacity",required:!1,type:{name:"number"}},coordinateSystem:{defaultValue:null,description:"The coordinate system of the data. Default to COORDINATE_SYSTEM.LNGLAT in a geospatial view or COORDINATE_SYSTEM.CARTESIAN in a non-geospatial view.",name:"coordinateSystem",required:!1,type:{name:"enum",value:[{value:"0"},{value:"1"},{value:"2"},{value:"-1"},{value:"3"}]}},coordinateOrigin:{defaultValue:null,description:"The coordinate origin of the data.",name:"coordinateOrigin",required:!1,type:{name:"[number, number, number]"}},modelMatrix:{defaultValue:null,description:"A 4x4 matrix to transform local coordianates to the world space.",name:"modelMatrix",required:!1,type:{name:"number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | ... 20 more ... | null"}},wrapLongitude:{defaultValue:null,description:"(Geospatial only) normalize geometries that cross the 180th meridian. Default false.",name:"wrapLongitude",required:!1,type:{name:"boolean"}},positionFormat:{defaultValue:null,description:"The format of positions, default 'XYZ'.",name:"positionFormat",required:!1,type:{name:"enum",value:[{value:'"XYZ"'},{value:'"XY"'}]}},colorFormat:{defaultValue:null,description:"The format of colors, default 'RGBA'.",name:"colorFormat",required:!1,type:{name:"enum",value:[{value:'"RGBA"'},{value:'"RGB"'}]}},parameters:{defaultValue:null,description:"Override the WebGL parameters used to draw this layer. See https://luma.gl/modules/gltools/docs/api-reference/parameter-setting#parameters",name:"parameters",required:!1,type:{name:"any"}},transitions:{defaultValue:null,description:"Create smooth transitions when prop values update.",name:"transitions",required:!1,type:{name:"Record<string, any> | null"}},extensions:{defaultValue:null,description:"Add additional functionalities to this layer.",name:"extensions",required:!1,type:{name:"LayerExtension<unknown>[]"}},loaders:{defaultValue:null,description:"Add support for additional data formats.",name:"loaders",required:!1,type:{name:"Loader[]"}},loadOptions:{defaultValue:null,description:"Options to customize the behavior of loaders",name:"loadOptions",required:!1,type:{name:"any"}},getPolygonOffset:{defaultValue:null,description:"Callback to calculate the polygonOffset WebGL parameter.",name:"getPolygonOffset",required:!1,type:{name:"((params: { layerIndex: number; }) => [number, number]) | null"}},autoHighlight:{defaultValue:null,description:"Enable GPU-based object highlighting. Default false.",name:"autoHighlight",required:!1,type:{name:"boolean"}},highlightedObjectIndex:{defaultValue:null,description:"The index of the data object to highlight. If unspecified, the currently hoverred object is highlighted.",name:"highlightedObjectIndex",required:!1,type:{name:"number | null"}},highlightColor:{defaultValue:null,description:"The color of the highlight.",name:"highlightColor",required:!1,type:{name:"(number[] | ((pickingInfo: PickingInfo) => number[])) & (number[] | ((pickingInfo: PickingInfo) => number[]))"}},onDataLoad:{defaultValue:null,description:"Called when remote data is fetched and parsed.",name:"onDataLoad",required:!1,type:{name:"(<LayerDataT = LayerData<unknown>>(data: LayerDataT, context: { propName: string; layer: Layer<{}>; }) => void) | null"}},onError:{defaultValue:null,description:"Called when the layer encounters an error.",name:"onError",required:!1,type:{name:"((error: Error) => boolean | void) | null"}},onHover:{defaultValue:null,description:"Called when the mouse enters/leaves an object of this layer.",name:"onHover",required:!1,type:{name:"((pickingInfo: PickingInfo, event: MjolnirEvent) => boolean | void) | null"}},onClick:{defaultValue:null,description:"Called when the mouse clicks over an object of this layer.",name:"onClick",required:!1,type:{name:"((pickingInfo: PickingInfo, event: MjolnirEvent) => boolean | void) | null"}},onDragStart:{defaultValue:null,description:"Called when the mouse starts dragging an object of this layer.",name:"onDragStart",required:!1,type:{name:"((pickingInfo: PickingInfo, event: MjolnirEvent) => boolean | void) | null"}},onDrag:{defaultValue:null,description:"Called when the mouse drags an object of this layer.",name:"onDrag",required:!1,type:{name:"((pickingInfo: PickingInfo, event: MjolnirEvent) => boolean | void) | null"}},onDragEnd:{defaultValue:null,description:"Called when the mouse releases an object of this layer.",name:"onDragEnd",required:!1,type:{name:"((pickingInfo: PickingInfo, event: MjolnirEvent) => boolean | void) | null"}},numInstances:{defaultValue:null,description:"(Advanced) supply attribute size externally",name:"numInstances",required:!1,type:{name:"number | null"}},startIndices:{defaultValue:null,description:"(Advanced) supply variable-width attribute size externally",name:"startIndices",required:!1,type:{name:"number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | ... 20 more ... | null"}},_subLayerProps:{defaultValue:null,description:"(Experimental) override sub layer props. Only works on a composite layer.",name:"_subLayerProps",required:!1,type:{name:"{ [subLayerId: string]: { [propName: string]: any; type?: ConstructorOf<Layer<{}>>; }; } | null"}},"__@COMPONENT_SYMBOL@1263":{defaultValue:null,description:"",name:"__@COMPONENT_SYMBOL@1263",required:!0,type:{name:"Component<DrawingLayerProps & Required<CompositeLayerProps> & Required<LayerProps>>"}},"__@PROP_TYPES_SYMBOL@1266":{defaultValue:null,description:"",name:"__@PROP_TYPES_SYMBOL@1266",required:!0,type:{name:"Record<string, PropType>"}},"__@ASYNC_DEFAULTS_SYMBOL@1269":{defaultValue:null,description:"",name:"__@ASYNC_DEFAULTS_SYMBOL@1269",required:!0,type:{name:"Partial<DrawingLayerProps & Required<CompositeLayerProps> & Required<LayerProps>>"}},"__@ASYNC_ORIGINAL_SYMBOL@1272":{defaultValue:null,description:"",name:"__@ASYNC_ORIGINAL_SYMBOL@1272",required:!0,type:{name:"Partial<DrawingLayerProps & Required<CompositeLayerProps> & Required<LayerProps>>"}},"__@ASYNC_RESOLVED_SYMBOL@1275":{defaultValue:null,description:"",name:"__@ASYNC_RESOLVED_SYMBOL@1275",required:!0,type:{name:"Partial<DrawingLayerProps & Required<CompositeLayerProps> & Required<LayerProps>>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["packages/subsurface-viewer/src/layers/drawing/drawingLayer.tsx#drawingLayer"]={docgenInfo:drawingLayer.__docgenInfo,name:"drawingLayer",path:"packages/subsurface-viewer/src/layers/drawing/drawingLayer.tsx#drawingLayer"})}catch(__react_docgen_typescript_loader_error){}const hillshading2dLayer_defaultProps={"@@type":"Hillshading2DLayer",name:"Hill shading",id:"hillshading-layer",opacity:1,pickable:!0,visible:!0,rotDeg:0,valueRange:{type:"array",value:[0,1]},lightDirection:[1,1,1],ambientLightIntensity:.5,diffuseLightIntensity:.5,valueDecoder:{rgbScaler:[1,1,1],floatScaler:1/16777215,offset:0,step:0}};class Hillshading2DLayer extends bitmap_layer.Z{initializeState(){this.setState({isLoaded:!1}),super.initializeState()}draw({moduleParameters:moduleParameters,uniforms:uniforms}){if(!this.state.isLoaded&&(this.setState({isLoaded:!0}),void 0!==this.props.setReportedBoundingBox)){const bbox=[this.props.bounds[0],this.props.bounds[1],1,this.props.bounds[2],this.props.bounds[3],-1];this.props.setReportedBoundingBox(bbox)}if(this.props.image){const mergedModuleParams={...moduleParameters,valueDecoder:{...hillshading2dLayer_defaultProps.valueDecoder,...moduleParameters.valueDecoder},modelMatrix:(0,layerTools.RT)(this.props.rotDeg,this.props.bounds[0],this.props.bounds[3])};super.setModuleParameters(mergedModuleParams);const valueRangeMin=this.props.valueRange[0]??0,valueRangeMax=this.props.valueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,[minVal,maxVal]=this.props.valueRange;super.draw({uniforms:{...uniforms,bitmapResolution:[this.props.image.width,this.props.image.height],valueRangeSize:maxVal-minVal,lightDirection:this.props.lightDirection,ambientLightIntensity:this.props.ambientLightIntensity,diffuseLightIntensity:this.props.diffuseLightIntensity,valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax},moduleParameters:mergedModuleParams})}}getShaders(){const parentShaders=super.getShaders();return parentShaders.fs="#define SHADER_NAME hillshading2d-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D bitmapTexture; // Property map\nuniform vec2 bitmapResolution;\n\nuniform float valueRangeSize;\n\nuniform vec3 lightDirection;\nuniform float ambientLightIntensity;\nuniform float diffuseLightIntensity;\nuniform float opacity;\n\n// Compute the normal value for every pixel, based on the current value and two values aroud it.\nvec3 normal(float val) {\n  vec2 dr = 1.0 / bitmapResolution;\n  float p0 = valueRangeSize * val;\n  float px = valueRangeSize * decode_rgb2float(texture2D(bitmapTexture, vTexCoord + vec2(1.0, 0.0) / bitmapResolution).rgb);\n  float py = valueRangeSize * decode_rgb2float(texture2D(bitmapTexture, vTexCoord + vec2(0.0, 1.0) / bitmapResolution).rgb);\n  vec3 dx = vec3(1.0, 0.0, px - p0);\n  vec3 dy = vec3(0.0, 1.0, py - p0);\n\n  return normalize(cross(dx, dy));\n}\n\n// Compute how much a pixel is in the shadow based on its normal and where the light comes from.\nfloat shadow(vec3 normal) {\n  float diffuse = diffuseLightIntensity * dot(normal, normalize(lightDirection));\n  return clamp(ambientLightIntensity + diffuse, 0.0, 1.0);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  // If it's a picking pass, we just return the raw property map value.\n  if (picking_uActive) {\n    gl_FragColor = bitmapColor;\n    return;\n  }\n\n  // Decode the RGB value into a float. See decoder.fs.glsl for more details.\n  float val = decode_rgb2float(bitmapColor.rgb);\n  // Compute the shadow value, how dark a pixel will be, 1 is in complete shadow, 0 is in complete light.\n  float shadow = shadow(normal(val));\n\n  // The final pixel is black, with the opacity based on the shadow value,\n  // opacity 0 if pixel is completely in the light, opacity 1 if pixel is completely in the shadow.\n  // The property map opacity (some portions of the property map can be transparent) and\n  // the user provided image-wide opacity value are also taken into account.\n  gl_FragColor = vec4(vec3(0.0), (1.0-shadow) * bitmapColor.a * opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",parentShaders.modules.push(decoder),parentShaders}getPickingInfo({info:info}){if(this.state.pickingDisabled||!info.color)return info;const mergedDecoder={...hillshading2dLayer_defaultProps.valueDecoder,...this.props.valueDecoder},val=decodeRGB(info.color,mergedDecoder,this.props.valueRange);return{...info,index:0,propertyValue:val}}}Hillshading2DLayer.layerName="Hillshading2DLayer",Hillshading2DLayer.defaultProps=hillshading2dLayer_defaultProps;var wellsLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts"),vector2=__webpack_require__("./node_modules/@math.gl/core/dist/esm/classes/vector2.js");class PieChartLayer extends lib_layer.Z{initializeState(){}shouldUpdateState(){return!0}updateState({context:context}){if(!this.state?.model){const pieData=this.props.data;if(pieData?.pies){const{gl:gl}=context;this.setState(this.getModel(gl,pieData))}}}getModel(gl,pieData){const vertexs=[],colors=[],mx=[],my=[],doScale=[],pieInfo=[],pieInfoIndex=[];let infoIndex=0;for(const pie of pieData.pies){const x=pie.x,y=pie.y,R=pie.R;let sum=0;for(const frac of pie.fractions)sum+=frac.value;if(0===sum)continue;let start_a=-90;for(let i=0;i<pie.fractions.length;i++){const frac=pie.fractions[i].value/sum,end_a=start_a+360*frac,prop=pieData.properties[pie.fractions[i].idx];let col=prop?.color??[255,0,255,255];col=col.map((x=>(x??0)/255));const name=prop?.label??"no label",frac_string=(100*frac).toFixed(1)+"%";pieInfo.push([name,frac_string]);for(let a=start_a;a<end_a;a+=5){const a1=a,rad1=a1*(2*Math.PI)/360,xx1=R*Math.cos(rad1)+x,yy1=R*Math.sin(rad1)+y,rad2=Math.min(a1+5,end_a)*(2*Math.PI)/360,xx2=R*Math.cos(rad2)+x,yy2=R*Math.sin(rad2)+y;vertexs.push(x,y,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(0),vertexs.push(xx1,yy1,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(1),vertexs.push(xx2,yy2,0),mx.push(x),my.push(y),colors.push(...col),pieInfoIndex.push(infoIndex),doScale.push(1)}infoIndex++,start_a=end_a}}return{model:new lib_model.Z(gl,{id:`${this.props.id}-pie`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin vec3 positions;\nin vec3 colors;\nin float do_scale;\nin float mx;\nin float my;\nin int pie_index;\n\nflat out int pie_index_;\n\nuniform float scale;\n\nout vec4 vColor;\n\nvoid main(void) {\n\n   vec3 v = positions;\n\n   if (do_scale == 1.0) {\n      // Triangle vertex' are (mx,my) and two more. The\n      // latter two will be scaled so that the triangle (or the pie piece its part of) will\n      // have constant size depending on zoom.\n      float x = scale * (positions.x - mx);\n      float y = scale * (positions.y - my);\n\n      v = vec3(x + mx, y + my, 0.0);\n   }\n\n   vec3 position_commonspace = project_position(v);\n\n   vColor = vec4(colors.rgb, 1.0);\n\n   pie_index_ = pie_index;\n\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nflat in int pie_index_;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n\nvoid main(void) {\n\n  //Picking pass.\n  if (picking_uActive) {\n     // Express triangle index in 255 system.\n     float r = 0.0;\n     float g = 0.0;\n     float b = 0.0;\n \n     int idx = pie_index_;\n \n     if (idx >= (256 * 256) - 1) {\n        r = floor(float(idx) / (256.0 * 256.0));\n        idx -= int(r * (256.0 * 256.0));\n     }\n \n     if (idx >= 256 - 1) {\n        g = floor(float(idx) / 256.0);\n        idx -= int(g * 256.0);\n     }\n \n     b = float(idx);\n \n     fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n     return;\n  }\n\n  fragColor = vColor;\n}\n",geometry:new geometry.Z({drawMode:esm.default.TRIANGLES,attributes:{positions:{value:new Float32Array(vertexs),size:3},colors:{value:new Float32Array(colors),size:3},pie_index:{value:new Int32Array(pieInfoIndex),size:1},mx:{value:new Float32Array(mx),size:1},my:{value:new Float32Array(my),size:1},do_scale:{value:new Float32Array(doScale),size:1}},vertexCount:vertexs.length/3}),modules:[project.Z,picking.Z],isInstanced:!1}),pieInfo:pieInfo}}draw(args){if(!this.state?.model)return;const{context:context}=args,{gl:gl}=context,p2=[100,0],p1_unproj=this.context.viewport.unproject([0,0]),p2_unproj=this.context.viewport.unproject(p2),v1=new vector2.Z(p1_unproj[0],p1_unproj[1]),v2=new vector2.Z(p2_unproj[0],p2_unproj[1]),scale=v1.distance(v2)/100,model=this.state.model;this.props.depthTest||gl.disable(esm.default.DEPTH_TEST),model.setUniforms({scale:scale}).draw(),this.props.depthTest||gl.enable(esm.default.DEPTH_TEST)}decodePickingColor(){return this.nullPickingColor()}getPickingInfo({info:info}){if(!info.color)return info;const pieIndex=65536*info.color[0]+256*info.color[1]+info.color[2],[pie_label,pie_frac]=this.state.pieInfo[pieIndex],layer_properties=[];return layer_properties.push((0,layerTools.ws)(pie_label,pie_frac)),{...info,properties:layer_properties}}}PieChartLayer.layerName="PieChartLayer",PieChartLayer.defaultProps={"@@type":"PieChartLayer",name:"Pie chart",id:"pie-layer",pickable:!0,visible:!0,selectedPie:"@@editedData.selectedPie",depthTest:!0};var geojson_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js");const getColor=d=>{const c=d?.properties?.color;return[c[0]??0,c[1]??0,c[2]??0,30]};class FaultPolygonsLayer extends composite_layer.Z{renderLayers(){return[new geojson_layer.Z(this.getSubLayerProps({id:this.props.id,data:this.props.data,pickable:this.props.pickable,visible:this.props.visible,filled:this.props.filled,lineWidthMinPixels:this.props.lineWidthMinPixels,coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,getLineColor:d=>d?.properties?.color??[0,0,0,255],getFillColor:getColor,parameters:{[esm.default.DEPTH_TEST]:this.props.depthTest}}))]}}FaultPolygonsLayer.layerName="FaultPolygonsLayer",FaultPolygonsLayer.defaultProps={"@@type":"FaultPolygonsLayer",name:"Fault polygons",id:"fault-polygons-layer",pickable:!0,visible:!0,filled:!0,lineWidthMinPixels:2,depthTest:!0};var axesLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/axes/axesLayer.ts"),axes2DLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/axes2d/axes2DLayer.ts");class SelectableGeoJsonLayer extends geojson_layer.Z{onClick(info){return!(0,layerTools.A3)(this.context.layerManager)&&(this.context.userData.setEditedData({selectedGeoJsonFeature:info.object}),!0)}}SelectableGeoJsonLayer.layerName="SelectableGeoJsonLayer",SelectableGeoJsonLayer.defaultProps={visible:!0,pickable:!0};var orthographic_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js");class NorthArrow3DLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context;this.setState(this._getModels(gl))}shouldUpdateState(){return!0}updateState({context:context}){context.gl&&this.setState(this._getModels(context.gl))}draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}){const{gl:gl}=context;gl.disable(gl.DEPTH_TEST),super.draw({moduleParameters:moduleParameters,uniforms:uniforms,context:context}),gl.enable(gl.DEPTH_TEST)}_getModels(gl){const model_lines=function GetArrowLines(){const lines=[];let z=.5;return lines.push([-1,-2,z]),lines.push([-1,2,z]),lines.push([-1,2,z]),lines.push([-1.5,2,z]),lines.push([-1.5,2,z]),lines.push([0,4,z]),lines.push([0,4,z]),lines.push([1.5,2,z]),lines.push([1.5,2,z]),lines.push([1,2,z]),lines.push([1,2,z]),lines.push([1,-2,z]),lines.push([1,-2,z]),lines.push([-1,-2,z]),z=-.5,lines.push([-1,-2,z]),lines.push([-1,2,z]),lines.push([-1,2,z]),lines.push([-1.5,2,z]),lines.push([-1.5,2,z]),lines.push([0,4,z]),lines.push([0,4,z]),lines.push([1.5,2,z]),lines.push([1.5,2,z]),lines.push([1,2,z]),lines.push([1,2,z]),lines.push([1,-2,z]),lines.push([1,-2,z]),lines.push([-1,-2,z]),lines.push([-1,-2,-.5]),lines.push([-1,-2,.5]),lines.push([-1,2,-.5]),lines.push([-1,2,.5]),lines.push([-1.5,2,-.5]),lines.push([-1.5,2,.5]),lines.push([0,4,-.5]),lines.push([0,4,.5]),lines.push([1.5,2,-.5]),lines.push([1.5,2,.5]),lines.push([1,2,-.5]),lines.push([1,2,.5]),lines.push([1,-2,-.5]),lines.push([1,-2,.5]),lines.flat()}(),is_orthographic=this.context.viewport.constructor===orthographic_viewport.Z,view_at=new vector3.Z(this.unproject([100,100,0]));let view_from=new vector3.Z(this.context.viewport.cameraPosition);if(is_orthographic){const cam_pos_z=new vector3.Z(this.context.viewport.cameraPosition)[2];view_from=new vector3.Z([view_at[0],view_at[1],cam_pos_z])}const dir=new vector3.Z([view_at[0]-view_from[0],view_at[1]-view_from[1],view_at[2]-view_from[2]]);dir.normalize(),dir.scale(9999);const pos=new vector3.Z([view_from[0]+dir[0],view_from[1]+dir[1],view_from[2]+dir[2]]),lines=[],zoom=this.context.viewport.zoom,zoom_scale=Math.pow(2,zoom),scale=is_orthographic?15/zoom_scale:99;for(let i=0;i<model_lines.length/3;i+=1){const x=model_lines[3*i+0]*scale+pos[0],y=model_lines[3*i+1]*scale+pos[1],z=model_lines[3*i+2]*scale+pos[2];lines.push(x,y,z)}const color=this.props.color.map((x=>(x??0)/255));color[3]=1;const grids=new lib_model.Z(gl,{id:`${this.props.id}-grids`,vs:"#version 300 es\n#define SHADER_NAME graph-layer-axis-vertex-shader\n\nprecision highp float;\n\nin  vec3 positions;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nuniform vec4 uColor;\n\nvoid main(void) {\n  fragColor = uColor;\n}\n",uniforms:{uColor:color},geometry:new geometry.Z({drawMode:esm.default.LINES,attributes:{positions:new Float32Array(lines)},vertexCount:lines.length/3}),modules:[project.Z],isInstanced:!1});return{model:grids,models:[grids].filter(Boolean),modelsByName:{grids:grids}}}}NorthArrow3DLayer.layerName="NorthArrow3DLayer",NorthArrow3DLayer.defaultProps={"@@type":"NorthArrow3DLayer",name:"NorthArrow3D",id:"north-arrow-layer",visible:!0,color:[0,0,0,1]};var unfoldedGeoJsonLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/intersection/unfoldedGeoJsonLayer.ts");const privateLayer_DEFAULT_TEXTURE_PARAMETERS={[esm.default.TEXTURE_MIN_FILTER]:esm.default.LINEAR_MIPMAP_LINEAR,[esm.default.TEXTURE_MAG_FILTER]:esm.default.LINEAR,[esm.default.TEXTURE_WRAP_S]:esm.default.CLAMP_TO_EDGE,[esm.default.TEXTURE_WRAP_T]:esm.default.CLAMP_TO_EDGE};function privateLayer_getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined="function"==typeof colorMapFunction,isColorMapNameDefined=!!colorMapName,data=new Uint8Array(768),defaultColorMap=legendCommonFunction.z$;let colorMap=colorMapFunction;isColorMapFunctionDefined||(colorMap=isColorMapNameDefined?value=>(0,dist.CA)(value,colorMapName,colorTables):defaultColorMap());for(let i=0;i<256;i++){const color=colorMap?colorMap(i/255):[0,0,0];color&&(data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2])}return data||[0,0,0]}const privateLayer_defaultProps={colorMapName:"",coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,propertyValueRange:[0,1],depthTest:!0};class privateLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context,[model_mesh,mesh_lines_model]=this._getModels(gl);this.setState({models:[model_mesh,mesh_lines_model]})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(gl){return[new lib_model.Z(gl,{id:`${this.props.id}-mesh`,vs:"#version 300 es\n#define SHADER_NAME vertex-shader\n\nprecision highp float;\n\n// Primitive attributes\nin vec3 positions;\nin float properties;\n//in vec3 normals;\nin vec3 colors;\n\nin int vertex_indexs;\nflat out int vertex_indexs_;\n\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\n// out vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nout vec3 worldPos;\nout float property;\n\n\nvoid main(void) {\n   cameraPosition = project_uCameraPosition;\n\n   worldPos = positions;\n\n   vertex_indexs_ = vertex_indexs;\n\n   vColor = vec4(colors.rgb, 1.0);\n\n   property = properties;\n\n   position_commonspace = vec4(project_position(positions), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n}\n",fs:'#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\n//in vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nflat in int vertex_indexs_;\n\nout vec4 fragColor;\n\nin vec3 worldPos;\nin float property;\n\nuniform sampler2D colormap;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform vec3 colorMapClampColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\n\n\n\nvoid main(void) {\n   geometry.uv = vTexCoord;\n\n   vec3 normal = vec3(0.0, 0.0, 1.0);\n   bool nomals_available = false;\n   if (!nomals_available) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n   // else {\n   //    normal = normals_commonspace;\n   // }\n\n   // // Discard transparent pixels. KEEP\n   // if (!picking_uActive && isnan(propertyValue)) {\n   //    discard;\n   //    return;\n   // }\n   \n   //Picking pass.\n   if (picking_uActive) {\n      // Express triangle index in 255 system.\n      float r = 0.0;\n      float g = 0.0;\n      float b = 0.0;\n  \n      int idx = vertex_indexs_;\n  \n      if (idx >= (256 * 256) - 1) {\n         r = floor(float(idx) / (256.0 * 256.0));\n         idx -= int(r * (256.0 * 256.0));\n      }\n  \n      if (idx >= 256 - 1) {\n         g = floor(float(idx) / 256.0);\n         idx -= int(g * 256.0);\n      }\n  \n      b = float(idx);\n  \n      fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n      return;\n   }\n\n   // Calculate color from propertyValue using colormap.\n   vec4 color = vec4(1.0, 1.0, 1.0,  1.0);;\n   float propertyValue = property;\n   float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n   if (x < 0.0 || x > 1.0) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n         return;\n      }\n      else {\n         // Use min/max color to clamp.\n         x = max(0.0, x);\n         x = min(1.0, x);\n\n         color = texture2D(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      color = texture2D(colormap, vec2(x, 0.5));\n   }\n\n   // Use normal lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',geometry:new geometry.Z({drawMode:this.props.mesh.drawMode,attributes:{positions:this.props.mesh.attributes.positions,properties:this.props.mesh.attributes.properties,vertex_indexs:this.props.mesh.attributes.vertex_indexs},vertexCount:this.props.mesh.vertexCount,indices:this.props.mesh.indices}),modules:[project.Z,picking.Z,phong_lighting.s],isInstanced:!1}),new lib_model.Z(gl,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n  // Picking pass.\n  if (picking_uActive) {\n    discard;\n    return;\n  }\n\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.Z(this.props.meshLines),modules:[project.Z,picking.Z],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{uniforms:uniforms,context:context}=args,{gl:gl}=context,[model_mesh,mesh_lines_model]=this.state.models,valueRangeMin=this.props.propertyValueRange?.[0]??0,valueRangeMax=this.props.propertyValueRange?.[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,isClampColor=void 0!==this.props.colorMapClampColor&&!0!==this.props.colorMapClampColor&&!1!==this.props.colorMapClampColor;let colorMapClampColor=isClampColor?this.props.colorMapClampColor:[0,0,0];colorMapClampColor=colorMapClampColor.map((x=>(x??0)/255));const isColorMapClampColorTransparent=!1===this.props.colorMapClampColor;gl.enable(gl.POLYGON_OFFSET_FILL),gl.polygonOffset(1,1),this.props.depthTest||gl.disable(gl.DEPTH_TEST),model_mesh.setUniforms({...uniforms,colormap:new texture_2d.Z(context.gl,{width:256,height:1,format:esm.default.RGB,data:privateLayer_getImageData(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction),parameters:privateLayer_DEFAULT_TEXTURE_PARAMETERS}),valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax,colorMapClampColor:colorMapClampColor,isColorMapClampColorTransparent:isColorMapClampColorTransparent,isClampColor:isClampColor}).draw(),gl.disable(gl.POLYGON_OFFSET_FILL),this.props.gridLines&&mesh_lines_model.draw(),this.props.depthTest||gl.enable(gl.DEPTH_TEST)}decodePickingColor(){return this.nullPickingColor()}encodePickingColor(){return this.nullPickingColor()}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],vertexIndex=65536*info.color[0]+256*info.color[1]+info.color[2],depth=-this.props.mesh.attributes.positions.value[3*vertexIndex+2];layer_properties.push((0,layerTools.ws)("Depth",depth));const property=this.props.mesh.attributes.properties.value[vertexIndex];return layer_properties.push((0,layerTools.ws)("Property",property)),{...info,properties:layer_properties}}}function webworker_makeFullMesh(e){class Node{constructor(i,x,y){this.i=i,this.x=x,this.y=y,this.prev=this,this.next=this,this.z=0,this.prevZ=this,this.nextZ=this,this.steiner=!1}}function earcut(data,dim){dim=dim||2;const outerLen=data.length,outerNode=function linkedList(data,start,end,dim,clockwise){let i,last=null;if(clockwise===function signedArea(data,start,end,dim){let sum=0;for(let i=start,j=end-dim;i<end;i+=dim)sum+=(data[j]-data[i])*(data[i+1]+data[j+1]),j=i;return sum}(data,start,end,dim)>0)for(i=start;i<end;i+=dim)last=insertNode(i,data[i],data[i+1],last);else for(i=end-dim;i>=start;i-=dim)last=insertNode(i,data[i],data[i+1],last);last&&equals(last,last.next)&&(removeNode(last),last=last.next);return last}(data,0,outerLen,dim,!0),triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let x,y,minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY,maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY,invSize=0;if(data.length>80*dim){minX=maxX=data[0],minY=maxY=data[1];for(let i=dim;i<outerLen;i+=dim)x=data[i],y=data[i+1],x<minX&&(minX=x),y<minY&&(minY=y),x>maxX&&(maxX=x),y>maxY&&(maxY=y);invSize=Math.max(maxX-minX,maxY-minY),invSize=0!==invSize?32767/invSize:0}return earcutLinked(outerNode,triangles,dim,minX,minY,invSize,0),triangles;function filterPoints(start,end){if(!start)return start;end||(end=start);let again,p=start;do{if(again=!1,p.steiner||!equals(p,p.next)&&0!==area(p.prev,p,p.next))p=p.next;else{if(removeNode(p),p=end=p.prev,p===p.next)break;again=!0}}while(again||p!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;!pass&&invSize&&function indexCurve(start,minX,minY,invSize){let p=start;do{0===p.z&&(p.z=zOrder(p.x,p.y,minX,minY,invSize)),p.prevZ=p.prev,p.nextZ=p.next,p=p.next}while(p!==start);p.prevZ&&(p.prevZ.nextZ=null);p.prevZ=null,function sortLinked(list){let i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{for(p=list,list=null,tail=null,numMerges=0;p;){for(numMerges++,q=p,pSize=0,i=0;i<inSize&&(pSize++,q=q.nextZ,q);i++);for(qSize=inSize;pSize>0||qSize>0&&q;)p&&0!==pSize&&(0===qSize||!q||p.z<=q.z)?(e=p,p=p?.nextZ,pSize--):(e=q,q=q?.nextZ,qSize--),tail?tail.nextZ=e:list=e,e?.prevZ&&(e.prevZ=tail),tail=e;p=q}tail&&(tail.nextZ=null),inSize*=2}while(numMerges>1);return list}(p)}(ear,minX,minY,invSize);let prev,next,stop=ear;for(;ear.prev!==ear.next;)if(prev=ear.prev,next=ear.next,invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear))triangles.push(prev.i/dim|0),triangles.push(ear.i/dim|0),triangles.push(next.i/dim|0),removeNode(ear),ear=next.next,stop=next.next;else if((ear=next)===stop){pass?1===pass?earcutLinked(ear=cureLocalIntersections(filterPoints(ear),triangles,dim),triangles,dim,minX,minY,invSize,2):2===pass&&splitEarcut(ear,triangles,dim,minX,minY,invSize):earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);break}}function getMin(a,b,c){return a<b?a<c?a:c:b<c?b:c}function getMax(a,b,c){return a>b?a>c?a:c:b>c?b:c}function triangleBBox(ax,bx,cx,ay,by,cy){return[getMin(ax,bx,cx),getMin(ay,by,cy),getMax(ax,bx,cx),getMax(ay,by,cy)]}function isEar(ear){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,[x0,y0,x1,y1]=triangleBBox(ax,bx,cx,ay,by,cy);let p=c.next;for(;p!==a;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function isEarHashed(ear,minX,minY,invSize){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,[x0,y0,x1,y1]=triangleBBox(ax,bx,cx,ay,by,cy),minZ=zOrder(x0,y0,minX,minY,invSize),maxZ=zOrder(x1,y1,minX,minY,invSize);let p=ear.prevZ,n=ear.nextZ;for(;p&&p.z>=minZ&&n&&n.z<=maxZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}for(;p&&p.z>=minZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;n&&n.z<=maxZ;){if(n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}return!0}function cureLocalIntersections(start,triangles,dim){let p=start;do{const a=p.prev,b=p.next.next;!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)&&(triangles.push(a.i/dim|0),triangles.push(p.i/dim|0),triangles.push(b.i/dim|0),removeNode(p),removeNode(p.next),p=start=b),p=p.next}while(p!==start);return filterPoints(p)}function splitEarcut(start,triangles,dim,minX,minY,invSize){let a=start;do{let b=a.next.next;for(;b!==a.prev;){if(a.i!==b.i&&isValidDiagonal(a,b)){let c=splitPolygon(a,b);return a=filterPoints(a,a.next),c=filterPoints(c,c.next),earcutLinked(a,triangles,dim,minX,minY,invSize,0),void earcutLinked(c,triangles,dim,minX,minY,invSize,0)}b=b.next}a=a.next}while(a!==start)}function zOrder(x,y,minX,minY,invSize){return(x=1431655765&((x=858993459&((x=252645135&((x=16711935&((x=(x-minX)*invSize|0)|x<<8))|x<<4))|x<<2))|x<<1))|(y=1431655765&((y=858993459&((y=252645135&((y=16711935&((y=(y-minY)*invSize|0)|y<<8))|y<<4))|y<<2))|y<<1))<<1}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)>=(ax-px)*(cy-py)&&(ax-px)*(by-py)>=(bx-px)*(ay-py)&&(bx-px)*(cy-py)>=(cx-px)*(by-py)}function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!function intersectsPolygon(a,b){let p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return!0;p=p.next}while(p!==a);return!1}(a,b)&&(locallyInside(a,b)&&locallyInside(b,a)&&function middleInside(a,b){const px=(a.x+b.x)/2,py=(a.y+b.y)/2;let p=a,inside=!1;do{p.y>py!=p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x&&(inside=!inside),p=p.next}while(p!==a);return inside}(a,b)&&(area(a.prev,a,b.prev)||area(a,b.prev,b))||equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0)}function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){const o1=sign(area(p1,q1,p2)),o2=sign(area(p1,q1,q2)),o3=sign(area(p2,q2,p1)),o4=sign(area(p2,q2,q1));return o1!==o2&&o3!==o4||(!(0!==o1||!onSegment(p1,p2,q1))||(!(0!==o2||!onSegment(p1,q2,q1))||(!(0!==o3||!onSegment(p2,p1,q2))||!(0!==o4||!onSegment(p2,q1,q2)))))}function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y)}function sign(num){return num>0?1:num<0?-1:0}function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0}function splitPolygon(a,b){const a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;return a.next=b,b.prev=a,a2.next=an,an.prev=a2,b2.next=a2,a2.prev=b2,bp.next=b2,b2.prev=bp,b2}function insertNode(i,x,y,last){const p=new Node(i,x,y);return last?(p.next=last.next,p.prev=last,last.next.prev=p,last.next=p):(p.prev=p,p.next=p),p}function removeNode(p){p.next.prev=p.prev,p.prev.next=p.next,p.prevZ&&(p.prevZ.nextZ=p.nextZ),p.nextZ&&(p.nextZ.prevZ=p.prevZ)}}const get3DPoint=(points,index)=>points.slice(3*index,3*(index+1)),substractPoints=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],crossProduct=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]],dotProduct=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],normalize=a=>{const len=Math.sqrt(dotProduct(a,a));return[a[0]/len,a[1]/len,a[2]/len]},projectPoint=(u,v,p)=>[dotProduct(p,u),dotProduct(p,v)],projectPolygon=points=>{const p0=get3DPoint(points,0),p1=get3DPoint(points,1),p2=get3DPoint(points,2),v1=substractPoints(p1,p0),v2=substractPoints(p2,p0),normal=normalize(crossProduct(v1,v2)),u=normalize(v1),v=normalize(crossProduct(normal,u)),res=[],count=points.length/3;for(let i=0;i<count;++i){const p=get3DPoint(points,i),fp=projectPoint(u,v,p);res.push(...fp)}return res},getLineSegment=(index0,index1,out)=>{const i1=polys[index0],i2=polys[index1],p1=get3DPoint(params.points,i1),p2=get3DPoint(params.points,i2);p1[2]*=z_sign,p2[2]*=z_sign,out.push(...p1),out.push(...p2)},t0=performance.now(),params=e.data,polys=params.polys,properties=params.properties,positions=[],indices=[],vertexProperties=[],line_positions=[];let propertyValueRangeMin=99999999,propertyValueRangeMax=-99999999;const z_sign=params.isZIncreasingDownwards?-1:1;let pn=0,i=0,vertexIndex=0;for(;i<polys.length;){const n=polys[i],propertyValue=properties[pn++];null!==propertyValue&&(propertyValueRangeMin=propertyValue<propertyValueRangeMin?propertyValue:propertyValueRangeMin,propertyValueRangeMax=propertyValue>propertyValueRangeMax?propertyValue:propertyValueRangeMax);for(let j=i+1;j<i+n;++j)getLineSegment(j,j+1,line_positions);getLineSegment(i+1,i+n,line_positions);const polygon=[],vertexIndices=[];for(let p=1;p<=n;++p){const i0=polys[i+p],point=get3DPoint(params.points,i0);point[2]*=z_sign,vertexIndices.push(i0),polygon.push(...point)}const triangles=earcut(projectPolygon(polygon),2);for(const t of triangles)positions.push(...get3DPoint(polygon,t)),vertexProperties.push(propertyValue),indices.push(vertexIndex++);i=i+n+1}console.log("Number of polygons: ",pn);const mesh={drawMode:4,attributes:{positions:{value:new Float32Array(positions),size:3},properties:{value:new Float32Array(vertexProperties),size:1},vertex_indexs:{value:new Int32Array(indices),size:1}},vertexCount:indices.length,indices:{value:new Uint32Array(indices),size:1}},mesh_lines={drawMode:1,attributes:{positions:{value:new Float32Array(line_positions),size:3}},vertexCount:line_positions.length/3},t1=performance.now();console.log(`Task makeMesh took ${.001*(t1-t0)}  seconds.`),postMessage([mesh,mesh_lines,[propertyValueRangeMin,propertyValueRangeMax]])}privateLayer.layerName="privateLayer",privateLayer.defaultProps=privateLayer_defaultProps;var json_loader=__webpack_require__("./node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js");class Grid3DLayer extends composite_layer.Z{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinished=this.state?.isFinishedLoading??!1;return isLoaded&&isFinished}rebuildData(reportBoundingBox){(async function load_data(pointsData,polysData,propertiesData){const points=Array.isArray(pointsData)?pointsData:await(0,load.z)(pointsData,json_loader.H),polys=Array.isArray(polysData)?polysData:await(0,load.z)(polysData,json_loader.H),properties=Array.isArray(propertiesData)?propertiesData:await(0,load.z)(propertiesData,json_loader.H);return Promise.all([points,polys,properties])})(this.props.pointsData,this.props.polysData,this.props.propertiesData).then((([points,polys,properties])=>{const bbox=function GetBBox(points,isZIncreasingDownwards){let xmax=-99999999,ymax=-99999999,zmax=-99999999,xmin=99999999,ymin=99999999,zmin=99999999;const z_sign=isZIncreasingDownwards?-1:1;for(let i=0;i<points.length/3;i++)xmax=points[3*i+0]>xmax?points[3*i+0]:xmax,xmin=points[3*i+0]<xmin?points[3*i+0]:xmin,ymax=points[3*i+1]>ymax?points[3*i+1]:ymax,ymin=points[3*i+1]<ymin?points[3*i+1]:ymin,zmax=points[3*i+2]>zmax?points[3*i+2]:zmax,zmin=points[3*i+2]<zmin?points[3*i+2]:zmin;return[xmin,ymin,zmin*z_sign,xmax,ymax,zmax*z_sign]}(points,this.props.ZIncreasingDownwards),blob=new Blob(["self.onmessage = ",webworker_makeFullMesh.toString()],{type:"text/javascript"}),url=URL.createObjectURL(blob),webWorker=new Worker(url),webworkerParams={points:points,polys:polys,properties:properties,isZIncreasingDownwards:this.props.ZIncreasingDownwards};webWorker.postMessage(webworkerParams),webWorker.onmessage=e=>{const[mesh,mesh_lines,propertyValueRange]=e.data,legend={discrete:!1,valueRange:this.props.colorMapRange??propertyValueRange,colorName:this.props.colorMapName,title:"MapLayer",colorMapFunction:this.props.colorMapFunction};this.setState({mesh:mesh,mesh_lines:mesh_lines,propertyValueRange:propertyValueRange,legend:legend}),void 0!==this.props.setReportedBoundingBox&&reportBoundingBox&&this.props.setReportedBoundingBox(bbox),webWorker.terminate(),this.setState({...this.state,isFinishedLoading:!0})}}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.pointsData,oldProps.pointsData)&&(0,lodash.isEqual)(props.polysData,oldProps.polysData)&&(0,lodash.isEqual)(props.propertiesData,oldProps.propertiesData)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];return[new privateLayer(this.getSubLayerProps({mesh:this.state.mesh,meshLines:this.state.mesh_lines,pickable:!0,colorMapName:this.props.colorMapName,colorMapRange:this.props.colorMapRange,colorMapClampColor:this.props.colorMapClampColor,colorMapFunction:this.props.colorMapFunction,gridLines:this.props.gridLines,propertyValueRange:this.state.propertyValueRange,material:this.props.material,depthTest:this.props.depthTest}))]}}Grid3DLayer.layerName="Grid3DLayer",Grid3DLayer.defaultProps={"@@type":"Grid3DLayer",name:"Grid 3D",id:"grid-3d-layer",visible:!0,material:!0,colorMapName:"",gridLines:!0,propertyValueRange:[0,1],depthTest:!0,ZIncreasingDownwards:!0};var boxSelectionLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/BoxSelectionLayer/boxSelectionLayer.ts")},"./packages/subsurface-viewer/src/layers/intersection/unfoldedGeoJsonLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return UnfoldedGeoJsonLayer}});var _deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js"),lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js"),mathjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"),_viewports_intersectionViewport__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/subsurface-viewer/src/viewports/intersectionViewport.ts");const planeY=2e3;function computeUnfoldedPath(worldCoordinates){const z=worldCoordinates.map((v=>v[2])),delta=worldCoordinates.map(((v,i,coordinates)=>{const prev=coordinates[i-1]||v;return(0,mathjs__WEBPACK_IMPORTED_MODULE_2__.TE$)([prev[0],prev[1]],[v[0],v[1]])})),a=[];delta.forEach((d=>{const prev=a.at(-1)||0;a.push(d+prev)}));return(0,lodash__WEBPACK_IMPORTED_MODULE_0__.zip)(a,[...a].fill(planeY),z)}function getUnfoldedPath(object){const worldCoordinates=object.geometry.coordinates;return(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(worldCoordinates[0],worldCoordinates.at(-1))?function computeUnfoldedPolygon(coordinates){const half=Math.floor(coordinates.length/2),upper_line=coordinates.splice(0,half),lower_line=coordinates.splice(0,half),uul=computeUnfoldedPath(upper_line),ull=computeUnfoldedPath(lower_line.reverse()),unfolded_coordinates=uul.concat(ull.reverse());return unfolded_coordinates.push(uul[0]),unfolded_coordinates}(worldCoordinates):computeUnfoldedPath(worldCoordinates)}class UnfoldedGeoJsonLayer extends _deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_3__.Z{renderLayers(){const layers=super.renderLayers();return layers.flat().filter((layer=>"PathLayer"===layer?.constructor.name)).forEach((layer=>{const unfolded_layer=layer.clone(this.getSubLayerProps({...layer,id:layer.id+"-for-intersection-view",getPath:object=>getUnfoldedPath(object)}));unfolded_layer&&layers.push(unfolded_layer)})),layers}filterSubLayer({layer:layer,viewport:viewport}){return viewport.constructor===_viewports_intersectionViewport__WEBPACK_IMPORTED_MODULE_1__.Z?-1!=layer.id.search("-for-intersection-view"):-1==layer.id.search("-for-intersection-view")}}UnfoldedGeoJsonLayer.layerName="UnfoldedGeoJsonLayer"},"./packages/subsurface-viewer/src/layers/map/mapLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return MapLayer}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),constants=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/constants.js"),lib_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/layer.js"),project=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"),picking=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"),phong_lighting=__webpack_require__("./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts"),model=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/lib/model.js"),geometry=__webpack_require__("./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");var dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),legendCommonFunction=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/component/Utils/legendCommonFunction.js"),texture_2d=__webpack_require__("./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"),esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js");const DEFAULT_TEXTURE_PARAMETERS={[esm.default.TEXTURE_MIN_FILTER]:esm.default.LINEAR_MIPMAP_LINEAR,[esm.default.TEXTURE_MAG_FILTER]:esm.default.LINEAR,[esm.default.TEXTURE_WRAP_S]:esm.default.CLAMP_TO_EDGE,[esm.default.TEXTURE_WRAP_T]:esm.default.CLAMP_TO_EDGE};function getImageData(colorMapName,colorTables,colorMapFunction){const isColorMapFunctionDefined=void 0!==colorMapFunction,isColorMapNameDefined=!!colorMapName;let colorMap=(0,legendCommonFunction.z$)();isColorMapFunctionDefined?colorMap="function"==typeof colorMapFunction?colorMapFunction:()=>colorMapFunction:isColorMapNameDefined&&(colorMap=value=>(0,dist.CA)(value,colorMapName,colorTables));const data=new Uint8Array(768);for(let i=0;i<256;i++){const color=colorMap?colorMap(i/255):[0,0,0];color&&(data[3*i+0]=color[0],data[3*i+1]=color[1],data[3*i+2]=color[2])}return data||[0,0,0]}const defaultProps={data:["dummy"],contours:[-1,-1],isContoursDepth:!0,gridLines:!1,colorMapName:"",coordinateSystem:constants.COORDINATE_SYSTEM.CARTESIAN,propertyValueRange:[0,1],meshValueRange:[0,1],depthTest:!0};class privateMapLayer extends lib_layer.Z{initializeState(context){const{gl:gl}=context,[model_mesh,mesh_lines_model]=this._getModels(gl);this.setState({models:[model_mesh,mesh_lines_model]})}shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags}){return super.shouldUpdateState({props:props,oldProps:oldProps,context:context,changeFlags:changeFlags})||changeFlags.propsOrDataChanged}updateState({context:context}){this.initializeState(context)}_getModels(gl){return[new model.Z(gl,{id:`${this.props.id}-mesh`,vs:"#version 300 es\n#define SHADER_NAME vertex-shader\n\nprecision highp float;\n\n// Primitive attributes\nin vec3 positions;\nin float properties;\nin vec3 normals;\nin vec3 colors;\n\nin int vertex_indexs;\nflat out int vertex_indexs_;\n\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nout vec3 worldPos;\nout float property;\n\n\nvoid main(void) {\n   cameraPosition = project_uCameraPosition;\n\n   worldPos = positions;\n\n   normals_commonspace = normals;\n\n   vertex_indexs_ = vertex_indexs;\n\n   vColor = vec4(colors.rgb, 1.0);\n\n   property = properties;\n\n   position_commonspace = vec4(project_position(positions), 0.0);\n   gl_Position = project_common_position_to_clipspace(position_commonspace);\n}\n",fs:'#version 300 es\n#define SHADER_NAME terrainmap-shader\n\nprecision highp float;\n\n\nuniform bool isContoursDepth;\nuniform float contourReferencePoint;\nuniform float contourInterval;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nflat in int vertex_indexs_;\n\nout vec4 fragColor;\n\nin vec3 worldPos;\nin float property;\n\nuniform sampler2D colormap;\n\nuniform float valueRangeMin;\nuniform float valueRangeMax;\nuniform float colorMapRangeMin;\nuniform float colorMapRangeMax;\n\nuniform vec3 colorMapClampColor;\nuniform bool isClampColor;\nuniform bool isColorMapClampColorTransparent;\nuniform bool smoothShading;\n\n\nvoid main(void) {\n   geometry.uv = vTexCoord;\n\n   vec3 normal = normals_commonspace;\n\n   if (!smoothShading) {\n      normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n   } \n\n   // // Discard transparent pixels. KEEP\n   // if (!picking_uActive && isnan(propertyValue)) {\n   //    discard;\n   //    return;\n   // }\n   \n   //Picking pass.\n   if (picking_uActive) {\n      // Express triangle index in 255 system.\n      float r = 0.0;\n      float g = 0.0;\n      float b = 0.0;\n  \n      int idx = vertex_indexs_;\n  \n      if (idx >= (256 * 256) - 1) {\n         r = floor(float(idx) / (256.0 * 256.0));\n         idx -= int(r * (256.0 * 256.0));\n      }\n  \n      if (idx >= 256 - 1) {\n         g = floor(float(idx) / 256.0);\n         idx -= int(g * 256.0);\n      }\n  \n      b = float(idx);\n  \n      fragColor = vec4(r / 255.0, g / 255.0, b / 255.0,  1.0);\n      return;\n   }\n\n   vec4 color = vec4(1.0, 1.0, 1.0,  1.0);;\n   float propertyValue = property;\n\n   float x = (propertyValue - colorMapRangeMin) / (colorMapRangeMax - colorMapRangeMin);\n   if (x < 0.0 || x > 1.0) {\n      // Out of range. Use clampcolor.\n      if (isClampColor) {\n         color = vec4(colorMapClampColor.rgb, 1.0);\n\n      }\n      else if (isColorMapClampColorTransparent) {\n         discard;\n         return;\n      }\n      else {\n         // Use min/max color to clamp.\n         x = max(0.0, x);\n         x = min(1.0, x);\n\n         color = texture2D(colormap, vec2(x, 0.5));\n      }\n   }\n   else {\n      color = texture2D(colormap, vec2(x, 0.5));\n   }\n\n  \n   bool is_contours = contourReferencePoint != -1.0 && contourInterval != -1.0;\n   if (is_contours) {\n      // Contours are made of either depths or properties.\n      float val = isContoursDepth ? (abs(worldPos.z) - contourReferencePoint) / contourInterval\n                                  : (propertyValue - contourReferencePoint) / contourInterval;\n\n      float f  = fract(val);\n      float df = fwidth(val);\n\n      // keep: float c = smoothstep(df * 1.0, df * 2.0, f); // smootstep from/to no of pixels distance fronm contour line.\n      float c = smoothstep(0.0, df * 2.0, f);\n\n      color = color * vec4(c, c, c, 1.0);\n   }\n\n   // Use normal lighting. This has no effect if "material" property is not set.\n   vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n   fragColor = vec4(lightColor, 1.0);\n\n   DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n',geometry:new geometry.Z({drawMode:this.props.mesh.drawMode,attributes:{positions:this.props.mesh.attributes.positions,normals:this.props.mesh.attributes.normals,properties:this.props.mesh.attributes.properties,vertex_indexs:this.props.mesh.attributes.vertex_indexs},vertexCount:this.props.mesh.vertexCount,indices:this.props.mesh.indices}),modules:[project.Z,picking.Z,phong_lighting.s],isInstanced:!1}),new model.Z(gl,{id:`${this.props.id}-lines`,vs:"#version 300 es\n#define SHADER_NAME vertex-lines-shader\n\nprecision highp float;\n\nin vec3 positions;\n\nout vec4 position_commonspace;\n\nvoid main(void) {\n   vec3 position_commonspace = project_position(positions);\n   gl_Position = project_common_position_to_clipspace(vec4(position_commonspace, 0.0));\n}\n",fs:"#version 300 es\n#define SHADER_NAME graph-layer-fragment-shader\n\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  \n  // Picking pass.\n  if (picking_uActive) {\n    discard;\n    return;\n  }\n\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n",geometry:new geometry.Z(this.props.meshLines),modules:[project.Z,picking.Z],isInstanced:!1})]}draw(args){if(!this.state.models)return;const{uniforms:uniforms,context:context}=args,{gl:gl}=context,contourReferencePoint=this.props.contours[0]??-1,contourInterval=this.props.contours[1]??-1,isContoursDepth=this.props.isContoursDepth,[model_mesh,mesh_lines_model]=this.state.models,valueRangeMin=this.props.propertyValueRange[0]??0,valueRangeMax=this.props.propertyValueRange[1]??1,colorMapRangeMin=this.props.colorMapRange?.[0]??valueRangeMin,colorMapRangeMax=this.props.colorMapRange?.[1]??valueRangeMax,isClampColor=void 0!==this.props.colorMapClampColor&&!0!==this.props.colorMapClampColor&&!1!==this.props.colorMapClampColor;let colorMapClampColor=isClampColor?this.props.colorMapClampColor:[0,0,0];colorMapClampColor=colorMapClampColor.map((x=>(x??0)/255));const isColorMapClampColorTransparent=!1===this.props.colorMapClampColor,smoothShading=this.props.smoothShading;gl.enable(esm.default.POLYGON_OFFSET_FILL),this.props.depthTest||gl.disable(esm.default.DEPTH_TEST),gl.polygonOffset(1,1),model_mesh.setUniforms({...uniforms,contourReferencePoint:contourReferencePoint,contourInterval:contourInterval,isContoursDepth:isContoursDepth,colormap:new texture_2d.Z(context.gl,{width:256,height:1,format:esm.default.RGB,data:getImageData(this.props.colorMapName,this.context.userData.colorTables,this.props.colorMapFunction),parameters:DEFAULT_TEXTURE_PARAMETERS}),valueRangeMin:valueRangeMin,valueRangeMax:valueRangeMax,colorMapRangeMin:colorMapRangeMin,colorMapRangeMax:colorMapRangeMax,colorMapClampColor:colorMapClampColor,isColorMapClampColorTransparent:isColorMapClampColorTransparent,isClampColor:isClampColor,smoothShading:smoothShading}).draw(),gl.disable(esm.default.POLYGON_OFFSET_FILL),this.props.depthTest||gl.enable(esm.default.DEPTH_TEST),this.props.gridLines&&mesh_lines_model.draw()}decodePickingColor(){return 0}getPickingInfo({info:info}){if(!info.color)return info;const layer_properties=[],vertexIndex=65536*info.color[0]+256*info.color[1]+info.color[2],depth=-this.props.mesh.attributes.positions.value[3*vertexIndex+2];layer_properties.push((0,layerTools.ws)("Depth",depth));const property=this.props.mesh.attributes.properties.value[vertexIndex];return layer_properties.push((0,layerTools.ws)("Property",property)),{...info,properties:layer_properties}}}privateMapLayer.layerName="privateMapLayer",privateMapLayer.defaultProps=defaultProps;var lodash=__webpack_require__("./node_modules/lodash/lodash.js"),lib=__webpack_require__("./node_modules/@vivaxy/png/lib/index.js");function makeFullMesh(e){const params=e.data,meshData=params.meshData,propertiesData=params.propertiesData,isMesh=params.isMesh,frame=params.frame,smoothShading=params.smoothShading;function getFloat32ArrayMinMax(data){let max=-99999999,min=99999999;for(let i=0;i<data.length;i++)max=data[i]>max?data[i]:max,min=data[i]<min?data[i]:min;return[min,max]}function crossProduct(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function calcNormal(w,h,nx,ny,isMesh,smoothShading,meshData,ox,oy){if(!smoothShading)return[1,1,1];if(!isMesh)return[0,0,1];const i0=h*nx+w,i1=h*nx+(w-1),i2=(h+1)*nx+w,i3=h*nx+(w+1),i4=(h-1)*nx+w,i0_act=!isNaN(meshData[i0]),i1_act=w-1>=0&&!isNaN(meshData[i1]),i2_act=h+1<ny&&!isNaN(meshData[i2]),i3_act=w+1<nx&&!isNaN(meshData[i3]),i4_act=h-1>=0&&!isNaN(meshData[i4]),noNormal=[0,0,1];if(!i0_act)return noNormal;const hh=ny-1-h,p0=[ox+w*dx,oy+hh*dy,i0_act?-meshData[i0]:0],p1=[ox+(w-1)*dx,oy+hh*dy,i1_act?-meshData[i1]:0],p2=[ox+w*dx,oy+(hh+1)*dy,i2_act?-meshData[i2]:0],p3=[ox+(w+1)*dx,oy+hh*dy,i3_act?-meshData[i3]:0],p4=[ox+w*dx,oy+(hh-1)*dy,i4_act?-meshData[i4]:0],v1=[p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]],v2=[p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]],v3=[p3[0]-p0[0],p3[1]-p0[1],p3[2]-p0[2]],v4=[p4[0]-p0[0],p4[1]-p0[1],p4[2]-p0[2]],normals=[];if(i1_act&&i2_act){const normal=crossProduct(v2,v1);normals.push(normal)}if(i2_act&&i3_act){const normal=crossProduct(v3,v2);normals.push(normal)}if(i3_act&&i4_act){const normal=crossProduct(v4,v3);normals.push(normal)}if(i4_act&&i1_act){const normal=crossProduct(v1,v4);normals.push(normal)}if(0===normals.length)return noNormal;const mean=normals[0];for(let i=1;i<normals.length;i++)mean[0]+=normals[i][0],mean[1]+=normals[i][1],mean[2]+=normals[i][2];return function normalize(a){const L=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);a[0]/=L,a[1]/=L,a[2]/=L}(mean),mean}const meshZValueRange=getFloat32ArrayMinMax(meshData),propertyValueRange=getFloat32ArrayMinMax(propertiesData),ox=frame.origin[0],oy=frame.origin[1],dx=frame.increment[0],dy=frame.increment[1],nx=frame.count[0],ny=frame.count[1],propLength=propertiesData.length,isCellCenteredProperties=propLength===(nx-1)*(ny-1);propLength!==(nx-1)*(ny-1)&&propLength!==nx*ny&&console.error("There should be as many property values as nodes (nx*ny) OR as many as cells (nx - 1) * (ny - 1).");const positions=[],normals=[],indices=[],vertexProperties=[],vertexIndexs=[],line_positions=[];if(isCellCenteredProperties){let i_indices=0,i_vertices=0;for(let h=0;h<ny-1;h++)for(let w=0;w<nx-1;w++){const hh=ny-1-h,i0=h*nx+w,i1=h*nx+(w+1),i2=(h+1)*nx+(w+1),i3=(h+1)*nx+w,normal0=calcNormal(w,h,nx,ny,isMesh,smoothShading,meshData,ox,oy),normal1=calcNormal(w+1,h,nx,ny,isMesh,smoothShading,meshData,ox,oy),normal2=calcNormal(w+1,h+1,nx,ny,isMesh,smoothShading,meshData,ox,oy),normal3=calcNormal(w,h+1,nx,ny,isMesh,smoothShading,meshData,ox,oy),i0_act=!isMesh||!isNaN(meshData[i0]),i1_act=!isMesh||!isNaN(meshData[i1]),i2_act=!isMesh||!isNaN(meshData[i2]),i3_act=!isMesh||!isNaN(meshData[i3]),x0=ox+w*dx,y0=oy+hh*dy,z0=isMesh?-meshData[i0]:0,x1=ox+(w+1)*dx,y1=oy+hh*dy,z1=isMesh?-meshData[i1]:0,x2=ox+(w+1)*dx,y2=oy+(hh-1)*dy,z2=isMesh?-meshData[i2]:0,x3=ox+w*dx,y3=oy+(hh-1)*dy,z3=isMesh?-meshData[i3]:0,propertyValue=propertiesData[h*(nx-1)+w];isNaN(propertyValue)||(i1_act&&i3_act?(i0_act&&(positions.push(x1,y1,z1),positions.push(x3,y3,z3),positions.push(x0,y0,z0),normals.push(normal1[0],normal1[1],normal1[2]),normals.push(normal3[0],normal3[1],normal3[2]),normals.push(normal0[0],normal0[1],normal0[2]),vertexIndexs.push(i_vertices++,i_vertices++,i_vertices++),indices.push(i_indices++,i_indices++,i_indices++),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),line_positions.push(x0,y0,z0),line_positions.push(x3,y3,z3),line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1)),i2_act&&(positions.push(x1,y1,z1),positions.push(x3,y3,z3),positions.push(x2,y2,z2),normals.push(normal1[0],normal1[1],normal1[2]),normals.push(normal3[0],normal3[1],normal3[2]),normals.push(normal2[0],normal2[1],normal2[2]),vertexIndexs.push(i_vertices++,i_vertices++,i_vertices++),indices.push(i_indices++,i_indices++,i_indices++),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),line_positions.push(x2,y2,z2),line_positions.push(x3,y3,z3),line_positions.push(x2,y2,z2),line_positions.push(x1,y1,z1)),(i0_act&&!i2_act||!i0_act&&i2_act)&&(line_positions.push(x1,y1,z1),line_positions.push(x3,y3,z3))):i0_act&&i2_act&&(i1_act&&(positions.push(x1,y1,z1),positions.push(x2,y2,z2),positions.push(x0,y0,z0),normals.push(normal1[0],normal1[1],normal1[2]),normals.push(normal2[0],normal2[1],normal2[2]),normals.push(normal0[0],normal0[1],normal0[2]),vertexIndexs.push(i_vertices++,i_vertices++,i_vertices++),indices.push(i_indices++,i_indices++,i_indices++),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),line_positions.push(x1,y1,z1),line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1),line_positions.push(x2,y2,z2)),i3_act&&(positions.push(x0,y0,z0),positions.push(x3,y3,z3),positions.push(x2,y2,z2),normals.push(normal0[0],normal0[1],normal0[2]),normals.push(normal3[0],normal3[1],normal3[2]),normals.push(normal2[0],normal2[1],normal2[2]),vertexIndexs.push(i_vertices++,i_vertices++,i_vertices++),indices.push(i_indices++,i_indices++,i_indices++),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),vertexProperties.push(propertyValue),line_positions.push(x3,y3,z3),line_positions.push(x0,y0,z0),line_positions.push(x3,y3,z3),line_positions.push(x2,y2,z2)),(i3_act&&!i1_act||!i3_act&&i1_act)&&(line_positions.push(x0,y0,z0),line_positions.push(x2,y2,z2))))}}else{let i=0;for(let h=0;h<ny;h++)for(let w=0;w<nx;w++){const i0=h*nx+w,x0=ox+w*dx,y0=oy+(ny-1-h)*dy,z=isMesh?-meshData[i0]:0,propertyValue=propertiesData[i0];positions.push(x0,y0,z);const normal=calcNormal(w,h,nx,ny,isMesh,smoothShading,meshData,ox,oy);normals.push(normal[0],normal[1],normal[2]),vertexProperties.push(propertyValue),vertexIndexs.push(i++)}for(let h=0;h<ny-1;h++)for(let w=0;w<nx-1;w++){const i0=h*nx+w,i1=h*nx+(w+1),i2=(h+1)*nx+(w+1),i3=(h+1)*nx+w,i0_act=!isMesh||!isNaN(meshData[i0])&&!isNaN(propertiesData[i0]),i1_act=!isMesh||!isNaN(meshData[i1])&&!isNaN(propertiesData[i1]),i2_act=!isMesh||!isNaN(meshData[i2])&&!isNaN(propertiesData[i2]),i3_act=!isMesh||!isNaN(meshData[i3])&&!isNaN(propertiesData[i3]),hh=ny-h-1,x0=ox+w*dx,y0=oy+hh*dy,z0=isMesh?-meshData[i0]:0,x1=ox+(w+1)*dx,y1=oy+hh*dy,z1=isMesh?-meshData[i1]:0,x2=ox+(w+1)*dx,y2=oy+(hh-1)*dy,z2=isMesh?-meshData[i2]:0,x3=ox+w*dx,y3=oy+(hh-1)*dy,z3=isMesh?-meshData[i3]:0;i1_act&&i3_act?(i0_act&&(indices.push(i1,i3,i0),line_positions.push(x0,y0,z0),line_positions.push(x3,y3,z3),line_positions.push(x0,y0,z0),line_positions.push(x1,y1,z1)),i2_act&&(indices.push(i1,i3,i2),line_positions.push(x2,y2,z2),line_positions.push(x3,y3,z3),line_positions.push(x2,y2,z2),line_positions.push(x1,y1,z1)),(i0_act&&!i2_act||!i0_act&&i2_act)&&(line_positions.push(x1,y1,z1),line_positions.push(x3,y3,z3))):i0_act&&i2_act&&(i1_act&&indices.push(i1,i2,i0),i3_act&&indices.push(i3,i0,i2),(i3_act&&!i1_act||!i3_act&&i1_act)&&(line_positions.push(x0,y0,z0),line_positions.push(x2,y2,z2)))}}const mesh={drawMode:4,attributes:{positions:{value:new Float32Array(positions),size:3},normals:{value:new Float32Array(normals),size:3},properties:{value:new Float32Array(vertexProperties),size:1},vertex_indexs:{value:new Int32Array(vertexIndexs),size:1}},vertexCount:indices.length,indices:{value:new Uint32Array(indices),size:1}},mesh_lines={drawMode:1,attributes:{positions:{value:new Float32Array(line_positions),size:3}},vertexCount:line_positions.length/3};postMessage([mesh,mesh_lines,meshZValueRange,propertyValueRange])}function rotate(x,y,x0,y0,rad){return[Math.cos(rad)*(x-x0)-Math.sin(rad)*(y-y0)+x0,Math.sin(rad)*(x-x0)+Math.cos(rad)*(y-y0)+y0]}class MapLayer extends composite_layer.Z{get isLoaded(){const subLayers=this.getSubLayers(),isLoaded=super.isLoaded&&subLayers.length>0&&subLayers.every((layer=>layer.isLoaded)),isFinished=this.state?.isFinishedLoading??!1;return isLoaded&&isFinished}rebuildData(reportBoundingBox){void 0!==this.props.meshUrl&&console.warn('"meshUrl" is deprecated. Use "meshData"'),void 0!==this.props.propertiesUrl&&console.warn('"propertiesUrl" is deprecated. Use "propertiesData"');const p=async function load_mesh_and_properties(meshData,propertiesData,ZIncreasingDownwards){const isMesh=void 0!==meshData,isProperties=void 0!==propertiesData;let properties;if(isMesh||isProperties||console.error("Error. One or both of texture and mesh must be given!"),isMesh&&!isProperties&&(propertiesData=meshData),Array.isArray(propertiesData))properties=new Float32Array(propertiesData);else{const response=await fetch(propertiesData);response.ok||console.error("Could not load ",propertiesData);const blob=await response.blob();if("image/png"===response.headers.get("content-type"))properties=await new Promise((resolve=>{const fileReader=new FileReader;fileReader.readAsArrayBuffer(blob),fileReader.onload=()=>{const arrayBuffer=fileReader.result,data=lib.Jx(arrayBuffer).data,n=data.length,buffer=new ArrayBuffer(n),view=new DataView(buffer);for(let i=0;i<n;i++)view.setUint8(i,data[i]);const floatArray=new Float32Array(buffer);resolve(floatArray)}}));else{const buffer=await blob.arrayBuffer();properties=new Float32Array(buffer)}}let mesh=new Float32Array;if(isMesh)if(Array.isArray(meshData))mesh=new Float32Array(meshData);else{const response_mesh=await fetch(meshData);response_mesh.ok||console.error("Could not load mesh");const blob_mesh=await response_mesh.blob();if("image/png"===response_mesh.headers.get("content-type"))mesh=await new Promise((resolve=>{const fileReader=new FileReader;fileReader.readAsArrayBuffer(blob_mesh),fileReader.onload=()=>{const arrayBuffer=fileReader.result,data=lib.Jx(arrayBuffer).data,n=data.length,buffer=new ArrayBuffer(n),view=new DataView(buffer);for(let i=0;i<n;i++)view.setUint8(i,data[i]);const floatArray=new Float32Array(buffer);resolve(floatArray)}}));else{const buffer=await blob_mesh.arrayBuffer();mesh=new Float32Array(buffer)}}if(!ZIncreasingDownwards)for(let i=0;i<mesh.length;i++)mesh[i]*=-1;return Promise.all([isMesh,mesh,properties])}(this.props.meshData??this.props.meshUrl,this.props.propertiesData??this.props.propertiesUrl,this.props.ZIncreasingDownwards);p.then((([isMesh,meshData,propertiesData])=>{const blob=new Blob(["self.onmessage = ",makeFullMesh.toString()],{type:"text/javascript"}),url=URL.createObjectURL(blob),webWorker=new Worker(url),webworkerParams={meshData:meshData,propertiesData:propertiesData,isMesh:isMesh,frame:this.props.frame,smoothShading:this.props.smoothShading};webWorker.postMessage(webworkerParams),webWorker.onmessage=e=>{const[mesh,mesh_lines,meshZValueRange,propertyValueRange]=e.data;if(this.setState({...this.state,mesh:mesh,mesh_lines:mesh_lines,propertyValueRange:propertyValueRange}),void 0!==this.props.setReportedBoundingBox&&reportBoundingBox){const xinc=this.props.frame?.increment?.[0]??0,yinc=this.props.frame?.increment?.[1]??0,nnodes_x=this.props.frame?.count?.[0]??2,nnodes_y=this.props.frame?.count?.[1]??2,xMin=this.props.frame?.origin?.[0]??0,yMin=this.props.frame?.origin?.[1]??0,zMin=-meshZValueRange[0],xMax=xMin+xinc*(nnodes_x-1),yMax=yMin+yinc*(nnodes_y-1),zMax=-meshZValueRange[1],center=this.props.frame.rotPoint??this.props.frame.origin,rotRad=(this.props.frame.rotDeg??0)*(2*Math.PI)/360,[x0,y0]=rotate(xMin,yMin,center[0],center[1],rotRad),[x1,y1]=rotate(xMax,yMin,center[0],center[1],rotRad),[x2,y2]=rotate(xMax,yMax,center[0],center[1],rotRad),[x3,y3]=rotate(xMin,yMax,center[0],center[1],rotRad),x_min=Math.min(x0,x1,x2,x3),x_max=Math.max(x0,x1,x2,x3),y_min=Math.min(y0,y1,y2,y3),y_max=Math.max(y0,y1,y2,y3);this.props.setReportedBoundingBox([x_min,y_min,zMin,x_max,y_max,zMax])}webWorker.terminate(),this.setState({...this.state,isFinishedLoading:!0})}}))}initializeState(){this.setState({...this.state,isFinishedLoading:!1});this.rebuildData(!0)}updateState({props:props,oldProps:oldProps}){if(!((0,lodash.isEqual)(props.meshUrl,oldProps.meshUrl)&&(0,lodash.isEqual)(props.propertiesUrl,oldProps.propertiesUrl)&&(0,lodash.isEqual)(props.meshData,oldProps.meshData)&&(0,lodash.isEqual)(props.propertiesData,oldProps.propertiesData)&&(0,lodash.isEqual)(props.frame,oldProps.frame)&&(0,lodash.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards)&&(0,lodash.isEqual)(props.gridLines,oldProps.gridLines))){this.setState({...this.state,isFinishedLoading:!1});const reportBoundingBox=!1;this.rebuildData(reportBoundingBox)}}renderLayers(){if(1===Object.keys(this.state).length)return[];const[minX,minY]=this.props.frame.origin,center=this.props.frame.rotPoint??[minX,minY],rotatingModelMatrix=(0,layerTools.RT)(this.props.frame.rotDeg??0,center[0],center[1]),isMesh=void 0!==this.props.meshUrl&&""!==this.props.meshUrl||void 0!==this.props.meshData&&""!==this.props.meshData;void 0!==this.props.modelMatrix&&null!==this.props.modelMatrix&&rotatingModelMatrix.multiplyRight(this.props.modelMatrix);return[new privateMapLayer(this.getSubLayerProps({mesh:this.state.mesh,meshLines:this.state.mesh_lines,pickable:this.props.pickable,modelMatrix:rotatingModelMatrix,contours:this.props.contours,gridLines:this.props.gridLines,isContoursDepth:!!isMesh&&this.props.isContoursDepth,colorMapName:this.props.colorMapName,colorMapRange:this.props.colorMapRange,colorMapClampColor:this.props.colorMapClampColor,colorMapFunction:this.props.colorMapFunction,propertyValueRange:this.state.propertyValueRange,material:this.props.material,smoothShading:this.props.smoothShading,depthTest:this.props.depthTest}))]}}MapLayer.layerName="MapLayer",MapLayer.defaultProps={"@@type":"MapLayer",name:"Map",id:"map3d-layer-float32",pickable:!0,visible:!0,bounds:{type:"object",value:null,false:!0,compare:!0},colorMapRange:{type:"array"},contours:[-1,-1],isContoursDepth:!0,gridLines:!1,smoothShading:!0,material:!0,depthTest:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/points/pointsLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return PointsLayer}});var _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),_deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js"),lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js"),_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");class PointsLayer extends _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_1__.Z{renderLayers(){return[new _deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_2__.Z(this.getSubLayerProps({id:"points-layer",pickable:this.props.pickable,billboard:!0,data:this.state.dataAttributes,_pathType:"open",getFillColor:()=>this.props.color,getRadius:()=>this.props.pointRadius,radiusUnits:this.props.radiusUnits,updateTriggers:{getFillColor:[this.props.color],getRadius:[this.props.pointRadius]}}))]}initializeState(){const dataAttributes=this.rebuildDataAttributes(!0);this.setState({dataAttributes:dataAttributes})}updateState({props:props,oldProps:oldProps}){if(!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.pointsData,oldProps.pointsData)||!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards)){const dataAttributes=this.rebuildDataAttributes(!1);this.setState({dataAttributes:dataAttributes})}}rebuildDataAttributes(reportBoundingBox){const dataArray=this.loadData();if(!dataArray)return null;if(this.props.ZIncreasingDownwards&&(0,_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__.pV)(dataArray),"function"==typeof this.props.setReportedBoundingBox&&reportBoundingBox){const boundingBox=(0,_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__.f3)(dataArray);this.props.setReportedBoundingBox(boundingBox)}return{length:dataArray.length/3,attributes:{getPosition:{value:dataArray,size:3}}}}loadData(){return Array.isArray(this.props.pointsData)?new Float32Array(this.props.pointsData):new Float32Array}}PointsLayer.layerName="PointsLayer",PointsLayer.defaultProps={"@@type":"PointsLayer",name:"PointsLayer",id:"points-layer",color:[125,0,0,255],radiusUnits:"pixels",pointRadius:5,pickable:!0,visible:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/polylines/polylinesLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return PolylinesLayer}});var _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),_deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js"),lodash__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lodash/lodash.js"),_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts");class PolylinesLayer extends _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_1__.Z{renderLayers(){return[new _deck_gl_layers_typed__WEBPACK_IMPORTED_MODULE_2__.Z(this.getSubLayerProps({id:"polylines-layer",widthUnits:this.props.widthUnits,pickable:this.props.pickable,billboard:!0,jointRounded:!0,capRounded:!0,data:this.state.dataAttributes,_pathType:this.state.dataAttributes.pathType,getColor:()=>this.props.color,getWidth:()=>this.props.linesWidth,updateTriggers:{getColor:[this.props.color],getWidth:[this.props.linesWidth]}}))]}initializeState(){const dataAttributes=this.rebuildDataAttributes(!0);this.setState({dataAttributes:dataAttributes})}updateState({props:props,oldProps:oldProps}){if(!((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.polylinePoints,oldProps.polylinePoints)&&(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.startIndices,oldProps.startIndices)&&(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.polylinesClosed,oldProps.polylinesClosed)&&(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isEqual)(props.ZIncreasingDownwards,oldProps.ZIncreasingDownwards))){const dataAttributes=this.rebuildDataAttributes(!1);this.setState({dataAttributes:dataAttributes})}}rebuildDataAttributes(reportBoundingBox){const dataArrays=this.loadData();if(this.props.ZIncreasingDownwards&&(0,_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__.pV)(dataArrays.positions),"function"==typeof this.props.setReportedBoundingBox&&reportBoundingBox){const boundingBox=(0,_utils_layerTools__WEBPACK_IMPORTED_MODULE_3__.f3)(dataArrays.positions);this.props.setReportedBoundingBox(boundingBox)}return{length:dataArrays.linesCount,startIndices:dataArrays.startIndices,attributes:{getPath:{value:dataArrays.positions,size:3}},pathType:dataArrays.pathType}}loadData(){this.normalizeStartIndices();const data=this.closePolylines();return{linesCount:data.startIndices.length,positions:new Float32Array(data.polylinePoints),startIndices:new Uint32Array(data.startIndices),pathType:data.pathType}}closePolylines(){const isClosedFunc=this.createIsClosedFunc();if(!isClosedFunc.func)return{polylinePoints:this.props.polylinePoints,startIndices:this.props.startIndices,pathType:isClosedFunc.pathType};let startIndexShift=0;const closedPoints=[],closedStartIndices=[],linesCount=this.props.startIndices.length-1;for(let i=0;i<linesCount;++i){const isClosed=isClosedFunc.func(i);closedStartIndices.push(this.props.startIndices[i]+startIndexShift),isClosed?(this.closePolyline(i,closedPoints),++startIndexShift):this.copyPolyline(i,closedPoints)}return{polylinePoints:closedPoints,startIndices:closedStartIndices,pathType:isClosedFunc.pathType}}normalizeStartIndices(){const lastIndex=this.props.startIndices.slice(-1)[0],totalPointsCount=this.props.polylinePoints.length/3;lastIndex<totalPointsCount&&this.props.startIndices.push(totalPointsCount)}copyPolyline(lineIndex,outPoints){const startPoint=this.props.startIndices[lineIndex],endPoint=this.props.startIndices[lineIndex+1];for(let idx=startPoint;idx<endPoint;++idx)outPoints.push(...this.getPolylinePoint(idx))}closePolyline(lineIndex,outPoints){this.copyPolyline(lineIndex,outPoints);const startPoint=this.props.startIndices[lineIndex];outPoints.push(...this.getPolylinePoint(startPoint))}getPolylinePoint(index){return this.props.polylinePoints.slice(3*index,3*(index+1))}createIsClosedFunc(){return!0===this.props.polylinesClosed?{func:()=>!0,pathType:"loop"}:Array.isArray(this.props.polylinesClosed)?{func:lineIndex=>this.props.polylinesClosed[lineIndex],pathType:null}:{func:null,pathType:"open"}}}PolylinesLayer.layerName="PolylinesLayer",PolylinesLayer.defaultProps={"@@type":"PolylinesLayer",name:"PolylinesLayer",id:"polylines-layer",widthUnits:"pixels",linesWidth:5,color:[0,0,200,255],pickable:!0,visible:!0,ZIncreasingDownwards:!0}},"./packages/subsurface-viewer/src/layers/utils/layerTools.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A3:function(){return isDrawingEnabled},BZ:function(){return getModelMatrixScale},RT:function(){return getModelMatrix},eG:function(){return getLayersByType},f3:function(){return defineBoundingBox},hc:function(){return getLayersById},kF:function(){return getWellLayerByTypeAndSelectedWells},pV:function(){return invertZCoordinate},ws:function(){return createPropertyData}});var math_gl__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");function createPropertyData(name,value,color){return{name:name,value:value,color:color}}function getModelMatrix(deg,x,y){const rad=.017453*deg,IDENTITY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],m1=new math_gl__WEBPACK_IMPORTED_MODULE_0__.Z(IDENTITY).translate([-x,-y,0,1]),mRot=new math_gl__WEBPACK_IMPORTED_MODULE_0__.Z(IDENTITY).rotateZ(rad),m2=new math_gl__WEBPACK_IMPORTED_MODULE_0__.Z(IDENTITY).translate([x,y,0,1]);mRot.multiplyRight(m1);return m2.multiplyRight(mRot)}function getModelMatrixScale(scaleZ){return new math_gl__WEBPACK_IMPORTED_MODULE_0__.Z([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]).scale([1,1,scaleZ])}function getLayersByType(layers,type){return layers?layers.filter((l=>l?.constructor.name===type)):[]}function getWellLayerByTypeAndSelectedWells(layers,type,selectedWell){return layers?layers.filter((l=>l?.constructor.name===type&&l.props.data.features.find((item=>item.properties.name===selectedWell)))):[]}function getLayersById(layers,id){return layers?layers.filter((l=>l.id===id)):[]}function isDrawingEnabled(layer_manager){const drawing_layer=layer_manager.getLayers({layerIds:["drawing-layer"]})?.[0];return drawing_layer&&drawing_layer.props.visible&&"view"!=drawing_layer.props.mode}function invertZCoordinate(dataArray){for(let i=2;i<dataArray.length;i+=3)dataArray[i]*=-1}function defineBoundingBox(dataArray){const length=dataArray.length;let minX=Number.POSITIVE_INFINITY,minY=Number.POSITIVE_INFINITY,minZ=Number.POSITIVE_INFINITY,maxX=Number.NEGATIVE_INFINITY,maxY=Number.NEGATIVE_INFINITY,maxZ=Number.NEGATIVE_INFINITY;for(let i=0;i<length;i+=3){const x=dataArray[i],y=dataArray[i+1],z=dataArray[i+2];minX=x<minX?x:minX,minY=y<minY?y:minY,minZ=z<minZ?z:minZ,maxX=x>maxX?x:maxX,maxY=y>maxY?y:maxY,maxZ=z>maxZ?z:maxZ}return[minX,minY,minZ,maxX,maxY,maxZ]}},"./packages/subsurface-viewer/src/layers/wells/wellsLayer.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{ZP:function(){return WellsLayer},ap:function(){return getSize}});var composite_layer=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"),orbit_viewport=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js"),layerTools=__webpack_require__("./packages/subsurface-viewer/src/layers/utils/layerTools.ts"),path_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js"),text_layer=__webpack_require__("./node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js"),path_style_extension=__webpack_require__("./node_modules/@deck.gl/extensions/dist/esm/path-style/path-style-extension.js"),pureFunctionsAny_generated=__webpack_require__("./node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"),dist=__webpack_require__("./node_modules/@emerson-eps/color-tables/dist/index.js"),lodash=__webpack_require__("./node_modules/lodash/lodash.js");function CatmullRom1D(P0,P1,P2,P3,t){const tt=t*t,ttt=t*t*t,dist_p0_p1=Math.sqrt((P1-P0)*(P1-P0)+(P1-P0)*(P1-P0)+(P1-P0)*(P1-P0)),dist_p1_p2=Math.sqrt((P1-P2)*(P1-P2)+(P1-P2)*(P1-P2)+(P1-P2)*(P1-P2)),dist_p2_p3=Math.sqrt((P3-P2)*(P3-P2)+(P3-P2)*(P3-P2)+(P3-P2)*(P3-P2)),t01=Math.pow(dist_p0_p1,.5),t12=Math.pow(dist_p1_p2,.5),t23=Math.pow(dist_p2_p3,.5),m1=P2-P1+t12*((P1-P0)/t01-(P2-P0)/(t01+t12)),m2=P2-P1+t12*((P3-P2)/t23-(P3-P1)/(t12+t23));return(2*(P1-P2)+m1+m2)*ttt+(-3*(P1-P2)-m1-m1-m2)*tt+m1*t+P1}function CatmullRom(P0,P1,P2,P3,t){const tt=t*t,ttt=t*t*t,dist_p0_p1=Math.sqrt((P1[0]-P0[0])*(P1[0]-P0[0])+(P1[1]-P0[1])*(P1[1]-P0[1])+(P1[2]-P0[2])*(P1[2]-P0[2])),dist_p1_p2=Math.sqrt((P1[0]-P2[0])*(P1[0]-P2[0])+(P1[1]-P2[1])*(P1[1]-P2[1])+(P1[2]-P2[2])*(P1[2]-P2[2])),dist_p2_p3=Math.sqrt((P3[0]-P2[0])*(P3[0]-P2[0])+(P3[1]-P2[1])*(P3[1]-P2[1])+(P3[2]-P2[2])*(P3[2]-P2[2])),t01=Math.pow(dist_p0_p1,.5),t12=Math.pow(dist_p1_p2,.5),t23=Math.pow(dist_p2_p3,.5),m1_x=P2[0]-P1[0]+t12*((P1[0]-P0[0])/t01-(P2[0]-P0[0])/(t01+t12)),m1_y=P2[1]-P1[1]+t12*((P1[1]-P0[1])/t01-(P2[1]-P0[1])/(t01+t12)),m1_z=P2[2]-P1[2]+t12*((P1[2]-P0[2])/t01-(P2[2]-P0[2])/(t01+t12)),m2_x=P2[0]-P1[0]+t12*((P3[0]-P2[0])/t23-(P3[0]-P1[0])/(t12+t23)),m2_y=P2[1]-P1[1]+t12*((P3[1]-P2[1])/t23-(P3[1]-P1[1])/(t12+t23)),m2_z=P2[2]-P1[2]+t12*((P3[2]-P2[2])/t23-(P3[2]-P1[2])/(t12+t23)),a_x=2*(P1[0]-P2[0])+m1_x+m2_x,a_y=2*(P1[1]-P2[1])+m1_y+m2_y,a_z=2*(P1[2]-P2[2])+m1_z+m2_z,b_x=-3*(P1[0]-P2[0])-m1_x-m1_x-m2_x,b_y=-3*(P1[1]-P2[1])-m1_y-m1_y-m2_y,b_z=-3*(P1[2]-P2[2])-m1_z-m1_z-m2_z,c_y=m1_y,c_z=m1_z;return[a_x*ttt+b_x*tt+m1_x*t+P1[0],a_y*ttt+b_y*tt+c_y*t+P1[1],a_z*ttt+b_z*tt+c_z*t+P1[2]]}var src=__webpack_require__("./node_modules/d3/src/index.js"),unfoldedGeoJsonLayer=__webpack_require__("./packages/subsurface-viewer/src/layers/intersection/unfoldedGeoJsonLayer.ts"),esm=__webpack_require__("./node_modules/@luma.gl/constants/dist/esm/index.js");function multiply(pair,factor){return[pair[0]*factor,pair[1]*factor]}const LINE="line",POINT="point",DEFAULT_POINT_SIZE=8,DEFAULT_LINE_WIDTH=5,DEFAULT_DASH=[5,5];function getDashFactor(accessor,width_accessor,offset=0){return(object,objectInfo)=>{let width=DEFAULT_LINE_WIDTH;"function"==typeof width_accessor?width=width_accessor(object):width_accessor&&(width=width_accessor);const factor=width/(width+offset);let dash=[0,0];return"function"==typeof accessor?dash=accessor(object,objectInfo):accessor?dash=accessor:accessor&&(dash=DEFAULT_DASH),2==dash.length?multiply(dash,factor):multiply(DEFAULT_DASH,factor)}}function getColor(accessor){return accessor||((object,objectInfo)=>{if("function"==typeof accessor){const color=accessor(object,objectInfo);if(color)return color}return object.properties?.color})}function getSize(type,accessor,offset=0){return"function"==typeof accessor?object=>accessor(object)+offset:0==accessor?0:accessor>0?accessor+offset:type==LINE?DEFAULT_LINE_WIDTH+offset:type==POINT?DEFAULT_POINT_SIZE+offset:0}class WellsLayer extends composite_layer.Z{onClick(info){return(0,layerTools.A3)(this.context.layerManager)||this.context.userData.setEditedData({selectedWell:info.object.properties?.name}),!1}setSelection(well,_selection){this.internalState&&this.setState({well:well,selection:_selection})}setMultiSelection(wells){this.internalState&&this.setState({selectedMultiWells:wells})}shouldUpdateState({changeFlags:changeFlags}){return changeFlags.viewportChanged||changeFlags.propsOrDataChanged||"object"==typeof changeFlags.updateTriggersChanged}getLegendData(value){return function getLegendData(logs,wellName,logName,logColor){if(!logs)return null;const log=wellName?logs.find((log=>log.header.well==wellName)):logs[0],logInfo=log?getLogInfo(log,log.header.name,logName):void 0,title="Wells / "+logName;if(log&&"discrete"==logInfo?.description){return{title:title,colorName:logColor,discrete:!0,metadata:log.metadata_discrete[logName].objects}}{const minArray=[],maxArray=[];return logs.forEach((function(log){const logValues=getLogValues(log,log.header.name,logName);minArray.push(Math.min(...logValues)),maxArray.push(Math.max(...logValues))})),{title:title,colorName:logColor,discrete:!1,valueRange:[Math.min(...minArray),Math.max(...maxArray)]}}}(value,"",this.props.logName,this.props.logColor)}setLegend(value){this.setState({legend:this.getLegendData(value)})}getLogLayer(){const sub_layers=this.internalState?.subLayers,log_layer=(0,layerTools.hc)(sub_layers,"wells-layer-log_curve");return log_layer?.[0]}getSelectionLayer(){const sub_layers=this.internalState?.subLayers,log_layer=(0,layerTools.hc)(sub_layers,"wells-layer-selection");return log_layer?.[0]}getLogCurveData(){const log_layer=this.getLogLayer();return log_layer?.props.data}setupLegend(){const data=this.getLogCurveData();data&&this.setLegend(data)}renderLayers(){if(!this.props.data.features)return[];let data=this.props.data;this.props.ZIncreasingDownwards||(data=function invertPath(data_in){const data=(0,lodash.cloneDeep)(data_in),no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;const coords_inverted=lineString.coordinates.map((e=>[e[0],e[1],-e[2]]));data.features[well_no].geometry.geometries[1].coordinates=coords_inverted}return data}(data));const refine=this.props.refine;data=refine?function splineRefine(data_in){const data=(0,lodash.cloneDeep)(data_in),no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const mds=data.features[well_no].properties?.md;if(void 0===mds)continue;const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;const coords=lineString.coordinates,n=coords.length,ts=n>3?[.2,.4,.6,.8]:[],P_first=[coords[0][0]-coords[1][0]+coords[0][0],coords[0][1]-coords[1][1]+coords[0][1],coords[0][2]-coords[1][2]+coords[0][2]],md_first=mds[0][0]-mds[0][1]+mds[0][0],P_n=[coords[n-1][0]-coords[n-2][0]+coords[n-1][0],coords[n-1][1]-coords[n-2][1]+coords[n-1][1],coords[n-1][2]-coords[n-2][2]+coords[n-1][2]],md_n=mds[0][n-1]-mds[0][n-2]+mds[0][n-1],newCoordinates=[],newMds=[];newMds.push([]);for(let i=0;i<n-1;i+=1){let P0,P1,P2,P3,md0,md1,md2,md3;if(0===i?(P0=P_first,P1=coords[i+0],P2=coords[i+1],P3=coords[i+2],md0=md_first,md1=mds[0][i+0],md2=mds[0][i+1],md3=mds[0][i+2]):i===n-2?(P0=coords[n-3],P1=coords[n-2],P2=coords[n-1],P3=P_n,md0=mds[0][n-3],md1=mds[0][n-2],md2=mds[0][n-1],md3=md_n):(P0=coords[i-1],P1=coords[i-0],P2=coords[i+1],P3=coords[i+2],md0=mds[0][i-1],md1=mds[0][i-0],md2=mds[0][i+1],md3=mds[0][i+2]),newCoordinates.push(P1),newMds[0].push(md1),i>1)for(let t_i=0;t_i<ts.length;t_i+=1){const t=ts[t_i],[x,y,z]=CatmullRom(P0,P1,P2,P3,t),md=CatmullRom1D(md0,md1,md2,md3,t);newCoordinates.push([x,y,z]),newMds[0].push(md)}}newCoordinates.push(coords[n-1]),newMds[0].push(mds[0][n-1]),data.features[well_no].geometry.geometries[1].coordinates=newCoordinates,data.features[well_no].properties&&(data.features[well_no].properties.md=newMds)}return data}(data):data;const is3d=this.context.viewport.constructor===orbit_viewport.Z,isDashed=!!this.props.lineStyle?.dash,extensions=[new path_style_extension.Z({dash:isDashed,highPrecisionDash:isDashed})],parameters={[esm.default.DEPTH_TEST]:this.props.depthTest,[esm.default.POLYGON_OFFSET_FILL]:!0},outline=new unfoldedGeoJsonLayer.Z(this.getSubLayerProps({id:"outline",data:data,pickable:!1,stroked:!1,positionFormat:"XYZ",pointRadiusUnits:"pixels",lineWidthUnits:"pixels",visible:this.props.outline,pointRadiusScale:this.props.pointRadiusScale,lineWidthScale:this.props.lineWidthScale,getLineWidth:getSize(LINE,this.props.lineStyle?.width),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size),extensions:extensions,getDashArray:getDashFactor(this.props.lineStyle?.dash),lineBillboard:!0,pointBillboard:!0,parameters:parameters})),colors=new unfoldedGeoJsonLayer.Z(this.getSubLayerProps({id:"colors",data:data,pickable:!0,stroked:!1,positionFormat:"XYZ",pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale,lineWidthScale:this.props.lineWidthScale,getLineWidth:getSize(LINE,this.props.lineStyle?.width,-1),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,-1),getFillColor:getColor(this.props.wellHeadStyle?.color),getLineColor:getColor(this.props.lineStyle?.color),extensions:extensions,getDashArray:getDashFactor(this.props.lineStyle?.dash,getSize(LINE,this.props.lineStyle?.width),-1),lineBillboard:!0,pointBillboard:!0,parameters:parameters})),highlight=new unfoldedGeoJsonLayer.Z(this.getSubLayerProps({id:"highlight",data:getWellObjectByName(data.features,this.props.selectedWell),pickable:!1,stroked:!1,positionFormat:"XYZ",pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale,lineWidthScale:this.props.lineWidthScale,getLineWidth:getSize(LINE,this.props.lineStyle?.width,2),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,2),getFillColor:getColor(this.props.wellHeadStyle?.color),getLineColor:getColor(this.props.lineStyle?.color),parameters:parameters})),highlightMultiWells=new unfoldedGeoJsonLayer.Z(this.getSubLayerProps({id:"highlight2",data:getWellObjectsByName(data.features,this.state.selectedMultiWells),pickable:!1,stroked:!1,positionFormat:"XYZ",pointRadiusUnits:"pixels",lineWidthUnits:"pixels",pointRadiusScale:this.props.pointRadiusScale,lineWidthScale:this.props.lineWidthScale,getLineWidth:getSize(LINE,this.props.lineStyle?.width,-1),getPointRadius:getSize(POINT,this.props.wellHeadStyle?.size,2),getFillColor:[255,140,0],getLineColor:[255,140,0],parameters:parameters}));return[outline,new path_layer.Z(this.getSubLayerProps({id:"log_curve",data:this.props.logData,positionFormat:"XYZ",pickable:!0,widthScale:10,widthMinPixels:1,miterLimit:100,visible:this.props.logCurves,getPath:d=>getLogPath(data.features,d,this.props.logrunName,this.props.lineStyle?.color),getColor:d=>function getLogColor(d,logrun_name,log_name,logColor,colorTables,colorMappingFunction,isLog){const log_data=getLogValues(d,logrun_name,log_name),log_info=getLogInfo(d,logrun_name,log_name);if(0==log_data.length||null==log_info)return[];const log_color=[];if("continuous"==log_info.description){const min=Math.min(...log_data),max_delta=Math.max(...log_data)-min;log_data.forEach((value=>{const rgb=colorMappingFunction?colorMappingFunction((value-min)/max_delta):(0,dist.CA)((value-min)/max_delta,logColor,colorTables);(0,dist.CA)(value-min/max_delta,logColor,colorTables,isLog),rgb?Array.isArray(rgb)?log_color.push([rgb[0],rgb[1],rgb[2]]):log_color.push([rgb?.r,rgb?.g,rgb?.b]):log_color.push([0,0,0,0])}))}else{const log_attributes=getDiscreteLogMetadata(d,log_name)?.objects,logLength=Object.keys(log_attributes).length,attributesObject={},categorial=!0;Object.keys(log_attributes).forEach((key=>{const point=log_attributes[key][1];let rgb;if(colorMappingFunction)rgb=colorMappingFunction(point,categorial,0,logLength-1);else{const arrayOfColors=(0,dist.EC)(logColor,colorTables,point);arrayOfColors.length||console.error("Empty or missed '"+logColor+"' color table"),rgb=arrayOfColors}rgb&&(Array.isArray(rgb)?3===rgb.length?attributesObject[key]=[[rgb[0],rgb[1],rgb[2]],point]:attributesObject[key]=[[rgb[1],rgb[2],rgb[3]],point]:attributesObject[key]=[[rgb.r,rgb.g,rgb.b],point])})),log_data.forEach((log_value=>{const dl_attrs=Object.entries(attributesObject).find((([,value])=>value[1]==log_value))?.[1];dl_attrs?log_color.push(dl_attrs[0]):log_color.push([0,0,0,0])}))}return log_color}(d,this.props.logrunName,this.props.logName,this.props.logColor,this.context.userData.colorTables,this.props.colorMappingFunction,this.props.isLog),getWidth:d=>this.props.logRadius||getLogWidth(d,this.props.logrunName,this.props.logName),updateTriggers:{getColor:[this.props.logrunName,this.props.logName,this.props.logColor,this.context.userData.colorTables,this.props.isLog],getWidth:[this.props.logrunName,this.props.logName,this.props.logRadius],getPath:["XYZ"]},onDataLoad:value=>{this.setLegend(value)},parameters:parameters})),colors,highlight,highlightMultiWells,new path_layer.Z(this.getSubLayerProps({id:"selection",data:this.props.logData,positionFormat:"XYZ",pickable:!1,widthScale:10,widthMinPixels:1,miterLimit:100,visible:this.props.logCurves,getPath:d=>function getLogPath1(wells_data,d,selectedWell,selection,logrun_name,trajectory_line_color){if(!selection||selectedWell!==d.header.well)return[];const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_xyz=getTrajectory(well_object,trajectory_line_color),well_mds=getWellMds(well_object);if(null==well_xyz||null==well_mds||0==well_xyz.length||0==well_mds.length)return[];const log_mds=getLogMd(d,logrun_name);if(!log_mds)return[];const log_xyz=[];let md0=selection[0];if(void 0!==md0){let md1=selection[1];md1==md0&&(md1=void 0);const mdFirst=well_mds[0],mdLast=well_mds[well_mds.length-1];if(void 0!==md1&&md0>md1){const tmp=md0;md0=md1,md1=tmp}const delta=2;if(md0-delta>mdFirst){let xyz=getPositionByMD(well_xyz,well_mds,md0-delta);log_xyz.push(xyz),xyz=getPositionByMD(well_xyz,well_mds,md0),log_xyz.push(xyz)}if(void 0!==md1){const _md1=md1;let index=0;if(well_mds.forEach((md=>{if(md0<=md&&md<=_md1){const xyz=well_xyz[index];log_xyz.push(xyz)}index++})),_md1+delta<mdLast){let xyz=getPositionByMD(well_xyz,well_mds,_md1);log_xyz.push(xyz),xyz=getPositionByMD(well_xyz,well_mds,_md1+delta),log_xyz.push(xyz)}}}return log_xyz}(data.features,d,this.state.well,this.state.selection,this.props.logrunName,this.props.lineStyle?.color),getColor:d=>function getLogColor1(wells_data,d,selectedWell,selection,logrun_name){if(!selection||selectedWell!==d.header.well)return[];const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_mds=getWellMds(well_object),log_mds=getLogMd(d,logrun_name);if(!log_mds||0===log_mds.length)return[];const log_color=[];let md0=selection[0];if(void 0!==md0){const mdFirst=well_mds[0],mdLast=well_mds[well_mds.length-1];let md1=selection[1];md1==md0&&(md1=void 0);let swap=!1;if(void 0!==md1&&md0>md1){const tmp=md0;md0=md1,md1=tmp,swap=!0}const delta=2;if(md0-delta>mdFirst&&log_color.push(swap?[0,255,0,128]:[255,0,0,128]),void 0!==md1){const _md1=md1;log_color.push([128,128,128,128]),well_mds.forEach((md=>{md0<=md&&md<=_md1&&log_color.push([128,128,128,128])})),_md1+delta<mdLast&&log_color.push(swap?[255,0,0,128]:[0,255,0,128])}}return log_color}(data.features,d,this.state.well,this.state.selection,this.props.logrunName),getWidth:d=>1.5*this.props.logRadius||getLogWidth(d,this.props.logrunName,this.props.logName),updateTriggers:{getColor:[this.props.logrunName,this.state.well,this.state.selection],getWidth:[this.props.logrunName,this.props.logName,this.props.logRadius],getPath:["XYZ",this.props.logrunName,this.state.well,this.state.selection]},onDataLoad:value=>{this.setLegend(value)},parameters:parameters})),new text_layer.Z(this.getSubLayerProps({id:"names",data:data.features,visible:this.props.wellNameVisible,getPosition:d=>function getAnnotationPosition(well_data,name_at_top,view_is_3d,color_accessor){if(name_at_top){let top;const well_head=getWellHeadPosition(well_data);if(well_data)top=well_head;else{const trajectory=getTrajectory(well_data,color_accessor);top=trajectory?.at(0)}if(top)return view_is_3d?top:[top[0],top[1],0]}else{let bot;const trajectory=getTrajectory(well_data,color_accessor);if(bot=trajectory?trajectory?.at(-1):getWellHeadPosition(well_data),bot)return view_is_3d?bot:[bot[0],bot[1],0]}return null}(d,this.props.wellNameAtTop,is3d,this.props.lineStyle?.color),getText:d=>d.properties?.name,getColor:this.props.wellNameColor,getAnchor:"start",getAlignmentBaseline:"bottom",getSize:this.props.wellNameSize,parameters:parameters}))]}getPickingInfo({info:info}){if(!info.object)return{...info,properties:[],logName:""};const coordinate=info.coordinate||[0,0,0];let md_property=function getMdProperty(coord,feature,accessor,featureType){if("points"===featureType)return null;const md=function getMd(coord,feature,accessor){if(!feature.properties?.md?.[0]||!feature.geometry)return null;const measured_depths=feature.properties.md[0],trajectory3D=getTrajectory(feature,accessor);if(null==trajectory3D)return null;let trajectory;if(2==coord.length){trajectory=trajectory3D.map((v=>v.slice(0,2)))}else trajectory=trajectory3D;return interpolateDataOnTrajectory(coord,measured_depths,trajectory)}(coord,feature,accessor);if(null!=md){const prop_name="MD "+feature.properties?.name;return(0,layerTools.ws)(prop_name,md,feature.properties?.color)}return null}(coordinate,info.object,this.props.lineStyle?.color,info.featureType);md_property||(md_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,"MD"));let tvd_property=function getTvdProperty(coord,feature,accessor,featureType){if("points"===featureType)return null;const tvd=function getTvd(coord,feature,accessor){const trajectory3D=getTrajectory(feature,accessor);if(null==trajectory3D||trajectory3D?.length<=1){const wellhead_xyz=getWellHeadPosition(feature);return wellhead_xyz?.[2]??null}let trajectory;if(2==coord.length){const trajectory2D=trajectory3D?.map((v=>v.slice(0,2)));trajectory=trajectory2D}else trajectory=trajectory3D;const tvds=trajectory3D.map((v=>v[2]));return interpolateDataOnTrajectory(coord,tvds,trajectory)}(coord,feature,accessor);if(null!=tvd){const prop_name="TVD "+feature.properties?.name;return(0,layerTools.ws)(prop_name,tvd,feature.properties?.color)}return null}(coordinate,info.object,this.props.lineStyle?.color,info.featureType);tvd_property||(tvd_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,"TVD"));const log_property=getLogProperty(coordinate,this.props.data.features,info.object,this.props.logrunName,this.props.logName),inverted_tvd_property=tvd_property&&{...tvd_property,value:-1*tvd_property?.value},layer_properties=[];return md_property&&layer_properties.push(md_property),inverted_tvd_property&&layer_properties.push(inverted_tvd_property),log_property&&layer_properties.push(log_property),{...info,properties:layer_properties,logName:log_property?.name||""}}}function getColumn(data,col){const column=[];for(let i=0;i<data.length;i++)column.push(data[i][col]);return column}function getLogMd(d,logrun_name){if(!isSelectedLogRun(d,logrun_name))return[];const log_id=function getLogIndexByNames(d,names){for(const name of names){const index=getLogIndexByName(d,name);if(index>=0)return index}return-1}(d,["DEPTH","DEPT","MD","TDEP","MD_RKB"]);return log_id>=0?getColumn(d.data,log_id):[]}function getLogValues(d,logrun_name,log_name){if(!isSelectedLogRun(d,logrun_name))return[];const log_id=getLogIndexByName(d,log_name);return log_id>=0?getColumn(d.data,log_id):[]}function getLogInfo(d,logrun_name,log_name){if(!isSelectedLogRun(d,logrun_name))return;const log_id=getLogIndexByName(d,log_name);return d.curves[log_id]}function getDiscreteLogMetadata(d,log_name){return d?.metadata_discrete[log_name]}function isSelectedLogRun(d,logrun_name){return d.header.name.toLowerCase()===logrun_name.toLowerCase()}function getWellObjectByName(wells_data,name){return wells_data?.find((item=>item.properties?.name?.toLowerCase()===name?.toLowerCase()))}function getWellObjectsByName(wells_data,name){const res=[];for(let i=0;i<name?.length;i++)wells_data?.find((item=>{item.properties?.name?.toLowerCase()===name[i]?.toLowerCase()&&res.push(item)}));return res}function getWellHeadPosition(well_object){return function getPointGeometry(well_object){return well_object.geometry?.geometries.find((item=>"Point"==item.type))}(well_object)?.coordinates}function getTrajectory(well_object,color_accessor){return function isTrajectoryVisible(well_object,color_accessor){let alpha;const accessor=getColor(color_accessor);return alpha="function"==typeof accessor?accessor(well_object)?.[3]:accessor?.[3],0!==alpha}(well_object,color_accessor)?function getLineStringGeometry(well_object){return well_object.geometry?.geometries.find((item=>"LineString"==item.type))}(well_object)?.coordinates:void 0}function getWellMds(well_object){return well_object.properties?.md[0]}function getPositionByMD(well_xyz,well_mds,md){const[l_idx,h_idx]=function getNeighboringMdIndices(mds,md){const idx=mds.findIndex((x=>x>=md));return 0===idx?[idx,idx+1]:[idx-1,idx]}(well_mds,md),md_low=well_mds[l_idx],md_normalized=(md-md_low)/(well_mds[h_idx]-md_low);return(0,src.qNB)(well_xyz[l_idx],well_xyz[h_idx])(md_normalized)}function getLogPath(wells_data,d,logrun_name,trajectory_line_color){const well_object=getWellObjectByName(wells_data,d.header.well);if(!well_object)return[];const well_xyz=getTrajectory(well_object,trajectory_line_color),well_mds=getWellMds(well_object);if(null==well_xyz||null==well_mds||0==well_xyz.length||0==well_mds.length)return[];const log_xyz=[];return getLogMd(d,logrun_name).forEach((md=>{const xyz=getPositionByMD(well_xyz,well_mds,md);log_xyz.push(xyz)})),log_xyz}function getLogIndexByName(d,log_name){const name=log_name.toLowerCase();return d.curves.findIndex((item=>item.name.toLowerCase()===name))}function getLogWidth(d,logrun_name,log_name){return getLogValues(d,logrun_name,log_name)}function squared_distance(a,b){const dx=a[0]-b[0],dy=a[1]-b[1];return dx*dx+dy*dy}function distToSegmentSquared(v,w,p){const l2=squared_distance(v,w);if(0==l2)return squared_distance(p,v);let t=((p[0]-v[0])*(w[0]-v[0])+(p[1]-v[1])*(w[1]-v[1]))/l2;return t=Math.max(0,Math.min(1,t)),squared_distance(p,[v[0]+t*(w[0]-v[0]),v[1]+t*(w[1]-v[1])])}function interpolateDataOnTrajectory(coord,data,trajectory){if(data.length<=1||data.length!=trajectory.length)return-1;const index0=getSegmentIndex(coord,trajectory),index1=index0+1,data0=data[index0],data1=data[index1],survey0=trajectory[index0],survey1=trajectory[index1],dv=(0,pureFunctionsAny_generated.TE$)(survey0,survey1);if(0===dv)return-1;const v0=(0,pureFunctionsAny_generated.$XF)(coord,survey0),v1=(0,pureFunctionsAny_generated.$XF)(survey1,survey0),scalar_projection=(0,pureFunctionsAny_generated.AKD)(v0,v1)/(dv*dv);return data0*(1-scalar_projection)+data1*scalar_projection}function getSegmentIndex(coord,path){let min_d=Number.MAX_VALUE,segment_index=0;for(let i=0;i<path?.length-1;i++){const d=distToSegmentSquared(path[i],path[i+1],coord);d>min_d||(segment_index=i,min_d=d)}return segment_index}function getLogProperty(coord,wells_data,log_data,logrun_name,log_name){if(!log_data.data)return null;const segment_index=function getLogSegmentIndex(coord,wells_data,log_data,logrun_name){return getSegmentIndex(coord,getLogPath(wells_data,log_data,logrun_name))}(coord,wells_data,log_data,logrun_name);let dl_attrs,log_value=getLogValues(log_data,logrun_name,log_name)[segment_index];const dl_metadata=getDiscreteLogMetadata(log_data,log_name)?.objects;dl_metadata&&(dl_attrs=Object.entries(dl_metadata).find((([,value])=>value[1]==log_value)));const log=getLogInfo(log_data,logrun_name,log_name)?.name,prop_name=log+" "+log_data.header.well;if(log_value=dl_attrs?dl_attrs[0]+" ("+log_value+")":log_value,log_value){const well_object=getWellObjectByName(wells_data,log_data.header.well);return(0,layerTools.ws)(prop_name,log_value,well_object?.properties?.color)}return null}WellsLayer.layerName="WellsLayer",WellsLayer.defaultProps={"@@type":"WellsLayer",name:"Wells",id:"wells-layer",autoHighlight:!0,opacity:1,lineWidthScale:1,pointRadiusScale:1,lineStyle:{dash:!1},outline:!0,logRadius:10,logCurves:!0,refine:!1,visible:!0,wellNameVisible:!1,wellNameAtTop:!1,wellNameSize:14,wellNameColor:[0,0,0,255],selectedWell:"@@#editedData.selectedWells",depthTest:!0,ZIncreasingDownwards:!0,onDataLoad:(data,context)=>function onDataLoad(data,context){const bbox=function GetBoundingBox(data){let xMin=9999999999,yMin=9999999999,zMin=9999999999,xMax=-9999999999,yMax=-9999999999,zMax=-9999999999;const no_wells=data.features.length;for(let well_no=0;well_no<no_wells;well_no++){const geometryCollection=data.features[well_no].geometry,lineString=geometryCollection?.geometries[1];if(void 0===lineString.coordinates?.length)continue;const coords=lineString.coordinates,n=coords.length;for(let i=0;i<n;i++){const xyz=coords[i];xMin=xyz[0]<xMin?xyz[0]:xMin,yMin=xyz[1]<yMin?xyz[1]:yMin,zMin=xyz[2]<zMin?xyz[2]:zMin,xMax=xyz[0]>xMax?xyz[0]:xMax,yMax=xyz[1]>yMax?xyz[1]:yMax,zMax=xyz[2]>zMax?xyz[2]:zMax}}return[xMin,yMin,zMin,xMax,yMax,zMax]}(data);void 0!==context.layer.props.setReportedBoundingBox&&context.layer.props.setReportedBoundingBox(bbox)}(data,context)}},"./packages/subsurface-viewer/src/viewports/intersectionViewport.ts":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Z:function(){return IntersectionViewport}});var _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@math.gl/core/dist/esm/classes/matrix4.js"),_math_gl_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@math.gl/core/dist/esm/lib/common.js");const viewMatrix=(new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__.Z).lookAt({eye:[0,-1,0],up:[0,0,1],center:[0,0,0]});function getProjectionMatrix({width:width,height:height,near:near,far:far,padding:padding}){let left=-width/2,right=width/2,bottom=-height/2,top=height/2;if(padding){const{left:l=0,right:r=0,top:t=0,bottom:b=0}=padding,offsetX=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.uZ)((l+width-r)/2,0,width)-width/2,offsetY=(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.uZ)((t+height-b)/2,0,height)-height/2;left-=offsetX,right-=offsetX,bottom+=offsetY,top+=offsetY}return(new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__.Z).ortho({left:left,right:right,bottom:bottom,top:top,near:near,far:far})}class IntersectionViewport extends _deck_gl_core_typed__WEBPACK_IMPORTED_MODULE_2__.Z{constructor(props){const{width:width,height:height,near:near=.1,far:far=1e3,zoom:zoom=0,target:target=[0,0,0],padding:padding=null,flipY:flipY=!0}=props,zoomX=Array.isArray(zoom)?zoom[0]:zoom,zoomY=Array.isArray(zoom)?zoom[1]:zoom,zoom_=Math.min(zoomX,zoomY),scale=Math.pow(2,zoom_);let distanceScales;if(zoomX!==zoomY){const scaleX=Math.pow(2,zoomX),scaleY=Math.pow(2,zoomY);distanceScales={unitsPerMeter:[scaleX/scale,1,scaleY/scale],metersPerUnit:[scale/scaleX,1,scale/scaleY]}}super({...props,longitude:void 0,position:target,viewMatrix:viewMatrix.clone().scale([scale,scale,scale*(flipY?-1:1)]),projectionMatrix:getProjectionMatrix({width:width||1,height:height||1,padding:padding,near:near,far:far}),zoom:zoom_,distanceScales:distanceScales})}}},"?b079":function(){},"?d4c0":function(){}}]);